<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>详解skynet 频发的重入问题</title>
    <link href="/2024/03/24/skynet_frame/reent/"/>
    <url>/2024/03/24/skynet_frame/reent/</url>
    
    <content type="html"><![CDATA[<h1 id="例子说明"><a href="#例子说明" class="headerlink" title="例子说明"></a>例子说明</h1><p>我们假设有2个服务，1个用户。<br><strong>银行服务</strong> 提供<strong>转账</strong>。<br><strong>分控服务</strong> 对用户进行风控，提供<strong>阻止转账取款功能</strong>。<br><strong>用户一</strong> 用手机<strong>转账</strong>。</p><p>bank_service.lua</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> account_amonut_map = &#123;&#125;   <span class="hljs-comment">--账户余额</span><br><span class="hljs-keyword">local</span> CMD = &#123;&#125;<br><span class="hljs-comment">--转账</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CMD.transfer</span><span class="hljs-params">(from_account, to_account, num)</span></span><br>    <span class="hljs-keyword">local</span> amonut = account_amonut_map[from_account] <span class="hljs-keyword">or</span> <span class="hljs-number">0</span><br>    <span class="hljs-keyword">if</span> amonut &lt; num <span class="hljs-keyword">then</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> <span class="hljs-comment">--余额不足</span><br>    <span class="hljs-keyword">end</span><br><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> skynet.call(<span class="hljs-string">&quot;.control_service&quot;</span>, <span class="hljs-string">&#x27;lua&#x27;</span>, <span class="hljs-string">&#x27;control&#x27;</span>, from_account, num) <span class="hljs-keyword">then</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    <span class="hljs-keyword">end</span><br><br>    <span class="hljs-keyword">local</span> to_amonut = account_amonut_map[to_account] <span class="hljs-keyword">or</span> <span class="hljs-number">0</span><br>    account_amonut_map[from_account] = amonut - num<br>    account_amonut_map[to_account] = to_amonut + num<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br><span class="hljs-keyword">end</span><br><br></code></pre></td></tr></table></figure><p>control_service.lua</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> CMD = &#123;&#125;<br><span class="hljs-comment">--分控查询 默认允许</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CMD.control</span><span class="hljs-params">(account, num)</span></span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span> <br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>client.lua</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">--user_1给user_2转一千</span><br>skynet.call(<span class="hljs-string">&#x27;.bank_service&#x27;</span>, <span class="hljs-string">&#x27;lua&#x27;</span>, <span class="hljs-string">&#x27;transfer&#x27;</span>, <span class="hljs-string">&#x27;user_1&#x27;</span>, <span class="hljs-string">&#x27;user_2&#x27;</span>, <span class="hljs-number">1000</span>)<br></code></pre></td></tr></table></figure><p>我们可以看到处理的流程是这样的:</p><ol><li>client-&gt;bank_service(transfer)</li><li>bank_service判断用余额是否足够</li><li>不够返回失败</li><li>够，bank_service-&gt;control_service(control)</li><li>control_service判断是否风控</li><li>是返回失败</li><li>否返回成功</li><li>bank_service根据结果决定操作</li><li>没风控，执行转账</li><li>风控了，返回失败</li></ol><p>这段逻辑按照<strong>串行</strong>执行，没有问题。但是<code>skynet.call</code>是一个rpc操作，有异步挂起，流程从<strong>串行</strong>变成了<strong>并发</strong>。<br>bank_service会在发送<code>control</code>消息后挂起等待control_service回复之后继续处理该执行流。但是问题是bank_service它不是<strong>阻塞</strong>等待。<br>它还能处理其他请求，挂起的仅仅是之前那个请求而已。</p><p>现在我们可以假设用户有：<br>余额1000</p><p>用户手很快，连续点了两下触发了并发。                                                 </p><ol><li>（请求1）client-&gt;bank_service(transfer(1000))                 </li><li>（请求1）bank_service判断用余额是否足够                       </li><li>（请求1）够 bank_service-&gt;control_service(control) <strong>挂起</strong></li><li>（请求2）client-&gt;bank_service(transfer(1000))   </li><li>（请求2）bank_service判断用余额是否足够     </li><li>（请求2）够 bank_service-&gt;control_service(control) <strong>挂起</strong></li><li>（请求1）收到回复没有风控，扣款1000，余额0。</li><li>（请求2）收到回复没有风控，扣款1000，余额-1000。<strong>震惊</strong>，见鬼的bug出现了。</li></ol><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h2 id="并发改串行"><a href="#并发改串行" class="headerlink" title="并发改串行"></a>并发改串行</h2><p>利用skynet.queue，把执行流串行化，是最简单的方案。</p><p>bank_service.lua</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> queue = <span class="hljs-built_in">require</span> <span class="hljs-string">&quot;skynet.queue&quot;</span>()<br><span class="hljs-keyword">local</span> account_amonut_map = &#123;&#125;   <span class="hljs-comment">--账户余额</span><br><span class="hljs-keyword">local</span> CMD = &#123;&#125;<br><span class="hljs-comment">--转账</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CMD.transfer</span><span class="hljs-params">(from_account, to_account, num)</span></span><br>    <span class="hljs-keyword">return</span> queue(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span><br>        <span class="hljs-keyword">local</span> amonut = account_amonut_map[from_account] <span class="hljs-keyword">or</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">if</span> amonut &lt; num <span class="hljs-keyword">then</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> <span class="hljs-comment">--余额不足</span><br>        <span class="hljs-keyword">end</span><br><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> skynet.call(<span class="hljs-string">&quot;.control_service&quot;</span>, <span class="hljs-string">&#x27;lua&#x27;</span>, <span class="hljs-string">&#x27;control&#x27;</span>, from_account, num) <span class="hljs-keyword">then</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        <span class="hljs-keyword">end</span><br><br>        <span class="hljs-keyword">local</span> to_amonut = account_amonut_map[to_account] <span class="hljs-keyword">or</span> <span class="hljs-number">0</span><br>        account_amonut_map[from_account] = amonut - num<br>        account_amonut_map[to_account] = to_amonut + num<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    <span class="hljs-keyword">end</span>)<br><span class="hljs-keyword">end</span><br><br></code></pre></td></tr></table></figure><p>这样处理流程就变成了(请求1开始-&gt;结束)(请求2开始-&gt;结束)，这个处理请求不可能再并发了。</p><h2 id="并发锁拒绝并发处理"><a href="#并发锁拒绝并发处理" class="headerlink" title="并发锁拒绝并发处理"></a>并发锁拒绝并发处理</h2><p>bank_service.lua</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> g_transfering = &#123;&#125;<br><span class="hljs-keyword">local</span> queue = <span class="hljs-built_in">require</span> <span class="hljs-string">&quot;skynet.queue&quot;</span>()<br><span class="hljs-keyword">local</span> account_amonut_map = &#123;&#125;   <span class="hljs-comment">--账户余额</span><br><span class="hljs-keyword">local</span> CMD = &#123;&#125;<br><span class="hljs-comment">--转账</span><br><span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">transfer</span><span class="hljs-params">(from_account, to_account, num)</span></span><br>    <span class="hljs-keyword">local</span> amonut = account_amonut_map[from_account] <span class="hljs-keyword">or</span> <span class="hljs-number">0</span><br>    <span class="hljs-keyword">if</span> amonut &lt; num <span class="hljs-keyword">then</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> <span class="hljs-comment">--余额不足</span><br>    <span class="hljs-keyword">end</span><br><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> skynet.call(<span class="hljs-string">&quot;.control_service&quot;</span>, <span class="hljs-string">&#x27;lua&#x27;</span>, <span class="hljs-string">&#x27;control&#x27;</span>, from_account, num) <span class="hljs-keyword">then</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    <span class="hljs-keyword">end</span><br><br>    <span class="hljs-keyword">local</span> to_amonut = account_amonut_map[to_account] <span class="hljs-keyword">or</span> <span class="hljs-number">0</span><br>    account_amonut_map[from_account] = amonut - num<br>    account_amonut_map[to_account] = to_amonut + num<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CMD.transfer</span><span class="hljs-params">(from_account, to_account, num)</span></span><br>    <span class="hljs-keyword">if</span> g_transfering[from_account] <span class="hljs-keyword">then</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    <span class="hljs-keyword">end</span><br>    g_transfering[from_account] = <span class="hljs-literal">true</span><br>    <span class="hljs-keyword">local</span> ret = transfer(from_account, to_account, num)<br>    g_transfering[from_account] = <span class="hljs-literal">false</span><br><br>    <span class="hljs-keyword">return</span> ret<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>这样不会并发了，拒绝同时转账。</p><h2 id="前置扣款"><a href="#前置扣款" class="headerlink" title="前置扣款"></a>前置扣款</h2><p>bank_service.lua</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> account_amonut_map = &#123;&#125;   <span class="hljs-comment">--账户余额</span><br><span class="hljs-keyword">local</span> CMD = &#123;&#125;<br><span class="hljs-comment">--转账</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CMD.transfer</span><span class="hljs-params">(from_account, to_account, num)</span></span><br>    <span class="hljs-keyword">local</span> amonut = account_amonut_map[from_account] <span class="hljs-keyword">or</span> <span class="hljs-number">0</span><br>    <span class="hljs-keyword">if</span> amonut &lt; num <span class="hljs-keyword">then</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> <span class="hljs-comment">--余额不足</span><br>    <span class="hljs-keyword">end</span><br><br>    account_amonut_map[from_account] = amonut - num<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> skynet.call(<span class="hljs-string">&quot;.control_service&quot;</span>, <span class="hljs-string">&#x27;lua&#x27;</span>, <span class="hljs-string">&#x27;control&#x27;</span>, from_account, num) <span class="hljs-keyword">then</span><br>     account_amonut_map[from_account] = amonut + num<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    <span class="hljs-keyword">end</span><br><br>    <span class="hljs-keyword">local</span> to_amonut = account_amonut_map[to_account] <span class="hljs-keyword">or</span> <span class="hljs-number">0</span><br>    account_amonut_map[to_account] = to_amonut + num<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br><span class="hljs-keyword">end</span><br><br></code></pre></td></tr></table></figure><h2 id="双重判断"><a href="#双重判断" class="headerlink" title="双重判断"></a>双重判断</h2><p>bank_service.lua</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> account_amonut_map = &#123;&#125;   <span class="hljs-comment">--账户余额</span><br><span class="hljs-keyword">local</span> CMD = &#123;&#125;<br><span class="hljs-comment">--转账</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CMD.transfer</span><span class="hljs-params">(from_account, to_account, num)</span></span><br>    <span class="hljs-keyword">local</span> amonut = account_amonut_map[from_account] <span class="hljs-keyword">or</span> <span class="hljs-number">0</span><br>    <span class="hljs-keyword">if</span> amonut &lt; num <span class="hljs-keyword">then</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> <span class="hljs-comment">--余额不足</span><br>    <span class="hljs-keyword">end</span><br><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> skynet.call(<span class="hljs-string">&quot;.control_service&quot;</span>, <span class="hljs-string">&#x27;lua&#x27;</span>, <span class="hljs-string">&#x27;control&#x27;</span>, from_account, num) <span class="hljs-keyword">then</span> <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    <span class="hljs-keyword">end</span><br><br>    amonut = account_amonut_map[from_account] <span class="hljs-keyword">or</span> <span class="hljs-number">0</span><br>    <span class="hljs-keyword">if</span> amonut &lt; num <span class="hljs-keyword">then</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> <span class="hljs-comment">--余额不足</span><br>    <span class="hljs-keyword">end</span><br><br>    account_amonut_map[from_account] = amonut + num<br>    <span class="hljs-keyword">local</span> to_amonut = account_amonut_map[to_account] <span class="hljs-keyword">or</span> <span class="hljs-number">0</span><br>    account_amonut_map[to_account] = to_amonut + num<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br><span class="hljs-keyword">end</span><br><br></code></pre></td></tr></table></figure><p>这样能并发，也不会出问题。</p><h1 id="只有skynet有并发重入问题吗？"><a href="#只有skynet有并发重入问题吗？" class="headerlink" title="只有skynet有并发重入问题吗？"></a>只有skynet有并发重入问题吗？</h1><p>只要存在<strong>并发</strong>，都会有这个问题，包括传统的<strong>使用异步消息回调</strong>，而不使用<strong>rpc</strong>调用也存在此问题。</p><p>异步回调无非是这样子，用skynet模拟。</p><p>bank_service.lua</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> account_amonut_map = &#123;&#125;   <span class="hljs-comment">--账户余额</span><br><span class="hljs-keyword">local</span> CMD = &#123;&#125;<br><span class="hljs-comment">--转账</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CMD.transfer</span><span class="hljs-params">(from_account, to_account, num)</span></span><br>    <span class="hljs-keyword">local</span> amonut = account_amonut_map[from_account] <span class="hljs-keyword">or</span> <span class="hljs-number">0</span><br>    <span class="hljs-keyword">if</span> amonut &lt; num <span class="hljs-keyword">then</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> <span class="hljs-comment">--余额不足</span><br>    <span class="hljs-keyword">end</span><br><br>    skynet.send(<span class="hljs-string">&quot;.control_service&quot;</span>, <span class="hljs-string">&#x27;lua&#x27;</span>, <span class="hljs-string">&#x27;control&#x27;</span>, from_account, num)<br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">--回调消息处理</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CMD.transfer_callback</span><span class="hljs-params">(ret)</span></span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> ret <span class="hljs-keyword">then</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">end</span><br><br>    account_amonut_map[from_account] = amonut + num<br>    <span class="hljs-keyword">local</span> to_amonut = account_amonut_map[to_account] <span class="hljs-keyword">or</span> <span class="hljs-number">0</span><br>    account_amonut_map[to_account] = to_amonut + num<br><br>    <span class="hljs-comment">--回复客户端成功</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>这样，只要服务端是支持并发的，就也会存在问题。</p>]]></content>
    
    
    <categories>
      
      <category>skynet</category>
      
    </categories>
    
    
    <tags>
      
      <tag>skynet_frame</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于skynet_fly_demo的架构设计</title>
    <link href="/2024/02/17/think/skynet_fly_demo/"/>
    <url>/2024/02/17/think/skynet_fly_demo/</url>
    
    <content type="html"><![CDATA[<h1 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h1><p><img src="/img/think/skynet_fly_demo.png"></p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>skynet_fly_demo是基于skynet_fly框架，开发对战类游戏架构，适用于<code>moba</code>、<code>棋牌</code>类游戏架构。</p><h1 id="各服务职责"><a href="#各服务职责" class="headerlink" title="各服务职责"></a>各服务职责</h1><h2 id="center-server-中心服"><a href="#center-server-中心服" class="headerlink" title="center server 中心服"></a>center server 中心服</h2><ul><li>记录用户账户信息，比如账号，密码，手机号，注册渠道，设备号，平台等等信息。</li><li>记录用户创角信息，比如玩家ID，归属大厅服ID等等。</li><li>可以记录一些全局唯一的信息，比如登录的公告信息等等。</li><li>验证登录服登录。</li></ul><h2 id="login-server-登录服"><a href="#login-server-登录服" class="headerlink" title="login server 登录服"></a>login server 登录服</h2><ul><li>登录限流，防止突发的流量挤爆<strong>中心服</strong>。</li></ul><h2 id="hall-server-大厅服"><a href="#hall-server-大厅服" class="headerlink" title="hall server 大厅服"></a>hall server 大厅服</h2><ul><li>签发token， 验证登录。</li><li>负责大厅的商城，活动，任务，邮件，等等交互逻辑。</li></ul><h2 id="log-server-日志服"><a href="#log-server-日志服" class="headerlink" title="log server 日志服"></a>log server 日志服</h2><ul><li>记录所有服务的错误日志。</li><li>记录玩家的行为日志。</li><li>记录游戏的记录日志。</li><li>等等。</li></ul><h2 id="match-server-匹配服"><a href="#match-server-匹配服" class="headerlink" title="match server 匹配服"></a>match server 匹配服</h2><ul><li>匹配玩家，分配公共的游戏房间供玩家进入。</li></ul><h2 id="game-server-游戏服"><a href="#game-server-游戏服" class="headerlink" title="game server 游戏服"></a>game server 游戏服</h2><ul><li>实现具体的游戏逻辑。</li></ul><h2 id="admin-server-后台服"><a href="#admin-server-后台服" class="headerlink" title="admin server 后台服"></a>admin server 后台服</h2><ul><li>服务监控。</li><li>数据看板等等。</li><li>后台相关需求。</li></ul><h1 id="各服务功能细节"><a href="#各服务功能细节" class="headerlink" title="各服务功能细节"></a>各服务功能细节</h1><h2 id="admin-server-后台服-1"><a href="#admin-server-后台服-1" class="headerlink" title="admin server 后台服"></a>admin server 后台服</h2><p>使用skynet_fly(后端) + vue(前端)架构。</p><ul><li><p>服务监控<br><img src="/img/think/server_monitor.png"><br><strong>后台服</strong>会间隔一分钟去采集各个服务节点的运行信息。目前实现仅仅保留7天的采集信息。</p></li><li><p>实时列表<br><img src="/img/think/real_list.png"><br>查看各个服务节点当前运行信息。</p></li><li><p>警告日志<br><img src="/img/think/warnlog.png"><br>各个服务节点的严重错误日志，或者断言错误都会汇总到这里，方便查看解决。</p></li><li><p>后台角色权限管理<br><img src="/img/think/roles.png"><br>通过角色权限划分，不同角色有不同的访问权限。</p></li><li><p>后台用户管理<br><img src="/img/think/user.png"><br>可以管理不同的后台账号。</p></li></ul><p>后续功能待补充。</p><h2 id="center-server-中心服-1"><a href="#center-server-中心服-1" class="headerlink" title="center server 中心服"></a>center server 中心服</h2><p>中心服只有一个，记录了全服玩家的账号信息，账号信息需要考虑分表，负责对<strong>玩家id</strong>的分配(保证全服唯一，方便后续做合服处理)，玩家归属的<strong>大厅服</strong>的分配。</p><h2 id="login-server-登录服-1"><a href="#login-server-登录服-1" class="headerlink" title="login server 登录服"></a>login server 登录服</h2><p>提供账号注册功能，登录限流。</p><h2 id="hall-server-大厅服-1"><a href="#hall-server-大厅服-1" class="headerlink" title="hall server 大厅服"></a>hall server 大厅服</h2><p>每个玩家只能归属一个大厅服，这样玩家的数据能够固定使用rpc调用从大厅服拿取。</p><h2 id="log-server-日志服-1"><a href="#log-server-日志服-1" class="headerlink" title="log server 日志服"></a>log server 日志服</h2><p>警号日志收集</p><h2 id="game-server-游戏服-1"><a href="#game-server-游戏服-1" class="headerlink" title="game server 游戏服"></a>game server 游戏服</h2><p>中国象棋游戏</p><h2 id="match-server-匹配服-1"><a href="#match-server-匹配服-1" class="headerlink" title="match server 匹配服"></a>match server 匹配服</h2><p>负责游戏房间匹配</p><h2 id="robot-server-机器人服"><a href="#robot-server-机器人服" class="headerlink" title="robot server 机器人服"></a>robot server 机器人服</h2><p>负责具体游戏的机器人补充</p><h2 id="游戏"><a href="#游戏" class="headerlink" title="游戏"></a>游戏</h2><html><head>  <base href="https://huahua132.github.io/"></head><body>  <video width="960" height="720" controls>    <source src="video/chess.mp4" type="video/mp4">    Your browser does not support the video tag.  </video></body></html>]]></content>
    
    
    <categories>
      
      <category>一些想法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>一些想法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于监听同步模块的封装</title>
    <link href="/2024/01/28/skynet_fly_ss/watch_syn/"/>
    <url>/2024/01/28/skynet_fly_ss/watch_syn/</url>
    
    <content type="html"><![CDATA[<h1 id="为啥需要封装一个监听同步模块？"><a href="#为啥需要封装一个监听同步模块？" class="headerlink" title="为啥需要封装一个监听同步模块？"></a>为啥需要封装一个监听同步模块？</h1><p>使用<code>skynet</code>开发功能，由于是actor模型，难免会遇到一个服务需要依赖另一个服务的数据的情况，解决这个问题常见的方案有：</p><ol><li><p><strong>封装一个c模块，用于共享数据</strong><br> <strong>优点</strong>：</p><ul><li>API使用简单，get set 即可。</li><li>节省内存。</li></ul><p> <strong>缺点</strong>：</p><ul><li>编码难度大，风险高，需要处理好多线程编码问题。</li><li>需要加读写锁，读取性能不一定高。</li><li>lua调用c，没有直接访问lua快。</li></ul></li><li><p><strong>要用的时候去查询</strong><br> <strong>优点</strong>:</p><ul><li>实现简单，简单call调用即可。</li></ul><p> <strong>缺点</strong>：</p><ul><li>对于过于频繁的请求，并不是一个很好的方案。</li><li>查询数据量大时，对性能有影响。(频繁的打包，解包，生成临时的<code>lua</code>表，增加lua gc 负担)</li></ul></li><li><p><strong>watch_syn监听同步机制</strong><br> <strong>优点</strong>：</p><ul><li>实现难度适中。</li><li>API调用简单。</li><li>数据本地持有，访问迅速。</li><li>更新通知，无需频繁请求。</li></ul><p> <strong>缺点</strong>：</p><ul><li>如果是频繁更新的数据，效果与第二方案没有多大差异。</li></ul></li></ol><h1 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h1><h2 id="skynet的share-datad-lua"><a href="#skynet的share-datad-lua" class="headerlink" title="skynet的share_datad.lua"></a>skynet的share_datad.lua</h2><p>我学习到使用这种机制，是通过翻看share_datad的源码，share_data通过监听同步机制来实现对共享配置的热更。</p><h2 id="skynet-flycontriner-mgr-lua"><a href="#skynet-flycontriner-mgr-lua" class="headerlink" title="skynet_flycontriner_mgr.lua"></a>skynet_fly<a href="https://github.com/huahua132/skynet_fly/blob/master/service/contriner_mgr.lua">contriner_mgr.lua</a></h2><p>skynet_fly使用这种方式，通知热更后服务地址的变更。</p><h2 id="skynet-flymonitor-exit-lua"><a href="#skynet-flymonitor-exit-lua" class="headerlink" title="skynet_flymonitor_exit.lua"></a>skynet_fly<a href="https://github.com/huahua132/skynet_fly/blob/master/service/monitor_exit.lua">monitor_exit.lua</a></h2><p>skynet_fly使用这种方式，监听服务退出。</p><h2 id="skynet-fly-demomonitor-exit-lua"><a href="#skynet-fly-demomonitor-exit-lua" class="headerlink" title="skynet_fly_demomonitor_exit.lua"></a>skynet_fly_demo<a href="https://github.com/huahua132/skynet_fly_demo/blob/master/admin/admin_server/module/signature_m.lua">monitor_exit.lua</a></h2><p>skynet_fly_demo使用这种方式，通知密钥变更。</p><p>所以说，这种机制开发中，挺常用的，所有就打算写一个通用模块，以便以后使用直接引入即可，不需要去关心实现rpc的细节了。</p><h1 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h1><h2 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h2><p><strong>监听同步机制中</strong>分为两个角色，<strong>发布者</strong>，<strong>订阅者</strong>，在代码中，我把他们分别称为<strong>server</strong>,<strong>client</strong>,<strong>server</strong>只有1个，<strong>client</strong>可以有多个，<strong>server</strong>可以<strong>发布</strong>多个key-value值，<br><strong>client</strong>也可以监听多个key-value值，其中<strong>key</strong>是string，<strong>value</strong>，可以是string,number,bool,nil,table。<strong>client</strong>可以有多个，但是同一个服务里只有一个对应<strong>server</strong>的访问实例，因为<strong>server</strong>是以<strong>client</strong>服务地址为key记录来访，通常一个<strong>订阅者</strong>也不需要创建2个以上<strong>发布者</strong>访问实例。</p><h2 id="机制链路"><a href="#机制链路" class="headerlink" title="机制链路"></a>机制链路</h2><ol><li><strong>server</strong>首先注册key-value,生成对应版本号为1。</li><li><strong>client</strong>C2S 监听key，传递版本号首次为空。</li><li><strong>server</strong>S2C 接收到key，如果不是首次访问或者版本号不一致返回最新结果，版本号一直<strong>暂时不回复</strong>(<strong>client</strong>会挂起等待)。</li><li><strong>server</strong>S2C 当需要发布新值时，通知所有的监听的<strong>client</strong>。</li></ol><p>通过以上步骤完成对数据的同步。</p><h1 id="API"><a href="#API" class="headerlink" title="API"></a><a href="https://huahua132.github.io/2024/01/28/skynet_fly_api/watch_syn/">API</a></h1><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a><a href="https://github.com/huahua132/skynet_fly/tree/master/test/module/watch_test">测试</a></h1><p><a href="https://github.com/huahua132/skynet_fly">skynetfly源码地址</a></p>]]></content>
    
    
    <categories>
      
      <category>skynet_fly实现思路历程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>skynet_fly实现思路历程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>orm</title>
    <link href="/2024/01/28/skynet_fly_api/orm/"/>
    <url>/2024/01/28/skynet_fly_api/orm/</url>
    
    <content type="html"><![CDATA[<h1 id="ormentry-lua"><a href="#ormentry-lua" class="headerlink" title="ormentry.lua"></a><a href="https://github.com/huahua132/skynet_fly/blob/master/lualib/skynet-fly/db/orm/ormentry.lua">ormentry.lua</a></h1><p>单条数据条目对象。</p><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><ul><li><p><strong>M:get(filed_name)</strong><br>  函数作用域：M:new 对象的成员函数<br>  函数名称：get<br>  描述:  获得对象指定字段的值<br>  参数:<br>  - filed_name (string): 字段名<br>  返回值:</p><ol><li>value(number or string): 值</li></ol></li><li><p><strong>M:set(filed_name, filed_value)</strong><br>  函数作用域：M:new 对象的成员函数<br>  函数名称：set<br>  描述:  修改条目数据的值<br>  参数:<br>  - filed_name (string): 字段名<br>  - filed_value (number or string): 字段值<br>  返回值:<br>  无</p></li><li><p><strong>M:get_entry_data()</strong><br>  函数作用域：M:new 对象的成员函数<br>  函数名称：get_entry_data<br>  描述:  获取所有数据<br>  参数:<br>  无<br>  返回值:</p><ol><li>value_map(table):数据表</li></ol></li></ul><h2 id="使用中通常不需要调用"><a href="#使用中通常不需要调用" class="headerlink" title="使用中通常不需要调用"></a>使用中通常不需要调用</h2><ul><li><p><strong>M:new(filed_name)</strong><br>通常只在<code>ormtable.lua</code>中调用，外部不需要调用。<br>  函数作用域：M 对象的成员函数<br>  函数名称：new<br>  描述:  新建条目数据对象<br>  参数:<br>  - ormtab (table): ormtable对象<br>  - entry_data(table): 数据表<br>  返回值:</p><ol><li>entry(table): entry对象</li></ol></li><li><p><strong>M:get_change_map()</strong><br>通常只在<code>ormtable.lua</code>中调用，外部不需要调用。<br>  函数作用域：M:new 对象的成员函数<br>  函数名称：get_change_map<br>  描述:  获取修改条目<br>  参数:<br>  无<br>  返回值:</p><ol><li>change_map(table):修改数据表</li></ol></li><li><p><strong>M:clear_change()</strong><br>通常只在<code>ormtable.lua</code>中调用，外部不需要调用。<br>  函数作用域：M:new 对象的成员函数<br>  函数名称：clear_change<br>  描述:  清除变更标记<br>  参数:<br>  无<br>  返回值:<br>  无</p></li></ul><h1 id="ormtable-lua"><a href="#ormtable-lua" class="headerlink" title="ormtable.lua"></a><a href="https://github.com/huahua132/skynet_fly/blob/master/lualib/skynet-fly/db/orm/ormtable.lua">ormtable.lua</a></h1><p>这是orm的核心实现，通常我们创建一个表，通过它来定义。</p><h2 id="构建前调用"><a href="#构建前调用" class="headerlink" title="构建前调用"></a>构建前调用</h2><ul><li><strong>M:new(tab_name)</strong><br>通常只在<code>ormtable.lua</code>中调用，外部不需要调用。<br>  函数作用域：M 对象的成员函数<br>  函数名称：new<br>  描述:  新建表对象<br>  参数:<br>  - tab_name (string): 对应数据库的表名<br>  返回值:<ol><li>orm_obj(table): 表对象</li></ol></li></ul><p>定义字段</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> FILED_TYPE = &#123;<br>    int8         = <span class="hljs-number">1</span>,<br>    int16        = <span class="hljs-number">2</span>,<br>    int32        = <span class="hljs-number">3</span>,<br>    int64        = <span class="hljs-number">4</span>,<br>   <br>    uint8        = <span class="hljs-number">11</span>,<br>    uint16       = <span class="hljs-number">12</span>,<br>    uint32       = <span class="hljs-number">13</span>,<br>   <br>    string32     = <span class="hljs-number">31</span>,<br>    string64     = <span class="hljs-number">32</span>,<br>    string128    = <span class="hljs-number">33</span>,<br>    string256    = <span class="hljs-number">34</span>,<br>    string512    = <span class="hljs-number">35</span>,<br>    string1024   = <span class="hljs-number">36</span>,<br>    string2048   = <span class="hljs-number">37</span>,<br>    string4096   = <span class="hljs-number">38</span>,<br>    string8192   = <span class="hljs-number">39</span>,<br><br>    text         = <span class="hljs-number">51</span>,<br>    blob         = <span class="hljs-number">52</span>,<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>M:int8(filed_name)</strong><br>  函数作用域：M:new 对象的成员函数<br>  函数名称：int8<br>  描述:  定义一个int8类型的字段<br>  参数:<br>  filed_name(string): 字段名<br>  返回值:<ol><li>orm_obj(table): 表对象</li></ol></li></ul><p>返回值是一个orm_obj对象，我们可以链式定义。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> orm_obj = ormtable:new(<span class="hljs-string">&quot;user&quot;</span>)<br>:string256(<span class="hljs-string">&quot;name&quot;</span>)<br>:int8(<span class="hljs-string">&quot;sex&quot;</span>)<br>:set_keys(<span class="hljs-string">&quot;name&quot;</span>)<br>:builder(adapter)  <span class="hljs-comment">--adapter是对接的对应数据库</span><br></code></pre></td></tr></table></figure><ul><li><p><strong>M:set_keys(filed_name)</strong><br>  函数作用域：M:new 对象的成员函数<br>  函数名称：set_keys<br>  描述:  设置主键<br>  参数:<br>  …(string): 字段名列表。<br>  返回值:</p><ol><li>orm_obj(table): 表对象</li></ol></li><li><p><strong>M:set_cache(expire, inval, cache_limit)</strong><br>  函数作用域：M:new 对象的成员函数<br>  函数名称：set_cache<br>  描述:  设置缓存时间<br>  参数:<br>  expire(number): 缓存时间。(创建和查询到entry会刷新缓存时间)<br>  inval(number): 自动保存时间间隔 (间隔一定时间，保存所有有修改的条目)<br>  cache_limit(number): 缓存总量限制，超出使用TTI淘汰策略<br>  返回值:</p><ol><li>orm_obj(table): 表对象</li></ol></li><li><p><strong>M:builder(adapterinterface)</strong><br>  函数作用域：M:new 对象的成员函数<br>  函数名称：builder<br>  描述:  构建<br>  参数:<br>  adapterinterface(number): 数据库适配器<br>  返回值:</p><ol><li>orm_obj(table): 表对象</li></ol></li></ul><h2 id="构建后调用"><a href="#构建后调用" class="headerlink" title="构建后调用"></a>构建后调用</h2><ul><li><strong>M:create_entry(entry_data_list)</strong><br>  函数作用域：M:new 对象的成员函数<br>  函数名称：create_entry<br>  描述:  批量创建新数据<br>  参数:<br>  entry_data_list(table): 数据表列表<br>  返回值:<ol><li>entry_list(table or false): entry对象列表（创建成功的idx是entry对象，失败的是false值）<br>异常情况:</li></ol></li></ul><ol><li><p>创建的<strong>数据有异常</strong>，比如int8类型出现了100000的数值或者干脆就是个”string”类型的值，此时会出现<strong>断言</strong>错误。<br><code>tab_name[t_player] set invaild value filed_name[sex] value[100000] filed_type[1]</code></p></li><li><p>当中途<strong>数据库宕机</strong>，由于创建过程可能是分批执行的，所以宕机的情况并不会导致断言，而是和主键冲突一样返回<strong>false</strong>。</p></li><li><p>一条执行语句都<strong>超过包长度限制</strong>, 这时候会出现<strong>断言错误</strong>。</p></li><li><p>出现<strong>主键冲突</strong>, 由于是分批执行的，过程中可能有成功的，并不会断言，<strong>并且同一批中有一条冲突，就会全部插入失败</strong>，这是数据库插入语句机制决定的。</p></li></ol><ul><li><strong>M:create_one_entry(entry_data_list)</strong><br>  函数作用域：M:new 对象的成员函数<br>  函数名称：create_one_entry<br>  描述:  创建一条数据<br>  参数:<br>  entry_data(table): 数据表<br>  返回值:<ol><li>entry(table): 成功entry对象，失败断言</li></ol></li></ul><p>异常情况：</p><ol><li>创建的<strong>数据有异常</strong>，断言。</li><li><strong>数据库宕机</strong>，断言。</li><li><strong>主键冲突</strong>，断言。</li></ol><p>创建过程是先调用数据库创建接口，再创建entry对象。</p><ul><li><strong>M:get_entry(…)</strong><br>  函数作用域：M:new 对象的成员函数<br>  函数名称：get_entry<br>  描述:  查询多条数据<br>  参数:<br>  …(string or number): 遵循最左原则，填入keys对应字段的值进行查询<br>  返回值:<ol><li>entry_list(table): entry对象列表</li></ol></li></ul><p>异常情况:</p><ol><li><strong>参数一个没有</strong>，断言，因为没有一个参数，是用于查询表所有数据的，查询所有数据应该显示的调用<code>get_all_entry</code>,这样可能避免因为一个传参问题导致非常严重的BUG。</li><li><strong>数据库宕机</strong>，断言。</li></ol><ul><li><strong>M:get_one_entry(…)</strong><br>  函数作用域：M:new 对象的成员函数<br>  函数名称：get_one_entry<br>  描述:  查询单条数据<br>  参数:<br>  …(string or number): 与get_entry不同的是,必须把所有keys的值填入<br>  返回值:<ol><li>entry(table or nil): 存在返回entry对象，不存在nil值</li></ol></li></ul><p>异常情况:</p><ol><li><strong>参数不全</strong>，断言，查询单条数据，应该传入所有主键值。</li><li><strong>数据库宕机</strong>，断言。</li></ol><ul><li><strong>M:save_entry(entry_list)</strong><br>  函数作用域：M:new 对象的成员函数<br>  函数名称：save_entry<br>  描述:  批量保存数据<br>  参数:<br>  entry_list(table): entry对象列表<br>  返回值:<ol><li>ret_list(table): 成功true,失败false</li></ol></li></ul><p>异常情况:</p><ol><li><strong>数据库宕机</strong> 不会断言，因为保存也是批量分配执行的，并且设置间隔保存的时候会自动重试，所以不能断言。</li></ol><ul><li><strong>M:save_one_entry(entry)</strong><br>  函数作用域：M:new 对象的成员函数<br>  函数名称：save_one_entry<br>  描述:  保存一条数据<br>  参数:<br>  entry(table): entry对象<br>  返回值:<ol><li>ret(bool): 成功返回true，失败断言</li></ol></li></ul><p>异常情况:</p><ol><li><strong>数据库宕机</strong>，断言。</li></ol><ul><li><strong>M:delete_entry(…)</strong><br>  函数作用域：M:new 对象的成员函数<br>  函数名称：delete_entry<br>  描述:  删除数据<br>  参数:<br>  …(number or string): 遵循最左原则，填入keys对应字段的值进行查询删除。<br>  返回值:<ol><li>ret(bool): 成功返回true，失败断言</li></ol></li></ul><p>异常情况:</p><ol><li><strong>参数一个没有</strong>，断言，因为没有一个参数，是用于删除表所有数据的，删除所有数据应该显示的调用<code>delete_all_entry</code>,这样可能避免因为一个传参问题导致非常严重的BUG。</li><li><strong>数据库宕机</strong>，断言。</li></ol><ul><li><strong>M:get_all_entry()</strong><br>  函数作用域：M:new 对象的成员函数<br>  函数名称：get_all_entry<br>  描述:  查询所有数据<br>  参数:<br>  无<br>  返回值:<ol><li>entry_list(table): entry对象列表</li></ol></li></ul><p>异常情况:</p><ol><li><strong>数据库宕机</strong>，断言。</li></ol><ul><li><strong>M:delete_all_entry()</strong><br>  函数作用域：M:new 对象的成员函数<br>  函数名称：delete_all_entry<br>  描述:  删除所有数据<br>  参数:<br>  无<br>  返回值:<ol><li>ret(bool): 成功返回true</li></ol></li></ul><p>异常情况:</p><ol><li><strong>数据库宕机</strong>，断言。</li></ol><ul><li><p><strong>M:save_change_now()</strong><br>  函数作用域：M:new 对象的成员函数<br>  函数名称：save_change_now<br>  描述:  立即保存所有修改<br>  参数:<br>  无<br>  返回值:<br>  无</p></li><li><p><strong>M:get_entry_by_data(entry_data)</strong><br>  函数作用域：M:new 对象的成员函数<br>  函数名称：get_entry_by_data<br>  描述:  通过数据获得entry<br>  参数:<br>  entry_data(table) : 实例的数据<br>  返回值:<br>  1. entry(string)：entry对象</p></li><li><p><strong>M:is_inval_save(entry_data)</strong><br>  函数作用域：M:new 对象的成员函数<br>  函数名称：is_inval_save<br>  描述:  是否启动了间隔保存<br>  参数:<br>  返回值:<br>  1. ret(bool)：true or false</p></li></ul><h1 id="ormadapter-mysql-lua"><a href="#ormadapter-mysql-lua" class="headerlink" title="ormadapter_mysql.lua"></a><a href="https://github.com/huahua132/skynet_fly/blob/master/lualib/skynet-fly/db/ormadapter/ormadapter_mysql.lua">ormadapter_mysql.lua</a></h1><p>mysql适配器。<br>业务开发中，我们只需要调用<strong>new</strong>来创建一个适配器传入<strong>ormtable</strong>的builder构建函数中。</p><ul><li><strong>M:new(db_name)</strong><br>  函数作用域：M 对象的成员函数<br>  函数名称：new<br>  描述:  新建适配器对象<br>  参数:<br>  - db_name (string): 表存在的数据库名称。<br>  返回值:<ol><li>apter(table): 适配器对象。</li></ol></li></ul><h2 id="业务层不直接访问的方法，都是通过orm-table间接访问。"><a href="#业务层不直接访问的方法，都是通过orm-table间接访问。" class="headerlink" title="业务层不直接访问的方法，都是通过orm_table间接访问。"></a>业务层不直接访问的方法，都是通过orm_table间接访问。</h2><ul><li><strong>M:builder(tab_name, filed_list, filed_map, key_list)</strong><br>  函数作用域：M:new 对象的成员函数<br>  函数名称：builder<br>  描述:  构建表，不存在构建，存在更新。<br>  参数:<br>  tab_name(string)表名。<br>  filed_list(table)字段列表，按定义顺序。<br>  filed_map(table)字段名和字段类型的映射。<br>  key_list(table)主键字段名列表。<br>  返回值:<br>  1. apter(table): 适配器对象。</li></ul><p>builder会在ormtable调用builder的时候调用。</p><ul><li><p><strong>M:create_entry(entry_data_list)</strong><br>  函数作用域：M:new 对象的成员函数<br>  函数名称：create_entry<br>  描述:  批量创建表数据<br>  参数:<br>  entry_data_list(table)数据表内容列表，数据经过ormtable过滤处理，空值string类型会是空串，number类型会是0。<br>  返回值:<br>  1. res_list(table): 成功true,失败false。</p></li><li><p><strong>M:create_one_entry(entry_data)</strong><br>  函数作用域：M:new 对象的成员函数<br>  函数名称：create_one_entry<br>  描述:  创建一条数据<br>  参数:<br>  entry_data(table)数据表内容，数据经过ormtable过滤处理，空值string类型会是空串，number类型会是0。<br>  返回值:<br>  1. ret(bool): 成功true,失败断言</p></li><li><p><strong>M:get_entry(keys_values)</strong><br>  函数作用域：M:new 对象的成员函数<br>  函数名称：get_entry<br>  描述:  查询表数据<br>  参数:<br>  keys_values(table)最左原则，keys的值。<br>  返回值:<br>  1. entry_data_list(table): 成功数据表列表，失败断言</p></li><li><p><strong>M:get_one_entry(keys_values)</strong><br>  函数作用域：M:new 对象的成员函数<br>  函数名称：get_one_entry<br>  描述:  查询单条数据<br>  参数:<br>  keys_values(table)最左原则，keys的值。<br>  返回值:<br>  1. entry_data(table): 成功数据表，失败断言</p></li><li><p><strong>M:save_entry(entry_data_list, change_map_list)</strong><br>  函数作用域：M:new 对象的成员函数<br>  函数名称：save_entry<br>  描述:  保存表数据<br>  参数:<br>  entry_data_list(table)数据表列表。<br>  change_map_list(table)数据表变更记录。<br>  返回值:<br>  1. ret_list(table): 成功true 失败false。</p></li><li><p><strong>M:save_one_entry(entry_data, change_map)</strong><br>  函数作用域：M:new 对象的成员函数<br>  函数名称：save_one_entry<br>  描述:  保存一条数据<br>  参数:<br>  entry_data(table)数据表。<br>  change_map(table)变更列表。<br>  返回值:<br>  1. ret(bool): 成功true失败断言</p></li><li><p><strong>M:delete_entry(key_values)</strong><br>  函数作用域：M:new 对象的成员函数<br>  函数名称：delete_entry<br>  描述:  删除表数据<br>  参数:<br>  keys_values(table)最左原则，keys的值。<br>  返回值:<br>  1. ret(bool): 成功true失败断言</p></li></ul><h1 id="ormadapter-mongo-lua"><a href="#ormadapter-mongo-lua" class="headerlink" title="ormadapter_mongo.lua"></a><a href="https://github.com/huahua132/skynet_fly/blob/master/lualib/skynet-fly/db/ormadapter/ormadapter_mongo.lua">ormadapter_mongo.lua</a></h1><p>mongo db多了以下两个方法，批量插入和批量更新的时候，设置一次执行的数量，mysql不用这样是因为mysql可以获取到网络包的长度限制，并且数据包的长度外部也能知道(sql的长度),但是mongo，外部获取不到网络包的长度，不确定一次能够执行多少，按照chatgpt的回复，mongo的包长度限制为16M，高版本为64M，想着预留这个接口，用户根据表的数量大小，自己预估单次数量即可，默认一次10条，在大多数情况下都不会超过16M。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">--设置单次整合批量插入的数量</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">M:set_batch_insert_num</span><span class="hljs-params">(num)</span></span><br>    <span class="hljs-built_in">assert</span>(num &gt; <span class="hljs-number">0</span>)<br>    <span class="hljs-built_in">self</span>.batch_insert_num = num<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">self</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">--设置单次整合批量更新的数量</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">M:set_batch_update_num</span><span class="hljs-params">(num)</span></span><br>    <span class="hljs-built_in">assert</span>(num &gt; <span class="hljs-number">0</span>)<br>    <span class="hljs-built_in">self</span>.batch_update_num = num<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">self</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>其他接口函数的实现会返回值都是统一的，这也是为什么orm的可以无缝切换数据库的原因。</p><p><a href="https://github.com/huahua132/skynet_fly/blob/master/module/orm_table_m.lua">orm_table_m.lua</a><br>有多个服务需要使用<strong>orm</strong>的时候，我们需要使用代理访问，这时候我们只在<code>orm_table_m.lua</code>服务中去构建操作orm对象。</p><p>具体示例可以查看<br><a href="https://github.com/huahua132/skynet_fly/blob/master/examples/orm/main.lua">orm</a><br>我们可以以这种方式自定义一些方法，比如玩家的道具<code>item</code>,我们必须原子性的加减，并且减少不能小于0，我们可能就需要定义这样的方法。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handle.add_item</span><span class="hljs-params">(player_id, item_id, num)</span></span><br>    <span class="hljs-built_in">assert</span>(num &gt;= <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">local</span> entry = g_orm_obj:get_one_entry(player_id, item_id)<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> entry <span class="hljs-keyword">then</span><br>        <span class="hljs-built_in">log</span>.<span class="hljs-built_in">error</span>(<span class="hljs-string">&quot;add_item not exist item_id &quot;</span>,player_id, item_id)<br>        <span class="hljs-keyword">return</span><br>    <span class="hljs-keyword">end</span><br><br>    <span class="hljs-keyword">local</span> count = entry:get(<span class="hljs-string">&#x27;count&#x27;</span>)<br>    count = count + num<br>    entry:set(<span class="hljs-string">&#x27;count&#x27;</span>, count)<br><br>     <span class="hljs-comment">--没有启动间隔时间自动保存就立即保存</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> g_orm_obj:is_inval_save() <span class="hljs-keyword">then</span><br>        g_orm_obj:save_one_entry(entry)<br>    <span class="hljs-keyword">end</span><br><br>    <span class="hljs-keyword">return</span> count<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>常用的处理函数</p><ul><li><p><strong>create_entry(entry_data_list)</strong><br>  函数作用域：handle<br>  函数名称：create_entry<br>  描述:  批量创建数据<br>  参数:<br>  entry_data_list(table)数据表列表<br>  返回值:<br>  1. data_list(table): 二级 成功值为entry_data失败值为false</p></li><li><p><strong>create_one_entry(entry_data)</strong><br>  函数作用域：handle<br>  函数名称：create_one_entry<br>  描述:  创建单条数据<br>  参数:<br>  entry_data(table)数据表<br>  返回值:<br>  1. entry_data(bool): 成功entry_data失败断言</p></li><li><p><strong>get_entry(…)</strong><br>  函数作用域：handle<br>  函数名称：get_entry<br>  描述:  查询多条数据<br>  参数:<br>  …(string or number)遵循最左原则，填入keys对应字段的值进行查询<br>  返回值:<br>  1. data_list(table): 数据表列表</p></li><li><p><strong>get_one_entry(…)</strong><br>  函数作用域：handle<br>  函数名称：get_one_entry<br>  描述:  查询一条数据<br>  参数:<br>  …(string or number)遵循最左原则，填入keys对应字段的值进行查询<br>  返回值:<br>  1. entry_data(table): 数据表</p></li><li><p><strong>change_save_entry(entry_data_list)</strong><br>  函数作用域：handle<br>  函数名称：change_save_entry<br>  描述:  批量变更保存数据<br>  参数:<br>  entry_data_list(table)数据表列表<br>  返回值:<br>  1. ret_list(table): 二级 成功值为true失败值为false</p></li><li><p><strong>change_save_one_entry(entry_data)</strong><br>  函数作用域：handle<br>  函数名称：change_save_one_entry<br>  描述:  变更保存一条数据<br>  参数:<br>  entry_data(table)数据表<br>  返回值:<br>  1. ret(bool):成功值为true失败断言</p></li><li><p><strong>delete_entry(…)</strong><br>  函数作用域：handle<br>  函数名称：delete_entry<br>  描述:  删除数据<br>  参数:<br>  …(string or number)遵循最左原则，填入keys对应字段的值进行删除<br>  返回值:<br>  1. ret(bool): 成功值为true失败断言</p></li><li><p><strong>get_all_entry()</strong><br>  函数作用域：handle<br>  函数名称：get_all_entry<br>  描述:  查询所有数据<br>  参数:<br>  无<br>  返回值:<br>  1. ret(bool): 成功值为true失败断言</p></li><li><p><strong>delete_all_entry()</strong><br>  函数作用域：handle<br>  函数名称：delete_all_entry<br>  描述:  删除所有数据<br>  参数:<br>  无<br>  返回值:<br>  1. ret(bool): 成功值为true失败断言</p></li><li><p><strong>save_change_now()</strong><br>  函数作用域：handle<br>  函数名称：save_change_now<br>  描述:  立即保存所有修改<br>  参数:<br>  无<br>  返回值:<br>  无</p></li></ul><h1 id="orm-table-client-lua"><a href="#orm-table-client-lua" class="headerlink" title="orm_table_client.lua"></a><a href="https://github.com/huahua132/skynet_fly/blob/master/lualib/skynet-fly/client/orm_table_client.lua">orm_table_client.lua</a></h1><p>访问代理，这个文件的实现，主要有两个目的</p><ol><li>解决热更问题，热更之后需要访问新的orm_table_m服务。</li><li>调用便捷性。</li></ol><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs lua">orm_table_client:instance(<span class="hljs-string">&quot;player&quot;</span>):not_exist_create(&#123;player_id = <span class="hljs-number">10001</span>&#125;)<br><br><span class="hljs-keyword">local</span> client = orm_table_client:new(<span class="hljs-string">&quot;player&quot;</span>)<br><span class="hljs-keyword">local</span> entry_data = client:get(<span class="hljs-number">10001</span>)<br><span class="hljs-built_in">log</span>.info(<span class="hljs-string">&quot;get:&quot;</span>,entry_data)<br><br><span class="hljs-comment">--批量创建数据</span><br><span class="hljs-keyword">local</span> entry_data_list = &#123;<br>    &#123;player_id = <span class="hljs-number">10001</span>&#125;,<br>    &#123;player_id = <span class="hljs-number">10002</span>&#125;,<br>    &#123;player_id = <span class="hljs-number">10003</span>&#125;,<br>    &#123;player_id = <span class="hljs-number">10003</span>&#125;,<br>&#125;<br><br><span class="hljs-comment">--主键冲突，创建失败</span><br><span class="hljs-keyword">local</span> res_list = client:create_entry(entry_data_list)<br><span class="hljs-built_in">log</span>.info(<span class="hljs-string">&quot;res_list:&quot;</span>, res_list)<br></code></pre></td></tr></table></figure><p>封装以后调用相当于调用本地方法一样，但是使用中，应该注意，这里存在rpc调用。</p>]]></content>
    
    
    <categories>
      
      <category>skynet_fly_api</category>
      
    </categories>
    
    
    <tags>
      
      <tag>skynet_fly_api</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>watch_syn.lua 监听同步机制</title>
    <link href="/2024/01/28/skynet_fly_api/watch_syn/"/>
    <url>/2024/01/28/skynet_fly_api/watch_syn/</url>
    
    <content type="html"><![CDATA[<h1 id="watch-syn-lua"><a href="#watch-syn-lua" class="headerlink" title="watch_syn.lua"></a><a href="https://github.com/huahua132/skynet_fly/blob/master/lualib/skynet-fly/watch/watch_syn.lua">watch_syn.lua</a></h1><h2 id="sever"><a href="#sever" class="headerlink" title="sever"></a><strong>sever</strong></h2><ul><li><strong>M.new_server(CMD)</strong><br>  函数作用域：M 对象的成员函数<br>  描述:  创建一个<strong>发布者</strong>对象，需要在代码<strong>load</strong>中创建好。<br>  参数:<br>  - CMD (table): 模块的CMDtable<br>  返回值:<ol><li>server_obj(table): <strong>发布者</strong>对象</li></ol></li></ul><p>为什么需要传递CMD，因为<strong>发布者</strong>需要创建<strong>watch</strong>和<strong>unwatch</strong>两个接口，还有如果是热更服务还需要处理<strong>fix_eixt</strong>,<strong>cancel_exit</strong>的回调。</p><ul><li><p><strong>server:register(name, init_v)</strong><br>  函数作用域：M.new_server 对象的成员函数<br>  描述:  注册一个key-value值<br>  参数:<br>  - name (string): 名称<br>  - init_v (any): 初始值<br>  返回值:</p><ol><li>server_obj(table): <strong>发布者</strong>对象</li></ol></li><li><p><strong>server:publish(name, new_value)</strong><br>  函数作用域：M.new_server 对象的成员函数<br>  描述:  发布新值，同时通知<strong>订阅者</strong><br>  参数:<br>  - name (string): 名称<br>  - new_value (any): 新值<br>  返回值:<br>  无</p></li></ul><h2 id="client"><a href="#client" class="headerlink" title="client"></a><strong>client</strong></h2><ul><li><strong>M.new_client(rpc_interface)</strong><br>  函数作用域：M 对象的成员函数<br>  描述:  创建一个<strong>订阅者</strong>对象<br>  参数:<br>  - rpc_interface (table): watch接口，需要实现send,call方法。<br>  返回值:<ol><li>client_obj(table): <strong>订阅者</strong>对象</li></ol></li></ul><p>因为<strong>server</strong>可能是在<strong>可热更模块服务</strong>中创建，也可能在普通的skynet服务中，所有就抽象出了接口，用于适配这两种情况。</p><p><code>service_watch_interface.lua</code> 在普通的skynet服务中使用</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs lua"><br><span class="hljs-keyword">local</span> skynet = <span class="hljs-built_in">require</span> <span class="hljs-string">&quot;skynet&quot;</span><br><br><span class="hljs-keyword">local</span> <span class="hljs-built_in">setmetatable</span> = <span class="hljs-built_in">setmetatable</span><br><br><span class="hljs-keyword">local</span> M = &#123;&#125;<br><span class="hljs-keyword">local</span> mt = &#123;<span class="hljs-built_in">__index</span> = M&#125;<br><span class="hljs-comment">--skynet服务 接口 传递别名或者handle_id</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">M:new</span><span class="hljs-params">(name_or_handle)</span></span><br>    <span class="hljs-keyword">local</span> t = &#123;<br>        server = name_or_handle<br>    &#125;<br><br>    <span class="hljs-built_in">setmetatable</span>(t, mt)<br>    <span class="hljs-keyword">return</span> t<br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">M:send</span><span class="hljs-params">(...)</span></span><br>    skynet.send(<span class="hljs-built_in">self</span>.server, <span class="hljs-string">&#x27;lua&#x27;</span>, ...)<br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">M:call</span><span class="hljs-params">(...)</span></span><br>    <span class="hljs-keyword">return</span> skynet.call(<span class="hljs-built_in">self</span>.server, <span class="hljs-string">&#x27;lua&#x27;</span>, ...)<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">return</span> M<br></code></pre></td></tr></table></figure><p><code>contriner_watch_interface.lua</code> 在<strong>可热更模块服务</strong>中使用</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> contriner_client = <span class="hljs-built_in">require</span> <span class="hljs-string">&quot;contriner_client&quot;</span><br><span class="hljs-keyword">local</span> <span class="hljs-built_in">setmetatable</span> = <span class="hljs-built_in">setmetatable</span><br><br><span class="hljs-keyword">local</span> M = &#123;&#125;<br><span class="hljs-keyword">local</span> mt = &#123;<span class="hljs-built_in">__index</span> = M&#125;<br><span class="hljs-comment">--可热更模块接口</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">M:new</span><span class="hljs-params">(mod_name, instance_name)</span></span><br>    <span class="hljs-keyword">local</span> t = &#123;<br>        cli = contriner_client:new(mod_name, instance_name)<br>    &#125;<br><br>    <span class="hljs-built_in">setmetatable</span>(t, mt)<br>    <span class="hljs-keyword">return</span> t<br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">M:send</span><span class="hljs-params">(...)</span></span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">self</span>.cli:mod_send(...)<br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">M:call</span><span class="hljs-params">(...)</span></span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">self</span>.cli:mod_call(...)<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">return</span> M<br></code></pre></td></tr></table></figure><ul><li><strong>client:watch(name)</strong><br>  函数作用域：M.new_client 对象的成员函数<br>  描述:  监听name<br>  参数:<br>  - name (string): 名称<br>  返回值:<ol><li>ret(bool): true</li></ol></li></ul><p>重复监听会断言</p><ul><li><p><strong>client:is_watch(name)</strong><br>  函数作用域：M.new_client 对象的成员函数<br>  描述: 是否还监听了此name<br>  参数:<br>  - name (string): 名称<br>  返回值:</p><ol><li>ret(bool): true or false</li></ol></li><li><p><strong>client:unwatch(name)</strong><br>  函数作用域：M.new_client 对象的成员函数<br>  描述: 取消监听<br>  参数:<br>  - name (string): 名称<br>  返回值:<br>  无</p></li></ul><p>没有监听取消会断言</p><ul><li><strong>client:get(name)</strong><br>  函数作用域：M.new_client 对象的成员函数<br>  描述: 获取name的值<br>  参数:<br>  - name (string): 名称<br>  返回值:<ol><li>value</li></ol></li></ul><p>没有监听会断言<br>监听的，可能值还没有返回。</p><ul><li><strong>client:await_get(name)</strong><br>  函数作用域：M.new_client 对象的成员函数<br>  描述: 获取name的值（至少第一次结果已经返回）<br>  参数:<br>  - name (string): 名称<br>  返回值:<ol><li>value</li></ol></li></ul><p>还没有拿到第一个值，就会一直等待，直到拿到。</p><ul><li><strong>client:await_update(name)</strong><br>  函数作用域：M.new_client 对象的成员函数<br>  描述: 等待推送新的值，如果是可热更服务也可能是对方下线了。<br>  参数:<br>  - name (string): 名称<br>  返回值:<ol><li>value</li></ol></li></ul>]]></content>
    
    
    <categories>
      
      <category>skynet_fly_api</category>
      
    </categories>
    
    
    <tags>
      
      <tag>skynet_fly_api</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>定时器的使用</title>
    <link href="/2024/01/21/skynet_fly_api/timer/"/>
    <url>/2024/01/21/skynet_fly_api/timer/</url>
    
    <content type="html"><![CDATA[<h1 id="timer-lua"><a href="#timer-lua" class="headerlink" title="timer.lua"></a><a href="https://github.com/huahua132/skynet_fly/blob/master/lualib/skynet-fly/timer.lua">timer.lua</a></h1><p>对skynet的定时器做了基础封装，提供了注销，延时，循环次数，获得下次触发的剩余时间等等功能。</p><h1 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h1><ul><li><p><strong>new(expire,times,callback,…)</strong><br>  函数作用域：M 对象的成员函数<br>  函数名称：new<br>  描述:  创建一个定时器对象<br>  参数:<br>  - expire (number): 过期时间 100等于1秒<br>  - times (number): 次数，0表示循环触发<br>  - callback (function): 回调函数<br>  - …  回调参数</p></li><li><p><strong>cancel()</strong><br>  函数作用域：M:new 对象的成员函数<br>  函数名称：cancel<br>  描述:  取消定时器</p></li><li><p><strong>after_next</strong><br>  函数作用域：M:new 对象的成员函数<br>  函数名称：after_next<br>  描述:  之后下一次 ： 回调函数执行完，再注册下一次，默认先注册下一次再执行回调</p></li><li><p><strong>extend</strong><br>  函数作用域：M:new 对象的成员函数<br>  函数名称：extend<br>  描述:  延长定时器<br>  参数:<br>  - ex_expire (number): 延长时间 100等于1秒</p></li><li><p><strong>remain_expire</strong><br>  函数作用域：M:new 对象的成员函数<br>  函数名称：remain_expire<br>  描述:  剩余触发时间</p></li></ul><h1 id="timer-point"><a href="#timer-point" class="headerlink" title="timer_point"></a><a href="https://github.com/huahua132/skynet_fly/blob/master/lualib/skynet-fly/time_extend/timer_point.lua">timer_point</a></h1><p>使用基础的timer.lua模块，封装的整点报时功能，功能的概念类似闹钟，比如设置每天下午2点半第30秒，就只需要这样设置。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">call_back</span><span class="hljs-params">(a, b ,c, d)</span></span><br><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">local</span> a,b,c,d = <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span><br><span class="hljs-keyword">local</span> point = timer_point:new(time_point.EVERY_DAY)<br>:set_hour(<span class="hljs-number">14</span>) <span class="hljs-comment">--下午2点</span><br>:set_min(<span class="hljs-number">30</span>)  <span class="hljs-comment">--30分</span><br>:set_sec(<span class="hljs-number">30</span>)  <span class="hljs-comment">--30秒</span><br>:builder(call_back, a, b, c, d)<br><br>point:cancel()  <span class="hljs-comment">--取消整点报时</span><br></code></pre></td></tr></table></figure><p>目前支持设置的时间刻度有：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> M = &#123;<br>    <span class="hljs-comment">--每分钟</span><br>    EVERY_MINUTE = <span class="hljs-number">1</span>,<br>    <span class="hljs-comment">--每小时</span><br>    EVERY_HOUR = <span class="hljs-number">2</span>,<br>    <span class="hljs-comment">--每天</span><br>    EVERY_DAY = <span class="hljs-number">3</span>,<br>    <span class="hljs-comment">--每周</span><br>    EVERY_WEEK = <span class="hljs-number">4</span>,<br>    <span class="hljs-comment">--每月 超过适配到最后一天</span><br>    EVERY_MOUTH = <span class="hljs-number">5</span>,<br>    <span class="hljs-comment">--每年几月几日几时几分几秒 超过适配到最后一天</span><br>    EVERY_YEAR = <span class="hljs-number">6</span>,<br>    <span class="hljs-comment">--每年的第几天 超过适配到最后一天</span><br>    EVERY_YEAR_DAY = <span class="hljs-number">7</span>,<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p><strong>new(type)</strong><br>  函数作用域：M 对象的成员函数<br>  函数名称：new<br>  描述:  创建整点报时对象<br>  参数:<br>  - type (number): 时间刻度类型</p></li><li><p><strong>set_month</strong><br>  函数作用域：M:new 对象的成员函数<br>  函数名称：set_month<br>  描述:  指定几月,如果刻度不是每年的话，这个设置没有作用<br>  参数:<br>  - month (number): 月份 1-12</p></li><li><p><strong>set_day</strong><br>  函数作用域：M:new 对象的成员函数<br>  函数名称：set_day<br>  描述:  每月第几天,超过适配到最后一天，比如设置31天，这月只有30天，适配到30天触发。<br>  参数:<br>  - day (number): 天数 1-31</p></li><li><p><strong>set_hour</strong><br>  函数作用域：M:new 对象的成员函数<br>  函数名称：set_hour<br>  描述:  几时<br>  参数:<br>  - hour (number): 几时 0-23</p></li><li><p><strong>set_min</strong><br>  函数作用域：M:new 对象的成员函数<br>  函数名称：set_min<br>  描述:  几分<br>  参数:<br>  - min (number): 几分 0-59</p></li><li><p><strong>set_sec</strong><br>  函数作用域：M:new 对象的成员函数<br>  函数名称：set_sec<br>  描述:  几秒<br>  参数:<br>  - sec (number): 几秒 0-59</p></li><li><p><strong>set_wday</strong><br>  函数作用域：M:new 对象的成员函数<br>  函数名称：set_wday<br>  描述:  周几（仅仅设置每周有效）<br>  参数:<br>  - wday (number): 周几 1-7 星期天为 1</p></li><li><p><strong>set_yday</strong><br>  函数作用域：M:new 对象的成员函数<br>  函数名称：set_yday<br>  描述:  一年第几天（仅仅设置每年第几天有效）<br>  参数:<br>  - yday (number): 第几天 1-366 超过适配到最后一天。</p></li><li><p><strong>builder</strong><br>  函数作用域：M:new 对象的成员函数<br>  函数名称：builder<br>  描述:  构建。<br>  参数:<br>  - callback (function): 回调函数。<br>  - … (any): 回调参数。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>skynet_fly_api</category>
      
    </categories>
    
    
    <tags>
      
      <tag>skynet_fly_api</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于skynet_fly 决定web路由工具使用的测试</title>
    <link href="/2024/01/14/skynet_fly_ss/benchmark_rax/"/>
    <url>/2024/01/14/skynet_fly_ss/benchmark_rax/</url>
    
    <content type="html"><![CDATA[<h1 id="测试对象"><a href="#测试对象" class="headerlink" title="测试对象"></a>测试对象</h1><ul><li><a href="https://github.com/hanxi/lua-rax">lua-rax</a></li><li><a href="https://github.com/vm-001/lua-radix-router">lua-radix-router</a></li></ul><h1 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h1><h2 id="lua-radix-router"><a href="#lua-radix-router" class="headerlink" title="lua-radix-router"></a>lua-radix-router</h2><table><thead><tr><th>TEST CASE</th><th>Router number</th><th>nanoseconds &#x2F; op</th><th>QPS</th><th>RSS</th></tr></thead><tbody><tr><td>static-paths</td><td>100000</td><td>0.352315 ns</td><td>2838369</td><td>74.60 MB</td></tr><tr><td>simple-variable</td><td>100000</td><td>1.403398 ns</td><td>712556</td><td>129.78 MB</td></tr><tr><td>simple-variable-binding</td><td>100000</td><td>2.443032 ns</td><td>409327</td><td>130.02 MB</td></tr><tr><td>simple-prefix</td><td>100000</td><td>1.082572 ns</td><td>923726</td><td>130.77 MB</td></tr><tr><td>complex-variable</td><td>100000</td><td>14.235308 ns</td><td>70247</td><td>344.34 MB</td></tr><tr><td>github-routes</td><td>609</td><td>4.73934 ns</td><td>210999</td><td>23.27 MB</td></tr></tbody></table><h2 id="lua-rax"><a href="#lua-rax" class="headerlink" title="lua-rax"></a>lua-rax</h2><table><thead><tr><th>TEST CASE</th><th>Router number</th><th>nanoseconds &#x2F; op</th><th>QPS</th><th>RSS</th></tr></thead><tbody><tr><td>static-paths</td><td>100000</td><td>0.298189 ns</td><td>3353577</td><td>66.65 MB</td></tr><tr><td>simple-variable</td><td>100000</td><td>1.905007 ns</td><td>524932</td><td>76.40 MB</td></tr><tr><td>simple-variable-binding</td><td>100000</td><td>1.898845 ns</td><td>526635</td><td>98.68 MB</td></tr><tr><td>simple-prefix</td><td>100000</td><td>1.837813 ns</td><td>544125</td><td>76.52 MB</td></tr><tr><td>complex-variable</td><td>100000</td><td>14.893003 ns</td><td>67145</td><td>63.65 MB</td></tr><tr><td>github-routes</td><td>609</td><td>260.5502 ns</td><td>3838</td><td>23.52 MB</td></tr></tbody></table><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>lua-rax 在github-routes测试项表现非常差劲，在其他项测试各有优劣。所以skynet_fly将切换使用lua-radix-router。</p>]]></content>
    
    
    <categories>
      
      <category>skynet_fly实现思路历程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>skynet_fly实现思路历程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>可热更模块的启动配置项</title>
    <link href="/2024/01/14/skynet_fly_api/mods/"/>
    <url>/2024/01/14/skynet_fly_api/mods/</url>
    
    <content type="html"><![CDATA[<h1 id="web服务"><a href="#web服务" class="headerlink" title="web服务"></a>web服务</h1><h2 id="web-master-m"><a href="#web-master-m" class="headerlink" title="web_master_m"></a>web_master_m</h2><ul><li><strong>max_client</strong> 最大同时连接数。</li><li><strong>second_conn_limit</strong> 相同ip一秒内建立连接数量限制。</li><li><strong>keep_live_limit</strong> 相同ip保持连接数量限制。</li><li><strong>host</strong> 无默认0.0.0.0。</li><li><strong>port</strong> 无 http默认80 https默认443。</li><li><strong>protocol</strong> 协议 http 或者 https。</li></ul><h2 id="web-agent-m"><a href="#web-agent-m" class="headerlink" title="web_agent_m"></a>web_agent_m</h2><ul><li><strong>protocol</strong> 协议 http 或者 https。</li><li><strong>keep_alive_time</strong> 保活时间。</li><li><strong>second_req_limit</strong> 一秒请求数量限制。</li></ul><h1 id="日志切割服务"><a href="#日志切割服务" class="headerlink" title="日志切割服务"></a>日志切割服务</h1><h2 id="logrotate-m"><a href="#logrotate-m" class="headerlink" title="logrotate_m"></a>logrotate_m</h2><ul><li><strong>filename</strong> 文件名。</li><li><strong>rename_format</strong> 重命名文件格式。日期格式。</li><li><strong>file_path</strong> 文件的路径。</li><li><strong>limit_size</strong> 至少多大才会切割。</li><li><strong>max_age</strong> 最大保留天数。</li><li><strong>max_backups</strong> 最大保留文件数。</li><li><strong>sys_cmd</strong> 轮转时调用的系统命令。</li><li><strong>point_type</strong> 定时轮转的定时器类型。</li><li><strong>month</strong> 几月。</li><li><strong>day</strong> 几天。</li><li><strong>hour</strong> 几时。</li><li><strong>min</strong> 几分。</li><li><strong>sec</strong> 几秒。</li><li><strong>wday</strong> 周几。</li><li><strong>yday</strong> 一年第几天。</li></ul><h1 id="orm服务"><a href="#orm服务" class="headerlink" title="orm服务"></a>orm服务</h1><h2 id="orm-table-m"><a href="#orm-table-m" class="headerlink" title="orm_table_m"></a>orm_table_m</h2><ul><li><strong>orm_plug</strong> 绑定的orm插件文件。</li></ul><h1 id="集群客户端服务"><a href="#集群客户端服务" class="headerlink" title="集群客户端服务"></a>集群客户端服务</h1><h2 id="cluster-client-m"><a href="#cluster-client-m" class="headerlink" title="cluster_client_m"></a>cluster_client_m</h2><ul><li><strong>node_map</strong> 访问的server列表 keyvalue形式 svr_name &#x3D; node。</li><li><strong>watch</strong> 监听方式，目前提供redis服务发现模式。</li></ul><h1 id="大厅房间类架构"><a href="#大厅房间类架构" class="headerlink" title="大厅房间类架构"></a>大厅房间类架构</h1><h2 id="room-game-alloc-m"><a href="#room-game-alloc-m" class="headerlink" title="room_game_alloc_m"></a>room_game_alloc_m</h2><ul><li><strong>alloc_plug</strong> 分配服插件。</li><li><strong>MAX_TABLES</strong> 最大桌子数量。</li></ul><h2 id="room-game-hall-m"><a href="#room-game-hall-m" class="headerlink" title="room_game_hall_m"></a>room_game_hall_m</h2><ul><li><strong>hall_plug</strong> 大厅服插件。</li></ul><h2 id="room-game-table-m"><a href="#room-game-table-m" class="headerlink" title="room_game_table_m"></a>room_game_table_m</h2><ul><li><strong>table_plug</strong> 桌子服插件。</li><li><strong>table_conf</strong> 桌子服配置。</li></ul><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="mysql-m"><a href="#mysql-m" class="headerlink" title="mysql_m"></a>mysql_m</h2><ul><li><strong>db_conf</strong> mysql连接配置。</li></ul>]]></content>
    
    
    <categories>
      
      <category>skynet_fly_api</category>
      
    </categories>
    
    
    <tags>
      
      <tag>skynet_fly_api</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>远程rpc调用</title>
    <link href="/2024/01/07/skynet_fly_api/rpcf/"/>
    <url>/2024/01/07/skynet_fly_api/rpcf/</url>
    
    <content type="html"><![CDATA[<h1 id="关联文件"><a href="#关联文件" class="headerlink" title="关联文件"></a>关联文件</h1><ul><li><a href="https://github.com/huahua132/skynet_fly/blob/master/lualib/skynet-fly/client/cluster_client.lua">cluster_client.lua</a></li></ul><h1 id="最常用API"><a href="#最常用API" class="headerlink" title="最常用API"></a>最常用API</h1><ul><li><p><strong>M:new(svr_name,module_name,instance_name)</strong> 创建调用对象。<br>  参数：<br>  * <strong>svr_name(string)</strong> 访问节点名称。<br>  * <strong>module_name(string)</strong>  模块名称，需要send或者call通信的模块名称(相当于一级索引)。<br>  * <strong>instance_name(string)</strong> 实例名称，它是模块的二级分类(相当于二级索引)。<br>  返回值：<br>  1. <strong>client(table)</strong> rpc客户端对象。</p></li><li><p><strong>M:instance(svr_name,module_name,instance_name)</strong> 使用单例访问对象(很多时候并不需要创建管理rpc调用对象)。<br>  参数：<br>  * <strong>svr_name(string)</strong> 访问节点名称。<br>  * <strong>module_name(string)</strong>  模块名称，需要send或者call通信的模块名称(相当于一级索引)。<br>  * <strong>instance_name(string)</strong> 实例名称，它是模块的二级分类(相当于二级索引)。<br>  返回值：<br>  1. <strong>client(table)</strong> rpc客户端对象。</p></li><li><p><strong>M:one_balance_send(…)</strong> 用简单轮询负载均衡给单个结点的module_name模板用balance_send的方式发送消息<br>  参数: <strong>server</strong>接受的参数。<br>  返回值: 无。</p></li><li><p><strong>M:one_balance_call(…)</strong> 跟<strong>one_balance_send</strong>一致，唯一区别是使用<strong>call</strong>的方式发消息。</p></li><li><p><strong>M:one_mod_send(…)</strong> 用简单轮询负载均衡给单个结点的module_name模板用mod_send的方式发送消息。<br>  参数: <strong>server</strong>接受的参数。<br>  返回值: 无。</p></li><li><p><strong>M:one_mod_call(…)</strong> 跟<strong>balance_send</strong>一致，唯一区别是使用<strong>call</strong>的方式发消息。</p></li><li><p><strong>M:one_broadcast(…)</strong> 用简单轮询负载均衡给单个结点的module_name模板用broadcast的方式发送消息。</p></li><li><p><strong>M:one_broadcast_call(…)</strong> 用简单轮询负载均衡给单个结点的module_name模板用broadcast_call的方式发送消息。</p></li><li><p><strong>M:byid_balance_send(…)</strong> 用svr_id映射的方式给单个结点的module_name模板用balance_send的方式发送消息。</p></li><li><p><strong>M:byid_balance_call(…)</strong> 用svr_id映射的方式给单个结点的module_name模板用balance_call的方式发送消息。</p></li><li><p><strong>M:byid_mod_send(…)</strong> 用svr_id映射的方式给单个结点的module_name模板用mod_send的方式发送消息。</p></li><li><p><strong>M:byid_mod_call(name)</strong> 用svr_id映射的方式给单个结点的module_name模板用mod_call的方式发送消息。</p></li><li><p><strong>M:byid_broadcast(name)</strong> 用svr_id映射的方式给单个结点的module_name模板用broadcast的方式发送消息。</p></li><li><p><strong>M:byid_broadcast_call(name)</strong> 用svr_id映射的方式给单个结点的module_name模板用broadcast_call的方式发送消息。</p></li><li><p><strong>M:all_balance_send(…)</strong> 给所有结点的module_name模板用balance_send的方式发送消息。</p></li><li><p><strong>M:all_balance_call(…)</strong> 给所有结点的module_name模板用balance_call的方式发送消息。</p></li><li><p><strong>M:all_mod_send(…)</strong> 给所有结点的module_name模板用mod_send的方式发送消息。</p></li><li><p><strong>M:all_mod_call(name)</strong> 给所有结点的module_name模板用mod_call的方式发送消息。</p></li><li><p><strong>M:all_broadcast(name)</strong> 给所有结点的module_name模板用broadcast的方式发送消息。</p></li><li><p><strong>M:all_broadcast_call(name)</strong> 给所有结点的module_name模板用broadcast_call的方式发送消息。</p></li><li><p><strong>M:one_balance_send_by_name(…)</strong> </p></li><li><p><strong>M:one_balance_call_by_name(…)</strong> </p></li><li><p><strong>M:one_mod_send_by_name(…)</strong> </p></li><li><p><strong>M:one_mod_call_by_name(name)</strong> </p></li><li><p><strong>M:one_broadcast_by_name(name)</strong> </p></li><li><p><strong>M:one_broadcast_call_by_name(name)</strong> </p></li><li><p><strong>M:byid_balance_send_by_name(…)</strong> </p></li><li><p><strong>M:byid_balance_call_by_name(…)</strong> </p></li><li><p><strong>M:byid_mod_send_by_name(…)</strong> </p></li><li><p><strong>M:byid_mod_call_by_name(name)</strong> </p></li><li><p><strong>M:byid_broadcast_by_name(name)</strong> </p></li><li><p><strong>M:byid_broadcast_call_by_name(name)</strong> </p></li><li><p><strong>M:all_balance_send_by_name(…)</strong> </p></li><li><p><strong>M:all_balance_call_by_name(…)</strong> </p></li><li><p><strong>M:all_mod_send_by_name(…)</strong> </p></li><li><p><strong>M:all_mod_call_by_name(name)</strong> </p></li><li><p><strong>M:all_broadcast_by_name(name)</strong> </p></li><li><p><strong>M:all_broadcast_call_by_name(name)</strong></p></li></ul><h1 id="不常用API"><a href="#不常用API" class="headerlink" title="不常用API"></a>不常用API</h1><ul><li><strong>M:set_svr_id(…)</strong> 指定服务id。</li><li><strong>M:set_instance_name(…)</strong> 指定访问实例名</li><li><strong>M:set_mod_num(…)</strong> 指定mod映射数</li></ul><h1 id="使用注意点："><a href="#使用注意点：" class="headerlink" title="使用注意点："></a>使用注意点：</h1><p>服务start之前不能使用rpc调用，因为服务还没有准备好，如果这样使用会抛出错误。</p>]]></content>
    
    
    <categories>
      
      <category>skynet_fly_api</category>
      
    </categories>
    
    
    <tags>
      
      <tag>skynet_fly_api</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>内部rpc调用</title>
    <link href="/2024/01/07/skynet_fly_api/rpc/"/>
    <url>/2024/01/07/skynet_fly_api/rpc/</url>
    
    <content type="html"><![CDATA[<h1 id="关联文件"><a href="#关联文件" class="headerlink" title="关联文件"></a>关联文件</h1><ul><li><a href="https://github.com/huahua132/skynet_fly/blob/master/lualib/skynet-fly/client/contriner_client.lua">contriner_client.lua</a></li></ul><h1 id="最常用API"><a href="#最常用API" class="headerlink" title="最常用API"></a>最常用API</h1><ul><li><p><strong>M:register(…)</strong> 注册访问。(没有注册访问的，去创建对象访问都会报错)，这个服务start之后就不能再调用。<br>  参数：module_name列表。</p></li><li><p><strong>M:new(module_name,instance_name,can_switch_func)</strong> 创建调用对象。<br>  参数：<br>  * <strong>module_name(string)</strong>  模块名称，需要send或者call通信的模块名称(相当于一级索引)。<br>  * <strong>instance_name(string)</strong> 实例名称，它是模块的二级分类(相当于二级索引)。<br>  * <strong>can_switch_func(function)</strong> 是否可以切换服务(不传默认可以)。<br>  返回值：<br>  1. <strong>client(table)</strong> rpc客户端对象。</p></li><li><p><strong>M:instance(module_name,instance_name)</strong> 使用单例访问对象(很多时候并不需要创建管理rpc调用对象)。<br>  参数：<br>  * <strong>module_name(string)</strong>  模块名称，需要send或者call通信的模块名称(相当于一级索引)。<br>  * <strong>instance_name(string)</strong> 实例名称，它是模块的二级分类(相当于二级索引)。<br>  返回值：<br>  1. <strong>client(table)</strong> rpc客户端对象。</p></li><li><p><strong>M:mod_send(…)</strong> 使用mod方式映射到一个<strong>server</strong>，之后用<strong>send</strong>方式给<strong>server</strong>发送消息(适用与长期与指定的服务联系)。<br>  参数: <strong>server</strong>接受的参数。<br>  返回值: 无。<br>  mod模式解释:假设<strong>server</strong>启动了<strong>6</strong>个，本服务的<strong>handle</strong>为7，取到的对应<strong>server</strong> handle为server_handle_list[7 % 6 + 1]。</p></li><li><p><strong>M:mod_call(…)</strong> 跟<strong>mod_send</strong>一致，唯一区别是使用<strong>call</strong>的方式发消息。</p></li><li><p><strong>M:set_mod_num(num)</strong> 设置mod值，没有设置的情况下，默认使用本服务的<strong>handle</strong>,用于解决有时候需要使用<strong>角色id</strong>来做映射。<br>  参数：<br>  * <strong>num(number)</strong> mod使用值。<br>  返回值：无</p></li><li><p><strong>M:balance_send(…)</strong> balance简单负载均衡，之后用<strong>send</strong>方式给<strong>server</strong>发送消息(适用与需要提高负载)。<br>  参数: <strong>server</strong>接受的参数。<br>  返回值: 无。<br>  balance模式解释: 假如<strong>server</strong>启动了<strong>6</strong>个，就会有<strong>server</strong>的handle列表，这种模式会1,2,3,4,5,6,1这样轮询的访问。</p></li><li><p><strong>M:balance_call(…)</strong> 跟<strong>balance_send</strong>一致，唯一区别是使用<strong>call</strong>的方式发消息。</p></li><li><p><strong>M:mod_send_by_name(…)</strong> 假如<strong>server</strong>启动了<strong>6</strong>个,3个<strong>instance_name</strong>为<strong>A</strong>，3个为<strong>B</strong>。这种方式基于指定的<strong>instance_name</strong>server_handle_list取映射。</p></li><li><p><strong>M:mod_call_by_name(…)</strong> call方式。</p></li><li><p><strong>M:balance_send_by_name(…)</strong> balance模式，send方式。</p></li><li><p><strong>M:balance_call_by_name(…)</strong> balance模式，call方式。</p></li><li><p><strong>M:set_instance_name(name)</strong> 设置instance_name。</p></li></ul><h1 id="不常用API"><a href="#不常用API" class="headerlink" title="不常用API"></a>不常用API</h1><ul><li><strong>M:broadcast(…)</strong> 广播。</li><li><strong>M:broadcast_call(…)</strong> 广播调用。</li><li><strong>M:broadcast_by_name(…)</strong> 通过instance_name广播。</li><li><strong>M:broadcast_call_by_name(…)</strong> 通过instance_name广播调用。</li><li><strong>M:set_week_visitor(…)</strong> 设置弱访问者,如果业务逻辑实在有环访问问题，可以使用这个设置。</li><li><strong>M:monitor_all()</strong> 监听所有的可热更服务地址，用于解决启动时，不确定访问哪些服务。</li><li><strong>M:CMD(cmd)</strong> 扩展CMD，不能热更服务需要扩展的CMD的命令。</li></ul><h1 id="使用注意点："><a href="#使用注意点：" class="headerlink" title="使用注意点："></a>使用注意点：</h1><p>服务start之前不能使用rpc调用，因为服务还没有准备好，如果这样使用会抛出错误。</p><h1 id="如果实在要在start中去rpc调用："><a href="#如果实在要在start中去rpc调用：" class="headerlink" title="如果实在要在start中去rpc调用："></a>如果实在要在start中去rpc调用：</h1><p>可以用fork包裹。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CMD.start</span><span class="hljs-params">()</span></span><br>    skynet.fock(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span><br>        rpc call...<br>    <span class="hljs-keyword">end</span>)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>已经坚持完善skynet_fly有半年多了，新年第一篇。<strong>新年快乐！！！</strong></p>]]></content>
    
    
    <categories>
      
      <category>skynet_fly_api</category>
      
    </categories>
    
    
    <tags>
      
      <tag>skynet_fly_api</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于增加skynet_fly orm_table_m 可热更服务</title>
    <link href="/2023/12/24/skynet_fly_ss/orm_table_m/"/>
    <url>/2023/12/24/skynet_fly_ss/orm_table_m/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>因为<strong>orm</strong>在多个服务持有的时候，没法保证一致性，所有需要把<strong>orm</strong>封装到独立服务中，其他服务通过rpc调用，为了使用便利性，封装了通用的<strong>orm</strong>可热更服务<strong>orm_table_m.lua</strong>和rpc调用模块<strong>orm_table_client.lua</strong>。</p><h1 id="orm-table-m-lua"><a href="#orm-table-m-lua" class="headerlink" title="orm_table_m.lua"></a>orm_table_m.lua</h1><p>转入的config需要提供一个配置项<strong>orm_plug</strong>，它是lua模块文件。需要提供<strong>init</strong>,<strong>call</strong>两个方法。</p><ul><li><strong>init()</strong> 方法需要创建出<strong>orm</strong>对象并且返回。</li><li><strong>call(func_name,…)</strong> 方法提供一系列rpc调用的方法。</li></ul><h2 id="热更处理"><a href="#热更处理" class="headerlink" title="热更处理"></a>热更处理</h2><p>当orm热更时，orm_table_m.lua会立即调用保存接口，确保数据全部同步到对应的数据库中，这个过程没有完成，新的服务都不会调用收到<strong>start</strong>回调，也不会收到服务地址变更的推送，这样就保证了数据只有一个服务持有<strong>保证数据一致性</strong>。强制保存过程中，如果操作失败会一直尝试，直到成功<strong>保证数据不丢失</strong>。通常操作失败是连接异常或者数据库挂壁了。</p><h2 id="call操作调用"><a href="#call操作调用" class="headerlink" title="call操作调用"></a>call操作调用</h2><p>其他服务调用<strong>orm服务</strong>时，可能orm服务正在热更，旧服务不再提供服务了，就需要通知<strong>rpc客户端</strong>，转移调用。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CMD.call</span><span class="hljs-params">(func_name,...)</span></span><br>    <span class="hljs-keyword">if</span> G_ISCLOSE <span class="hljs-keyword">then</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    <span class="hljs-keyword">end</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>, queue(g_orm_plug.call, func_name, ...)<br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CMD.herald_exit</span><span class="hljs-params">()</span></span><br>    G_ISCLOSE = <span class="hljs-literal">true</span><br><br>    queue(g_orm_obj.save_change_now,g_orm_obj)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>只需要在确定下线以后，通知move转移调用。</p><h1 id="orm-table-client-lua"><a href="#orm-table-client-lua" class="headerlink" title="orm_table_client.lua"></a>orm_table_client.lua</h1><h2 id="简化调用"><a href="#简化调用" class="headerlink" title="简化调用"></a>简化调用</h2><p>正常热更模块的rpc调用如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> client = contriner_client:new(<span class="hljs-string">&quot;orm_table_m&quot;</span>,<span class="hljs-string">&quot;player&quot;</span>)<br>client:mod_call(<span class="hljs-string">&#x27;call&#x27;</span>,<span class="hljs-string">&quot;doing_same&quot;</span>, arg1, arg2)<br></code></pre></td></tr></table></figure><p>为了简化调用，使用元表封装一层。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> mt = &#123;<span class="hljs-built_in">__index</span> = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(t,k)</span></span><br>    t[k] = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self,...)</span></span><br>        t._client = t._client <span class="hljs-keyword">or</span> contriner_client:new(<span class="hljs-string">&quot;orm_table_m&quot;</span>,t._orm_name)<br>        <span class="hljs-keyword">local</span> ret = <span class="hljs-literal">nil</span><br>        <span class="hljs-comment">--尝试 5 次，还不成功，那肯定是数据库挂逼了或者热更后执行保存比较耗时</span><br>        <span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span>,<span class="hljs-number">5</span> <span class="hljs-keyword">do</span><br>            ret = &#123;t._client:mod_call(<span class="hljs-string">&quot;call&quot;</span>, k, ...)&#125;<br>            <span class="hljs-keyword">local</span> is_move = ret[<span class="hljs-number">1</span>]<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> is_move <span class="hljs-keyword">then</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-built_in">select</span>(<span class="hljs-number">2</span>,tunpack(ret))<br>            <span class="hljs-keyword">end</span><br>            skynet.<span class="hljs-built_in">yield</span>()<br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">return</span> t[k]<br><span class="hljs-keyword">end</span>&#125;<br></code></pre></td></tr></table></figure><p>之后调用方式如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> client = orm_table_client:new(<span class="hljs-string">&quot;player&quot;</span>)<br>client:doing_same(arg1, arg2)<br><span class="hljs-comment">--或者</span><br>orm_table_client:instance(<span class="hljs-string">&quot;player&quot;</span>):doing_same(arg1, arg2)<br></code></pre></td></tr></table></figure><p>封装的目的除了简化调用，还有一个作用就是，对接<strong>特殊处理</strong>。</p><h2 id="特殊处理"><a href="#特殊处理" class="headerlink" title="特殊处理"></a>特殊处理</h2><p>因为热更过程中，旧服务不再提供服务，会返回<strong>move</strong>的结果，此时仅仅需要重试就行了。因为<strong>contriner_client</strong>默认使用了服务切换。</p><h2 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h2><p>因为旧服务被替代之后，无法再进行<strong>服务切换</strong>，所以它的消息会一直发给旧服务。（如果放开这个限制，就会出现AB问题），比如旧服务访问的函数，在最新的版本被删除了。或者函数调用的参数做了调整了，都会导致调用出错。暂时想不到很完美的方案解决这个问题。只能旧服务不能访问orm可以接受的情况下，可以用热更，其他情况只能停服更新了。</p><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p><a href="https://github.com/huahua132/skynet_fly/tree/master/examples/orm">orm</a></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>完善了orm系统。</p><p><a href="https://github.com/huahua132/skynet_fly">skynetfly源码地址</a></p>]]></content>
    
    
    <categories>
      
      <category>skynet_fly实现思路历程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>skynet_fly实现思路历程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于增加skynet_fly orm数据关系映射</title>
    <link href="/2023/12/24/skynet_fly_ss/orm/"/>
    <url>/2023/12/24/skynet_fly_ss/orm/</url>
    
    <content type="html"><![CDATA[<h1 id="ORM简介"><a href="#ORM简介" class="headerlink" title="ORM简介"></a>ORM简介</h1><p>ORM（Object-Relational Mapping，对象关系映射）是一种编程技术，用于在不同类型的系统之间转换数据。在关系数据库和面向对象编程语言之间，ORM 为数据的转换提供了一个桥梁。这种技术允许我们使用编程语言中的对象表示和操作数据库中的数据，而不必编写底层的SQL代码。</p><p>ORM 的核心优势在于抽象化和自动化数据存储的细节，使开发者可以专注于业务逻辑，而无需关心数据库操作的具体实现。</p><h2 id="ORM-的主要功能包括："><a href="#ORM-的主要功能包括：" class="headerlink" title="ORM 的主要功能包括："></a>ORM 的主要功能包括：</h2><ol><li><p>映射（Mapping）：将数据库表（或视图）映射到代码中的类，将记录映射到对象实例，列映射到类的属性。</p></li><li><p>CRUD 操作：提供了对象级别的创建（Create）、读取（Read）、更新（Update）和删除（Delete）操作，不需要直接使用SQL语句。</p></li><li><p>查询接口：提供了建立在对象上的查询接口，允许我们使用类似SQL功能的方法来查询和操作数据。</p></li><li><p>事务管理：支持事务操作，确保数据一致性和完整性。</p></li><li><p>缓存：为了性能优化，ORM系统通常提供了一级或二级缓存机制，减少对数据库的直接访问次数。</p></li></ol><h2 id="ORM-的优点："><a href="#ORM-的优点：" class="headerlink" title="ORM 的优点："></a>ORM 的优点：</h2><ul><li>生产效率：通过简化数据库操作，ORM 可以提高开发速度。</li><li>可维护性：代码通常更清晰、更可维护，因为它遵循面向对象的原则。</li><li>可移植性：ORM 代码通常不依赖于具体的数据库，更容易在不同的数据库系统之间移植。</li><li>减少重复：ORM 库通常提供了大量公共代码，减少开发人员需要编写和维护的代码量。</li></ul><h2 id="ORM-的缺点："><a href="#ORM-的缺点：" class="headerlink" title="ORM 的缺点："></a>ORM 的缺点：</h2><ul><li>性能开销：ORM 增加了一层抽象，可能会导致性能开销，尤其是在复杂查询和高负载操作的情况下。</li><li>复杂性：在处理复杂的查询或性能优化时，ORM 可能不如使用原生 SQL 灵活。</li><li>学习曲线：需要学习使用 ORM 工具或框架，了解其设计和最佳实践。</li></ul><h1 id="skynet-fly-ORM提供功能"><a href="#skynet-fly-ORM提供功能" class="headerlink" title="skynet_fly ORM提供功能"></a>skynet_fly ORM提供功能</h1><ol><li>映射提供。</li><li>CRUD操作提供。</li><li>提供主键查询和查询所有。</li><li>不支持事务，确保数据一致性和完整性。</li><li>缓存，提供缓存时间和永久缓存机制，定时批量同步修改。</li></ol><p>实现orm的目标是能够应付非常常见的功能数据，比如跟玩家id，角色id关联的数据。并不想适配比较复杂的需求场景，比如分页查询，条件查询等等。这样orm能够更好的适配数据库，比如mysql，redis，mongo等等。<br>这样能够简化实现，方便后续维护优化，也不用担心性能问题（因为不能通过orm做复杂的查询工作）,复杂性也没有了，学习也很简单，因为只有 CRUD 和通过主键查询的接口，并且通过主键查询的也是可以落入缓存的。</p><h1 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h1><p>实现上通过<strong>依赖反转</strong>的方式，通过抽象出<strong>数据适配器接口</strong>，让<strong>数据表实体</strong>依赖<strong>数据适配器接口</strong>，这样想对接不同的数据库，只需要实现<strong>数据适配器接口</strong>就行。</p><p>结构图<br><img src="/img/skynet_fly/orm.png"></p><h2 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h2><p>数据类型支持。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> FILED_TYPE = &#123;<br>    int8         = <span class="hljs-number">1</span>,<br>    int16        = <span class="hljs-number">2</span>,<br>    int32        = <span class="hljs-number">3</span>,<br>    int64        = <span class="hljs-number">4</span>,<br>   <br>    uint8        = <span class="hljs-number">11</span>,<br>    uint16       = <span class="hljs-number">12</span>,<br>    uint32       = <span class="hljs-number">13</span>,<br>   <br>    string32     = <span class="hljs-number">31</span>,<br>    string64     = <span class="hljs-number">32</span>,<br>    string128    = <span class="hljs-number">33</span>,<br>    string256    = <span class="hljs-number">34</span>,<br>    string512    = <span class="hljs-number">35</span>,<br>    string1024   = <span class="hljs-number">36</span>,<br>    string2048   = <span class="hljs-number">37</span>,<br>    string4096   = <span class="hljs-number">38</span>,<br>    string8192   = <span class="hljs-number">39</span>,<br><br>    text         = <span class="hljs-number">51</span>,<br>    blob         = <span class="hljs-number">52</span>,<br>&#125;<br></code></pre></td></tr></table></figure><p>不支持浮点型，因为浮点型有精度问题，而且系统，语言的处理可能都不一样，业务上尽量不用。<br>不支持bool类型，业务上直接用int8类型替代就行了。</p><h3 id="创建表示例"><a href="#创建表示例" class="headerlink" title="创建表示例"></a>创建表示例</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> adapter = ormadapter_mysql:new(<span class="hljs-string">&quot;admin&quot;</span>)<br><span class="hljs-keyword">local</span> orm_obj = ormtable:new(<span class="hljs-string">&quot;t_player&quot;</span>)<br>:int64(<span class="hljs-string">&quot;player_id&quot;</span>)<br>:int64(<span class="hljs-string">&quot;role_id&quot;</span>)<br>:int8(<span class="hljs-string">&quot;sex&quot;</span>)<br>:string32(<span class="hljs-string">&quot;nickname&quot;</span>)<br>:string64(<span class="hljs-string">&quot;email&quot;</span>)<br>:uint8(<span class="hljs-string">&quot;sex1&quot;</span>)<br>:int16(<span class="hljs-string">&quot;sex2&quot;</span>)<br>:uint16(<span class="hljs-string">&quot;sex3&quot;</span>)<br>:int32(<span class="hljs-string">&quot;sex4&quot;</span>)<br>:uint32(<span class="hljs-string">&quot;sex5&quot;</span>)<br>:int64(<span class="hljs-string">&quot;sex6&quot;</span>)<br>:string128(<span class="hljs-string">&quot;sex7&quot;</span>)<br>:string256(<span class="hljs-string">&quot;sex8&quot;</span>)<br>:string512(<span class="hljs-string">&quot;sex9&quot;</span>)<br>:string1024(<span class="hljs-string">&quot;sex10&quot;</span>)<br>:string2048(<span class="hljs-string">&quot;sex11&quot;</span>)<br>:string4096(<span class="hljs-string">&quot;sex12&quot;</span>)<br>:string8192(<span class="hljs-string">&quot;sex13&quot;</span>)<br>:text(<span class="hljs-string">&quot;sex14&quot;</span>)<br>:blob(<span class="hljs-string">&quot;sex15&quot;</span>)<br>:set_cache(<span class="hljs-number">500</span>,<span class="hljs-number">500</span>)  <span class="hljs-comment">--设置 5秒的缓存 间隔5秒同步数据库（有修改同步）</span><br>:set_keys(<span class="hljs-string">&quot;player_id&quot;</span>,<span class="hljs-string">&quot;role_id&quot;</span>,<span class="hljs-string">&quot;sex&quot;</span>) <span class="hljs-comment">--设置3个关联key</span><br>:builder(adapter)<br></code></pre></td></tr></table></figure><p>一开始想法是用写lua表字段描述的方式来创建比如：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> des = &#123;<br>    &#123;name = <span class="hljs-string">&quot;player_id&quot;</span>, <span class="hljs-built_in">type</span> = <span class="hljs-string">&quot;int8&quot;</span>, is_key = <span class="hljs-literal">true</span>&#125;,<br>    &#123;name = <span class="hljs-string">&quot;role_id&quot;</span>, <span class="hljs-built_in">type</span> = <span class="hljs-string">&quot;int64&quot;</span>, is_key = <span class="hljs-literal">false</span>&#125;,<br>&#125;<br></code></pre></td></tr></table></figure><p>后来想想这种用 <strong>建造者模式</strong>更适合。<br><strong>优点</strong></p><ol><li>不需要写name,type描述字段,而且类型的函数没有时或者检查有错，直接在对应的行就报错了，更有利于开发。</li><li>能够设置一些额外属性，比如<strong>set_cache</strong>，设置缓存时间。</li><li>代码结构更清晰。</li></ol><h2 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h2><p>通常在实际业务开发中，可能由于需求的变化，想要改动表结构，大部分情况都是新增字段，orm提供修改表的手段，提供<strong>新增字段</strong>，<strong>删除字段</strong>。<br>不可以<strong>删除或者修改主键</strong>，也不可以修改<strong>关联主键顺序</strong>。</p><h2 id="修改示例"><a href="#修改示例" class="headerlink" title="修改示例"></a>修改示例</h2><p>修改表并不需要调用其他<strong>API</strong>，使用中，只需要去调整创建过程即可。<br>基于上面的<strong>创建示例</strong>，<strong>修改示例</strong>如下。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs lua"> <span class="hljs-keyword">local</span> adapter = ormadapter_mysql:new(<span class="hljs-string">&quot;admin&quot;</span>)<br><span class="hljs-keyword">local</span> orm_obj = ormtable:new(<span class="hljs-string">&quot;t_player&quot;</span>)<br>    :int64(<span class="hljs-string">&quot;player_id&quot;</span>)<br>    :int64(<span class="hljs-string">&quot;role_id&quot;</span>)<br>    :int8(<span class="hljs-string">&quot;sex&quot;</span>)<br>    :int8(<span class="hljs-string">&quot;nickname1&quot;</span>)<br>    :set_keys(<span class="hljs-string">&quot;player_id&quot;</span>,<span class="hljs-string">&quot;role_id&quot;</span>,<span class="hljs-string">&quot;sex&quot;</span>)<br>    :builder(adapter)<br></code></pre></td></tr></table></figure><p>这个修改示例中，我们去掉了多余不想用的字段，增加了<strong>nickname1</strong>字段。<br><strong>删除字段</strong>并不会真的去对应数据库执行删除字段(这个是ormadapter接口实现决定的)，只是<strong>orm</strong>不在关心该字段，查询不取，插入不写。</p><h2 id="字段默认值"><a href="#字段默认值" class="headerlink" title="字段默认值"></a>字段默认值</h2><p>当我们没有为字段设置值的时候，字段提供默认值。<br>对于lua是<strong>string</strong>类型的默认为空串,也就是””<br>对于lua是<strong>number</strong>类型的默认为0</p><h2 id="创建数据"><a href="#创建数据" class="headerlink" title="创建数据"></a>创建数据</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lua">orm_obj:create_entry(<br>    &#123;player_id = <span class="hljs-number">10005</span>,role_id = <span class="hljs-number">1</span>, sex = <span class="hljs-number">1</span>&#125;,<br>    &#123;player_id = <span class="hljs-number">10006</span>,role_id = <span class="hljs-number">1</span>, sex = <span class="hljs-number">2</span>&#125;<br>    )<br></code></pre></td></tr></table></figure><p>支持一次创建多条。</p><h2 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据"></a>读取数据</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> player_id = <span class="hljs-number">10005</span><br><span class="hljs-keyword">local</span> role_id = <span class="hljs-number">1</span><br><span class="hljs-keyword">local</span> sex = <span class="hljs-number">1</span><br><span class="hljs-keyword">local</span> entry_list = orm_obj:get_entry(player_id)                 <span class="hljs-comment">--查询player_id</span><br><span class="hljs-keyword">local</span> entry_list = orm_obj:get_entry(player_id,role_id)         <span class="hljs-comment">--查询player_id,role_id</span><br><span class="hljs-keyword">local</span> entry_list = orm_obj:get_entry(player_id, role_id, sex)   <span class="hljs-comment">--查询player_id,role_id,sex</span><br><span class="hljs-keyword">local</span> entry_list = orm_obj:get_all_entry()                      <span class="hljs-comment">--查询所有数据</span><br></code></pre></td></tr></table></figure><p>利用关联主键，使用最左原则查询数据。</p><h2 id="修改更新数据"><a href="#修改更新数据" class="headerlink" title="修改更新数据"></a>修改更新数据</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> entry_list = orm_obj:get_entry(player_id, role_id, sex)   <span class="hljs-comment">--查询player_id,role_id,sex</span><br><span class="hljs-keyword">local</span> entry = entry_list[<span class="hljs-number">1</span>]<br>entry:set(<span class="hljs-string">&quot;nickname&quot;</span>,<span class="hljs-string">&quot;abc&quot;</span>)<br><br>orm_obj:save_entry(entry)<br></code></pre></td></tr></table></figure><p>修改数据有个限制，主键不能修改（正常也不会去改主键）。<br>更新数据也可以不用主动调用save_entry,可以用set_cache设置缓存，同时设置间隔多少秒去同步，这种方式效率更高，因为是定时批量同步的。</p><h2 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h2><p>删除数据类似读取数据通过主键keys去删除。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> player_id = <span class="hljs-number">10005</span><br><span class="hljs-keyword">local</span> role_id = <span class="hljs-number">1</span><br><span class="hljs-keyword">local</span> sex = <span class="hljs-number">1</span><br><span class="hljs-keyword">local</span> entry_list = orm_obj:delete_entry(player_id)                 <span class="hljs-comment">--删除player_id</span><br><span class="hljs-keyword">local</span> entry_list = orm_obj:delete_entry(player_id,role_id)         <span class="hljs-comment">--删除player_id,role_id</span><br><span class="hljs-keyword">local</span> entry_list = orm_obj:delete_entry(player_id, role_id, sex)   <span class="hljs-comment">--删除player_id,role_id,sex</span><br><span class="hljs-keyword">local</span> entry_list = orm_obj:delete_all_entry()                      <span class="hljs-comment">--删除所有数据</span><br></code></pre></td></tr></table></figure><h1 id="适配"><a href="#适配" class="headerlink" title="适配"></a>适配</h1><p>目前针对orm适配了mysql,后续会适配mango。适配器需要实现六个方法分别是：<strong>new</strong>,<strong>builder</strong>,<strong>create_entry</strong>,<strong>get_entry</strong>,<strong>save_entry</strong>,<strong>delete_entry</strong>。</p><ol><li>new, 创建适配器对象。</li><li>builder(tab_name, filed_list, filed_map, key_list) 构建表。</li><li>create_entry(entry_data_list) 创建表数据。</li><li>get_entry(key_values) 查询表数据。</li><li>save_entry(entry_data_list, change_map_list) 保存表数据。</li><li>delete_entry(key_values) 删除表数据。</li></ol><h1 id="适配mysql"><a href="#适配mysql" class="headerlink" title="适配mysql"></a>适配mysql</h1><p>针对适配MySQL，我的设计是这样的，在<strong>builder</strong>构建方法中，表不存在创建表，表存在更新表，主键不能为空，主键不能变更修改。<br>在<strong>create_entry</strong>和<strong>save_entry</strong>中做了批量安全处理（消息过长的分批执行）。</p><h1 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h1><p>针对ormmysql写了健全的单元测试。<br><a href="https://github.com/huahua132/skynet_fly/blob/master/test/module/ormmysql_test_m.lua">ormmysqltest</a></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>为框架增加了orm特性的支持。增强了skynet_fly的功能。</p><h1 id="使用orm的限制"><a href="#使用orm的限制" class="headerlink" title="使用orm的限制"></a>使用orm的限制</h1><p>使用orm需要注意数据一致性问题。orm只能在一个服务中使用才能保证一致性。特别是使用缓存的时候，不用缓存，在多个服务同时用，也需要考虑分布式问题（不用orm多个服务也存在分布式问题）。<br>有一种情况下可以多服使用：比如用player_id绑定服务器，并且服务器只会查询修改连接本服的player_id的数据。<br>其他情况需要在一个服务中处理，后续想利用框架的热更模块对接上<strong>orm</strong>,并且处理好热更问题。因为热更过程中可能新旧服务都持有数据的，可能出现数据不一致，目前的想法是热更后，旧服务的请求全部转给新服务处理，旧服务收到准备下线的时候，保存所有数据，并拒绝之后所有的请求，通知等待新服上线处理，就可以解决这个问题。</p><h1 id="热更orm-table-注意点"><a href="#热更orm-table-注意点" class="headerlink" title="热更orm_table 注意点"></a>热更orm_table 注意点</h1><p>如果一个服务访问了orm_table_m服务，这个服务同时跟orm_table_m一起热更，由于 <strong>使用orm的限制</strong>的特性，旧的orm服务不在提供服务，然后旧的访问orm的服务又不能切换访问到新的orm服务。这时旧的服务将访问不了orm服务。</p><h1 id="orm的缓存策略"><a href="#orm的缓存策略" class="headerlink" title="orm的缓存策略"></a>orm的缓存策略</h1><p>面对高并发的场景，我们需要尽量减少访问数据库，<code>skynet_fly</code>提供了<strong>设置缓存时间、改动统一同步的设置项</strong>。<br>比如设置5秒缓存，1秒同步一次修改。 set_cache(500,100)。<br>orm会在创建和查询的时间重置一下缓存。这样可以尽可能保留热数据的缓存不失效。</p><h1 id="缓存优化-2024-x2F-3-x2F-17"><a href="#缓存优化-2024-x2F-3-x2F-17" class="headerlink" title="缓存优化 2024&#x2F;3&#x2F;17"></a>缓存优化 2024&#x2F;3&#x2F;17</h1><p>由于之前的缓存，没有考虑缓存总量控制，当缓存时长过长，缓存量大的时候，会导致服务器内存增长不可控。所以需要引入缓存淘汰策略来控制缓存总量。<br>常见的缓存淘汰策略有:</p><ul><li><strong>LRU</strong> 最近最少使用淘汰算法（Least Recently Used）。LRU是淘汰最长时间没有被使用的数据</li><li><strong>LFU</strong> 最不经常使用淘汰算法（Least Frequently Used）。LFU是淘汰一段时间内，使用次数最少的数据</li><li><strong>TTI</strong> 最快过期淘汰</li></ul><p>由于目前以有缓存时间，就打算先实现<strong>TTI</strong>的策略，后续有想法再引入<strong>LRU</strong>,<strong>LFU</strong>。</p><h1 id="缓存穿透问题优化-2024-x2F-3-x2F-24"><a href="#缓存穿透问题优化-2024-x2F-3-x2F-24" class="headerlink" title="缓存穿透问题优化 2024&#x2F;3&#x2F;24"></a>缓存穿透问题优化 2024&#x2F;3&#x2F;24</h1><p>缓存常见3大问题</p><ul><li><p><strong>缓存雪崩</strong> 大量热点数据同时过期，导致大量请求落到数据库。<br>  <strong>常见的解决方案</strong><br>  过期时间增加额外的随机数，使过期时间分散。<br>  <strong>skynet_fly解决方案</strong><br>  创建和查询，都会使过期时间重置，热点数据在这种机制下不可能大量同时过期。</p></li><li><p><strong>缓存击穿</strong> 单个热点数据存在大量请求，数据过期后，大量请求落到数据库。<br>  <strong>常见的解决方案</strong><br>  定量热点数据不设置过期时间。<br>  <strong>skynet_fly解决方案</strong><br>  提供设置不过期手段。<br>  查询重置过期时间。<br>  所有请求都要经过orm代理，就算过期了，经过queue的排队处理，也只有一条请求落到数据库，之后的请求都能命中缓存。</p></li><li><p><strong>缓存穿透</strong> 查询数据库不存在的数据，一般缓存也不会建立。导致大量请求落到数据库。<br>  <strong>常见的解决方案</strong><br>  布隆过滤器(存在误判)。<br>  建立空缓存。<br>  <strong>skynet_fly解决方案</strong><br>  建立空缓存，因为大部分业务是需要精准判断的。<br>  针对不过期缓存的优化，既然缓存不过期，那边orm初始化的时候可以把数据库的所有数据拉取出来建立缓存。之后查询，如果缓存不存在那么就是不存在。</p></li></ul><p><a href="https://github.com/huahua132/skynet_fly">skynetfly源码地址</a></p>]]></content>
    
    
    <categories>
      
      <category>skynet_fly实现思路历程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>skynet_fly实现思路历程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>新增可热更服务</title>
    <link href="/2023/12/17/skynet_fly_api/module/"/>
    <url>/2023/12/17/skynet_fly_api/module/</url>
    
    <content type="html"><![CDATA[<h1 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h1><p>统一写在<code>module</code>的文件夹，好处就是review代码时能比较清晰的分清那个文件是<strong>可热更服务</strong>,还是lua模块文件，还是skynet的普通服务（skynet普通服务建议都放在sevice文件夹下）。</p><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> CMD = &#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CMD.start</span><span class="hljs-params">(config)</span></span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CMD.herald_exit</span><span class="hljs-params">()</span></span><br>    <span class="hljs-built_in">log</span>.<span class="hljs-built_in">error</span>(<span class="hljs-string">&quot;预告退出&quot;</span>)<br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CMD.exit</span><span class="hljs-params">()</span></span><br>    <span class="hljs-built_in">log</span>.<span class="hljs-built_in">error</span>(<span class="hljs-string">&quot;退出&quot;</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CMD.fix_exit</span><span class="hljs-params">()</span></span><br>    <span class="hljs-built_in">log</span>.<span class="hljs-built_in">error</span>(<span class="hljs-string">&quot;确认要退出&quot;</span>)<br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CMD.cancel_exit</span><span class="hljs-params">()</span></span><br>    <span class="hljs-built_in">log</span>.<span class="hljs-built_in">error</span>(<span class="hljs-string">&quot;取消退出&quot;</span>)<br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CMD.check_exit</span><span class="hljs-params">()</span></span><br>    <span class="hljs-built_in">log</span>.<span class="hljs-built_in">error</span>(<span class="hljs-string">&quot;检查退出&quot;</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>start</strong> （必须实现）开始，通常在这里做一些初始化的操作，config是<strong>load_mods</strong>传入的配置。（限制）不能在这个阶段访问其他可热更服务。<br><strong>herald_exit</strong> 热更时，启动新服务之前会给旧服务发预告。<br><strong>exit</strong> （必须实现）说明可以退出了，返回true的话，10分钟后会销毁改服务，false都话就不会销毁。<br><strong>fix_exit</strong> 确定被新服务替代了。<br><strong>cancel_exit</strong> 热更时新服务启动失败了，比如start没有返回true，这时候旧服务应该继续干活。<br><strong>check_exit</strong> 用于检查能不能退出。</p>]]></content>
    
    
    <categories>
      
      <category>skynet_fly_api</category>
      
    </categories>
    
    
    <tags>
      
      <tag>skynet_fly_api</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>启动配置load_mods.lua</title>
    <link href="/2023/12/17/skynet_fly_api/load_mods/"/>
    <url>/2023/12/17/skynet_fly_api/load_mods/</url>
    
    <content type="html"><![CDATA[<h1 id="作用定位"><a href="#作用定位" class="headerlink" title="作用定位"></a>作用定位</h1><p>可热更服务的启动配置文件，用于配置可插拔的可热更服务，可以自定义启动<strong>顺序</strong>，<strong>数量</strong>,<strong>配置参数</strong>，<strong>推迟最后启动</strong>。</p><h1 id="示例参考"><a href="#示例参考" class="headerlink" title="示例参考"></a>示例参考</h1><p><a href="https://github.com/huahua132/skynet_fly/blob/master/examples/AB_question/load_mods.lua">AB_question</a></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">return</span> &#123;<br>A_m = &#123;<br>launch_seq = <span class="hljs-number">1</span>,<br>launch_num = <span class="hljs-number">1</span>,<br>&#125;,<br>    B_m = &#123;<br>        launch_seq = <span class="hljs-number">2</span>,<br>launch_num = <span class="hljs-number">2</span>,<br>mod_args = &#123;<br>&#123;instance_name = <span class="hljs-string">&quot;test_one&quot;</span>&#125;,<br>&#123;instance_name = <span class="hljs-string">&quot;test_two&quot;</span>&#125;,<br>&#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="配置参数说明"><a href="#配置参数说明" class="headerlink" title="配置参数说明"></a>配置参数说明</h1><p><strong>A_m</strong>,<strong>B_m</strong>是指定的热更服务文件名。</p><p><strong>launch_seq</strong> 启动顺序。<br><strong>launch_num</strong> 启动数量。<br><strong>mod_args</strong>   模块对应的启动配置。<br><strong>default_arg</strong> 如果配置都一样，就用default_arg，也可以default_arg和mod_args一起用，启动会优先用mod_args对应的配置（如果对应下标的配置存在）。<br><strong>instance_name</strong> 热更服务实例名称，用于给热更服务做分类，比如每个mysql服务连接的数据库都不同，可以用instance_name来区分，之后通过指定instance_name访问。<br><strong>delay_run</strong> 延迟运行。有时候有些服务需要之后再启动。比如这个<a href="https://github.com/huahua132/skynet_fly/blob/master/examples/digitalbomb/main.lua">数字炸弹示例的客户端</a></p><h1 id="修改启动配置指向"><a href="#修改启动配置指向" class="headerlink" title="修改启动配置指向"></a>修改启动配置指向</h1><p>通常需要区分<strong>开发环境</strong>，<strong>测试环境</strong>，<strong>预发环境</strong>，<strong>正式环境</strong>的启动配置。<br>我们可以修改由<code>binshell/make_server.sh</code>生成好的skynet启动配置中的<code>loadmodsfile</code>配置项，改变启用的可热更服务配置。</p>]]></content>
    
    
    <categories>
      
      <category>skynet_fly_api</category>
      
    </categories>
    
    
    <tags>
      
      <tag>skynet_fly_api</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于skynet_fly gate，ws_gate消息包设计</title>
    <link href="/2023/12/10/skynet_fly_ss/pack/"/>
    <url>/2023/12/10/skynet_fly_ss/pack/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近<code>skynet_fly</code>被群友用来写项目，并且上线了，感觉还是很欣慰的，群友用了我的<code>房间类游戏架构</code>，大概三周的时间，游戏就直接上线了，过程中咨询过我一些问题，其中关于协议这一块，解释的比较久，并且最后是我把我写好的<code>中国象棋客户端</code>上传了github，让他给客户端参考，才较快解决了前后端协议对接。所以想写这一篇来拆解一下协议封装。</p><h1 id="协议图"><a href="#协议图" class="headerlink" title="协议图"></a>协议图</h1><p><img src="/img/skynet_fly/pack.png"></p><h1 id="skynet-gate协议包"><a href="#skynet-gate协议包" class="headerlink" title="skynet gate协议包"></a>skynet gate协议包</h1><p>skynet协议包就是上图<strong>红色</strong>部分，<strong>大端2字节的包体长度</strong>拼接<strong>包体</strong>。</p><h1 id="skynet-fly-协议包"><a href="#skynet-fly-协议包" class="headerlink" title="skynet_fly 协议包"></a>skynet_fly 协议包</h1><p>skynet_fly的gate和ws_gate协议基于skynet协议把包体拆分成了<strong>大端2字节包名长度</strong>，<strong>包名</strong>，<strong>消息体</strong>。</p><h2 id="为啥这么做"><a href="#为啥这么做" class="headerlink" title="为啥这么做"></a>为啥这么做</h2><p>因为通常消息派发都会在框架层处理，业务层只需要监听处理就行。这样业务层只需要监听处理对应的<strong>包名</strong>,<strong>消息体</strong>。</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="包体处理"><a href="#包体处理" class="headerlink" title="包体处理"></a>包体处理</h2><p>这个是对于<strong>包体</strong>的打包解包，通过函数式编程，抽象了两个基础方法。只需要提供具体的编码解码方式就可以创建对应的打包解包函数。<br>代码路径 <code>lualib/netpack/netpack_base</code></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> <span class="hljs-built_in">assert</span> = <span class="hljs-built_in">assert</span><br><span class="hljs-keyword">local</span> spack = <span class="hljs-built_in">string</span>.pack<br><br><span class="hljs-keyword">local</span> M = &#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">M.create_pack</span><span class="hljs-params">(encode)</span></span><br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(name,tab)</span></span><br><span class="hljs-built_in">assert</span>(name)<br><span class="hljs-built_in">assert</span>(tab)<br><br><span class="hljs-keyword">local</span> ok,str = encode(name,tab)<br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> ok <span class="hljs-keyword">then</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>,str<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">local</span> pbmsgbuff = spack(<span class="hljs-string">&quot;&gt;I2&quot;</span>,name:<span class="hljs-built_in">len</span>()) .. name .. str<br><span class="hljs-keyword">return</span> pbmsgbuff<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">M.create_unpack</span><span class="hljs-params">(decode)</span></span><br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(msgbuff)</span></span><br><span class="hljs-built_in">assert</span>(msgbuff)<br><span class="hljs-keyword">local</span> name_sz = (msgbuff:<span class="hljs-built_in">byte</span>(<span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-number">8</span>) + msgbuff:<span class="hljs-built_in">byte</span>(<span class="hljs-number">2</span>)<br><span class="hljs-keyword">local</span> packname = msgbuff:<span class="hljs-built_in">sub</span>(<span class="hljs-number">3</span>,<span class="hljs-number">3</span> + name_sz - <span class="hljs-number">1</span>)<br><span class="hljs-keyword">local</span> pack_str = msgbuff:<span class="hljs-built_in">sub</span>(<span class="hljs-number">3</span> + name_sz)<br><br><span class="hljs-keyword">local</span> ok,tab = decode(packname,pack_str)<br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> ok <span class="hljs-keyword">then</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>,tab<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">return</span> packname,tab<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">return</span> M<br></code></pre></td></tr></table></figure><p>例如json</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> json = <span class="hljs-built_in">require</span> <span class="hljs-string">&quot;cjson&quot;</span><br><span class="hljs-keyword">local</span> netpack_base = <span class="hljs-built_in">require</span> <span class="hljs-string">&quot;netpack_base&quot;</span><br><br><span class="hljs-keyword">local</span> <span class="hljs-built_in">pcall</span> = <span class="hljs-built_in">pcall</span><br><span class="hljs-keyword">local</span> <span class="hljs-built_in">assert</span> = <span class="hljs-built_in">assert</span><br><br><span class="hljs-keyword">local</span> M = &#123;&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">M.encode</span><span class="hljs-params">(name,tab)</span></span><br><span class="hljs-built_in">assert</span>(tab)<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">pcall</span>(json.encode,tab)<br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">M.decode</span><span class="hljs-params">(name,pstr)</span></span><br><span class="hljs-built_in">assert</span>(pstr)<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">pcall</span>(json.decode,pstr)<br><span class="hljs-keyword">end</span><br><br>M.pack = netpack_base.create_pack(M.encode)<br><br>M.<span class="hljs-built_in">unpack</span> = netpack_base.create_unpack(M.decode)<br><br><span class="hljs-keyword">return</span> M<br></code></pre></td></tr></table></figure><h2 id="整包处理"><a href="#整包处理" class="headerlink" title="整包处理"></a>整包处理</h2><p>这是对于整包的处理，包含包体长度，也是采用了函数式编程，提供了<strong>单发消息</strong>，<strong>广播消息</strong>，<strong>解包</strong>，<strong>客户端收包处理</strong>。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> skynet = <span class="hljs-built_in">require</span> <span class="hljs-string">&quot;skynet&quot;</span><br><span class="hljs-keyword">local</span> socket = <span class="hljs-built_in">require</span> <span class="hljs-string">&quot;socket&quot;</span><br><span class="hljs-keyword">local</span> netpack = <span class="hljs-built_in">require</span> <span class="hljs-string">&quot;netpack&quot;</span><br><span class="hljs-keyword">local</span> websocket = <span class="hljs-built_in">require</span> <span class="hljs-string">&quot;websocket&quot;</span><br><span class="hljs-keyword">local</span> <span class="hljs-built_in">log</span> = <span class="hljs-built_in">require</span> <span class="hljs-string">&quot;log&quot;</span><br><br><span class="hljs-keyword">local</span> <span class="hljs-built_in">pcall</span> = <span class="hljs-built_in">pcall</span><br><span class="hljs-keyword">local</span> <span class="hljs-built_in">string</span> = <span class="hljs-built_in">string</span><br><span class="hljs-keyword">local</span> <span class="hljs-built_in">assert</span> = <span class="hljs-built_in">assert</span><br><br><span class="hljs-keyword">local</span> M = &#123;&#125;<br><br><span class="hljs-comment">-------------------------------------------------------</span><br><span class="hljs-comment">--基于skynet gate 的消息发送</span><br><span class="hljs-comment">-------------------------------------------------------</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">M.create_gate_send</span><span class="hljs-params">(pack)</span></span><br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(gate,fd,name,tab)</span></span><br><span class="hljs-built_in">assert</span>(fd)<br><span class="hljs-built_in">assert</span>(name)<br><span class="hljs-built_in">assert</span>(tab)<br><br><span class="hljs-keyword">local</span> msg,err = pack(name,tab)<br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> msg <span class="hljs-keyword">then</span><br><span class="hljs-built_in">log</span>.<span class="hljs-built_in">error</span>(<span class="hljs-string">&quot;util_net_base.pack err &quot;</span>,name,tab,err)<br><span class="hljs-keyword">return</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">return</span> socket.<span class="hljs-built_in">write</span>(fd,netpack.pack(msg))<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">-------------------------------------------------------</span><br><span class="hljs-comment">--基于skynet gate 的消息广播</span><br><span class="hljs-comment">-------------------------------------------------------</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">M.create_gate_broadcast</span><span class="hljs-params">(pack)</span></span><br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(gate_list,fd_list,name,tab)</span></span><br><span class="hljs-built_in">assert</span>(fd_list <span class="hljs-keyword">and</span> #fd_list &gt; <span class="hljs-number">0</span>)<br><span class="hljs-built_in">assert</span>(name)<br><span class="hljs-built_in">assert</span>(tab)<br><br><span class="hljs-keyword">local</span> msg,err = pack(name,tab)<br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> msg <span class="hljs-keyword">then</span><br><span class="hljs-built_in">log</span>.<span class="hljs-built_in">error</span>(<span class="hljs-string">&quot;util_net_base.pack err &quot;</span>,name,tab,err)<br><span class="hljs-keyword">return</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span>,#fd_list <span class="hljs-keyword">do</span><br><span class="hljs-comment">--netpack.pack会分配内存，write会释放内存，所以必须一个write一个包</span><br>socket.<span class="hljs-built_in">write</span>(fd_list[i], netpack.pack(msg))<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><span class="hljs-comment">--------------------------------------------------------</span><br><span class="hljs-comment">--基于skynet gate 的消息解包</span><br><span class="hljs-comment">--------------------------------------------------------</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">M.create_gate_unpack</span><span class="hljs-params">(unpack)</span></span><br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(msg,sz)</span></span><br><span class="hljs-built_in">assert</span>(msg)<br><span class="hljs-built_in">assert</span>(sz)<br><br><span class="hljs-keyword">local</span> msgstr = skynet.<span class="hljs-built_in">tostring</span>(msg,sz)<br><span class="hljs-keyword">if</span> sz &lt; <span class="hljs-number">2</span> <span class="hljs-keyword">then</span><br><span class="hljs-built_in">log</span>.info(<span class="hljs-string">&quot;unpack invalid msg &quot;</span>,msgstr,sz)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">local</span> packname,tab = <span class="hljs-built_in">unpack</span>(msgstr)<br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> packname <span class="hljs-keyword">then</span><br><span class="hljs-built_in">log</span>.<span class="hljs-built_in">error</span>(<span class="hljs-string">&quot;unpack err &quot;</span>,tab)<br><span class="hljs-keyword">return</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">return</span> packname,tab<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><span class="hljs-comment">--------------------------------------------------------</span><br><span class="hljs-comment">--通用的客户端消息接送处理</span><br><span class="hljs-comment">--------------------------------------------------------</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">M.create_recv</span><span class="hljs-params">(read,unpack)</span></span><br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(fd,dispatch)</span></span><br><span class="hljs-built_in">assert</span>(fd)<br><span class="hljs-built_in">assert</span>(dispatch)<br><br><span class="hljs-keyword">local</span> is_cancel = <span class="hljs-literal">false</span><br><span class="hljs-keyword">local</span> total_msg = <span class="hljs-string">&quot;&quot;</span><br><br><span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unpack_msg</span><span class="hljs-params">()</span></span><br><span class="hljs-keyword">local</span> sz = total_msg:<span class="hljs-built_in">len</span>()<br><span class="hljs-keyword">if</span> sz &lt; <span class="hljs-number">2</span> <span class="hljs-keyword">then</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">local</span> pack_sz = (total_msg:<span class="hljs-built_in">byte</span>(<span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-number">8</span>) + total_msg:<span class="hljs-built_in">byte</span>(<span class="hljs-number">2</span>)<br><span class="hljs-keyword">if</span> sz &lt; pack_sz + <span class="hljs-number">2</span> <span class="hljs-keyword">then</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">local</span> offset = <span class="hljs-number">2</span><br><span class="hljs-keyword">local</span> msg = total_msg:<span class="hljs-built_in">sub</span>(offset + <span class="hljs-number">1</span>,offset + pack_sz)<br>total_msg = total_msg:<span class="hljs-built_in">sub</span>(offset + <span class="hljs-number">1</span> + pack_sz)<br><span class="hljs-keyword">return</span> msg<br><span class="hljs-keyword">end</span><br><br>skynet.fork(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span><br><span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> is_cancel <span class="hljs-keyword">do</span><br><span class="hljs-keyword">local</span> ok,msg = <span class="hljs-built_in">pcall</span>(<span class="hljs-built_in">read</span>,fd)<br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> ok <span class="hljs-keyword">or</span> msg == <span class="hljs-literal">false</span> <span class="hljs-keyword">then</span><br><span class="hljs-built_in">log</span>.<span class="hljs-built_in">error</span>(<span class="hljs-string">&quot;read faild &quot;</span>,fd,msg)<br><span class="hljs-keyword">break</span><br><span class="hljs-keyword">end</span><br><br>total_msg = total_msg .. msg<br><span class="hljs-keyword">while</span> total_msg:<span class="hljs-built_in">len</span>() &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">do</span><br><span class="hljs-keyword">local</span> one_pack = unpack_msg()<br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> one_pack <span class="hljs-keyword">then</span> <span class="hljs-keyword">break</span> <span class="hljs-keyword">end</span><br>skynet.fork(dispatch,fd,<span class="hljs-built_in">unpack</span>(one_pack))<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br>socket.<span class="hljs-built_in">close</span>(fd)<br><span class="hljs-keyword">end</span>)<br><br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> <br>is_cancel = <span class="hljs-literal">true</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">--------------------------------------------------------</span><br><span class="hljs-comment">--基于skynet ws_gate 的消息发送</span><br><span class="hljs-comment">--------------------------------------------------------</span><br><span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">create_ws_gate_send</span><span class="hljs-params">(type)</span></span><br><span class="hljs-keyword">local</span> send_type = <span class="hljs-string">&#x27;send_&#x27;</span> .. <span class="hljs-built_in">type</span><br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(pack)</span></span><br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(gate,fd,name,tab)</span></span><br><span class="hljs-built_in">assert</span>(fd)<br><span class="hljs-built_in">assert</span>(name)<br><span class="hljs-built_in">assert</span>(tab)<br><br><span class="hljs-keyword">local</span> msg,err = pack(name,tab)<br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> msg <span class="hljs-keyword">then</span><br><span class="hljs-built_in">log</span>.<span class="hljs-built_in">error</span>(<span class="hljs-string">&quot;util_net_base.pack err &quot;</span>,name,tab,err)<br><span class="hljs-keyword">return</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">--大端2字节表示包长度</span><br><span class="hljs-keyword">local</span> send_buffer = <span class="hljs-built_in">string</span>.pack(<span class="hljs-string">&quot;&gt;I2&quot;</span>,msg:<span class="hljs-built_in">len</span>()) .. msg<br><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> gate <span class="hljs-keyword">then</span><br><span class="hljs-keyword">if</span> websocket.is_close(fd) <span class="hljs-keyword">then</span><br><span class="hljs-built_in">log</span>.warn(<span class="hljs-string">&quot;send not exists fd &quot;</span>,fd)<br><span class="hljs-keyword">else</span><br>websocket.<span class="hljs-built_in">write</span>(fd,send_buffer,<span class="hljs-built_in">type</span>)<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">else</span><br>skynet.send(gate,<span class="hljs-string">&#x27;lua&#x27;</span>,send_type,fd,send_buffer)<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">create_ws_gate_broadcast</span><span class="hljs-params">(type)</span></span><br><span class="hljs-keyword">local</span> send_type = <span class="hljs-string">&#x27;send_&#x27;</span> .. <span class="hljs-built_in">type</span><br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(pack)</span></span><br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(gate_list,fd_list,name,tab)</span></span><br><span class="hljs-built_in">assert</span>(gate_list <span class="hljs-keyword">and</span> #gate_list &gt; <span class="hljs-number">0</span>)<br><span class="hljs-built_in">assert</span>(fd_list <span class="hljs-keyword">and</span> #fd_list &gt; <span class="hljs-number">0</span>)<br><span class="hljs-built_in">assert</span>(name)<br><span class="hljs-built_in">assert</span>(tab)<br><br><span class="hljs-keyword">local</span> msg,err = pack(name,tab)<br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> msg <span class="hljs-keyword">then</span><br><span class="hljs-built_in">log</span>.<span class="hljs-built_in">error</span>(<span class="hljs-string">&quot;util_net_base.pack err &quot;</span>,name,tab,err)<br><span class="hljs-keyword">return</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">--大端2字节表示包长度</span><br><span class="hljs-keyword">local</span> send_buffer = <span class="hljs-built_in">string</span>.pack(<span class="hljs-string">&quot;&gt;I2&quot;</span>,msg:<span class="hljs-built_in">len</span>()) .. msg<br><br><span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span>,#fd_list <span class="hljs-keyword">do</span><br><span class="hljs-keyword">local</span> fd = fd_list[i]<br><span class="hljs-keyword">local</span> gate = gate_list[i]<br>skynet.send(gate,<span class="hljs-string">&#x27;lua&#x27;</span>,send_type,fd,send_buffer)<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br>M.create_ws_gate_send_text = create_ws_gate_send(<span class="hljs-string">&#x27;text&#x27;</span>)<br><br>M.create_ws_gate_send_binary = create_ws_gate_send(<span class="hljs-string">&#x27;binary&#x27;</span>)<br><br>M.create_ws_gate_broadcast_text = create_ws_gate_broadcast(<span class="hljs-string">&#x27;text&#x27;</span>)<br><br>M.create_ws_gate_broadcast_binary = create_ws_gate_broadcast(<span class="hljs-string">&#x27;binary&#x27;</span>)<br><br><span class="hljs-comment">--------------------------------------------------------</span><br><span class="hljs-comment">--基于skynet ws_gate 的消息解包</span><br><span class="hljs-comment">--------------------------------------------------------</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">M.create_ws_gate_unpack</span><span class="hljs-params">(unpack)</span></span><br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(msg,sz)</span></span><br><span class="hljs-built_in">assert</span>(msg)<br><span class="hljs-keyword">local</span> msgstr = skynet.<span class="hljs-built_in">tostring</span>(msg,sz)<br><span class="hljs-keyword">if</span> sz &lt; <span class="hljs-number">2</span> <span class="hljs-keyword">then</span><br><span class="hljs-built_in">log</span>.info(<span class="hljs-string">&quot;unpack invalid msg &quot;</span>,msg,sz)<br><span class="hljs-keyword">return</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">local</span> msgsz = (msgstr:<span class="hljs-built_in">byte</span>(<span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-number">8</span>) + msgstr:<span class="hljs-built_in">byte</span>(<span class="hljs-number">2</span>)<br>msgstr = msgstr:<span class="hljs-built_in">sub</span>(<span class="hljs-number">3</span>)<br>sz = msgstr:<span class="hljs-built_in">len</span>()<br><span class="hljs-keyword">if</span> msgsz ~= sz <span class="hljs-keyword">then</span><br><span class="hljs-built_in">log</span>.info(<span class="hljs-string">&quot;unpack invalid msg &quot;</span>,msgsz,sz)<br><span class="hljs-keyword">return</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">local</span> packname,tab = <span class="hljs-built_in">unpack</span>(msgstr)<br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> packname <span class="hljs-keyword">then</span><br><span class="hljs-built_in">log</span>.<span class="hljs-built_in">error</span>(<span class="hljs-string">&quot;unpack err &quot;</span>,tab)<br><span class="hljs-keyword">return</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">return</span> packname,tab<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">return</span> M<br></code></pre></td></tr></table></figure><p>由于<code>gate</code>版本的消息已经经过skynet.netpack处理，传递出来的是<strong>包体长度</strong>和<strong>包体</strong>，所以gate版本在打包解包不需要处理2字节的包体长度了。<code>ws_gate</code>需要处理。<br><code>ws_gate</code>区分了<code>text</code>消息和<code>binary</code>经过查资料，区别是text是人类可读的内容，比如json格式的数据，pb就是<code>binary</code>人类不可读的数据。<br>需要什么格式消息处理，只需要实现对于的打包解包函数即可。</p><p>例如 json pb</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> socket = <span class="hljs-built_in">require</span> <span class="hljs-string">&quot;socket&quot;</span><br><span class="hljs-keyword">local</span> json_netpack = <span class="hljs-built_in">require</span> <span class="hljs-string">&quot;json_netpack&quot;</span><br><span class="hljs-keyword">local</span> util_net_base = <span class="hljs-built_in">require</span> <span class="hljs-string">&quot;util_net_base&quot;</span><br><br><span class="hljs-comment">--------------------------------------------------------</span><br><span class="hljs-comment">--这是给skynet gate网关服务处理消息用的 基于json协议</span><br><span class="hljs-comment">--------------------------------------------------------</span><br><br><span class="hljs-keyword">local</span> M = &#123;&#125;<br><br><span class="hljs-comment">--给fd发送socket消息</span><br>M.send = util_net_base.create_gate_send(json_netpack.pack)<br><br><span class="hljs-comment">--给fd_list发送socket消息</span><br>M.broadcast = util_net_base.create_gate_broadcast(json_netpack.pack)<br><br><span class="hljs-comment">--解包</span><br>M.<span class="hljs-built_in">unpack</span> = util_net_base.create_gate_unpack(json_netpack.<span class="hljs-built_in">unpack</span>)<br><br><span class="hljs-comment">--客户端读取消息包</span><br>M.recv = util_net_base.create_recv(socket.<span class="hljs-built_in">read</span>,json_netpack.<span class="hljs-built_in">unpack</span>)<br><br><span class="hljs-keyword">return</span> M <br></code></pre></td></tr></table></figure><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> socket = <span class="hljs-built_in">require</span> <span class="hljs-string">&quot;socket&quot;</span><br><span class="hljs-keyword">local</span> pb_netpack = <span class="hljs-built_in">require</span> <span class="hljs-string">&quot;pb_netpack&quot;</span><br><span class="hljs-keyword">local</span> util_net_base = <span class="hljs-built_in">require</span> <span class="hljs-string">&quot;util_net_base&quot;</span><br><br><span class="hljs-comment">--------------------------------------------------------</span><br><span class="hljs-comment">--这是给skynet gate网关服务处理消息用的 基于protobuf协议</span><br><span class="hljs-comment">--------------------------------------------------------</span><br><br><span class="hljs-keyword">local</span> M = &#123;&#125;<br><br><span class="hljs-comment">--给fd发送socket消息</span><br>M.send = util_net_base.create_gate_send(pb_netpack.pack)<br><br><span class="hljs-comment">--给fd_list发送socket消息</span><br>M.broadcast = util_net_base.create_gate_broadcast(pb_netpack.pack)<br><br><span class="hljs-comment">--解包</span><br>M.<span class="hljs-built_in">unpack</span> = util_net_base.create_gate_unpack(pb_netpack.<span class="hljs-built_in">unpack</span>)<br><br><span class="hljs-comment">--客户端读取消息包</span><br>M.recv = util_net_base.create_recv(socket.<span class="hljs-built_in">read</span>,pb_netpack.<span class="hljs-built_in">unpack</span>)<br><br><span class="hljs-keyword">return</span> M <br></code></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>消息包这一块的代码实现还是挺清晰明了，使用者也可以基于<code>base</code>扩展出其他不同的编码解码方式。</p><h2 id="扩展实现想法"><a href="#扩展实现想法" class="headerlink" title="扩展实现想法"></a>扩展实现想法</h2><p>这一版用的packname的方式做映射，其实大多都是用消息码，然后代码里写对于映射关系。因为我一开始想着把packname打进去，pb消息能直接解析，不需要写映射关系，非常方便。<br>后续也可以实现一个消息码版本的，这种方式业务层需要多写一个对于消息码的映射，不过好处是包体更小。</p><h2 id="底层优化想法"><a href="#底层优化想法" class="headerlink" title="底层优化想法"></a>底层优化想法</h2><p>因为<code>ws_gate</code>是lua实现了，socket产生fd是<code>slave</code>节点接收管理的，所以每次发消息需要先发给slave，slave再发给客户端，这里可以想想能不能直接发。</p><p><a href="https://github.com/huahua132/skynet_fly">skynetfly源码地址</a></p>]]></content>
    
    
    <categories>
      
      <category>skynet_fly实现思路历程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>skynet_fly实现思路历程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于skynet_fly热更模块启动配置的调整</title>
    <link href="/2023/12/10/skynet_fly_ss/script/"/>
    <url>/2023/12/10/skynet_fly_ss/script/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>经过几个月的打磨使用，发现之前想的生成<code>mod_config.lua</code>热更模块配置文件用于启动的方式并不是很好。<br>    <strong>缺点</strong><br>    1. 很少需要修改里面的值，当修改掉<code>load_mods.lua</code>，需要重新生成<code>mod_config.lua</code>。<br>    2. 数组的配置重新生成也不好覆盖。<br>    3. 有些配置想一直用<code>load_mods.lua</code>中的，却要手动同步改一遍<code>mod_config.lua</code>。</p><p>一开始生成<code>mod_config.lua</code>的目的是想着配置是跟着运行环境走的，想着<code>load_mods.lua</code>只是生成一个模板，<code>mod_config.lua</code>作为实际运行的配置，现在发现有个更好的方案。</p><h1 id="调整后的方案"><a href="#调整后的方案" class="headerlink" title="调整后的方案"></a>调整后的方案</h1><p>在skynet 启动的config中增加配置项<code>loadmodsfile</code>，默认生成配置<code>load_mods</code>，就直接用代码中写好的配置，这样就没有上述1，2，3的缺点了。至于区分环境，不同的环境编写好不同的配置文件就行，只需要修改启动配置中的<code>loadmodsfile</code>文件名指向就行。</p><h1 id="script-shell脚本优化"><a href="#script-shell脚本优化" class="headerlink" title="script shell脚本优化"></a>script shell脚本优化</h1><p>一开始 script脚本中会去读skynet的启动配置文件，拿到debug_port用与法debug命令，实际使用中可能还没停服就去修改了config配置中的debug_port，导致debug命令调用不通。<br>现在 每次启动的时候会拷贝一份启动的config作为运行时配置，script console读取该配置就行。这样什么时候去更改启动的config都没有问题。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>实践出真理。<br><a href="https://github.com/huahua132/skynet_fly">skynetfly源码地址</a></p>]]></content>
    
    
    <categories>
      
      <category>skynet_fly实现思路历程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>skynet_fly实现思路历程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于skynet_fly热更新实现细节</title>
    <link href="/2023/12/03/skynet_fly_ss/reload/"/>
    <url>/2023/12/03/skynet_fly_ss/reload/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>由于几个月的时间里，断断续续发现一些问题，做了很多调整，与最初的版本已经有些许差异了，于是打算重新梳理一下热更的流程实现的细节。</p><h1 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h1><p>可以先看看这篇<a href="https://huahua132.github.io/2023/06/30/skynet_fly/%E5%85%B3%E4%BA%8Eskynet_fly%E7%83%AD%E6%9B%B4%E6%96%B0%E5%AE%9E%E7%8E%B0/">关于skynet_fly热更新实现</a></p><p>整体还是围绕<strong>容器管理员</strong>,<strong>容器客户端</strong>,<strong>可热更服务</strong>展开。</p><h1 id="职责"><a href="#职责" class="headerlink" title="职责"></a>职责</h1><ul><li><strong>容器管理员</strong> 负责<strong>启动</strong>，<strong>通知关闭</strong>，<strong>通知更新</strong></li><li><strong>容器客户端</strong> 负责<strong>注册访问</strong>，<strong>监听</strong>，<strong>服务切换</strong>，<strong>记录需要访问</strong>，<strong>回复是否需要访问</strong></li><li><strong>可热更服务</strong> 负责<strong>记录来访</strong>，<strong>检查安全退出</strong></li></ul><h2 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h2><p><strong>容器管理员</strong>查看有没有旧服务，有的话<strong>通知关闭</strong>，然后<strong>启动</strong>新服务，<strong>通知更新</strong>（监听的<strong>容器客户端</strong>）更新地址。</p><h2 id="访问流程"><a href="#访问流程" class="headerlink" title="访问流程"></a>访问流程</h2><p><strong>容器客户端</strong> 在加载代码阶段提供好注册表，在skynet.init启动阶段根据注册表启动多个监控循环进行<strong>注册访问</strong>，<strong>监听</strong>地址更新，<strong>记录需要访问</strong>的地址。访问实例直接引用本地记录地址进行消息发送，根据访问实例提供的<code>can_switch_func</code>服务切换检查来决定是否进行<strong>服务切换</strong>。<strong>记录需要访问</strong>的地址使用弱引用表记录，当没有任何访问实例引用时，说明不在需要访问该地址。当需要退出的<strong>可热更服务</strong>来询问是否需要访问它是，它就已经不在<strong>记录需要访问</strong>的表里了（<strong>回复是否需要访问</strong>）。</p><h2 id="退出流程"><a href="#退出流程" class="headerlink" title="退出流程"></a>退出流程</h2><p><strong>可热更服务</strong> 在被<strong>通知关闭</strong>后会启动一个定时轮询任务做<strong>检查安全退出</strong>的流程,检查流程分为两步，1是调用本服务的<code>check_exit</code>函数，看本服务的工作结束没有，如果结束，再看条件2询问来访者是否还需要访问自己（<strong>记录来访</strong>的目的），当全部不需要了，确认服务可以退出。</p><h1 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h1><p><img src="/img/skynet_fly/reload.png"></p><h1 id="细节展开"><a href="#细节展开" class="headerlink" title="细节展开"></a>细节展开</h1><h2 id="容器管理员"><a href="#容器管理员" class="headerlink" title="容器管理员"></a><strong>容器管理员</strong></h2><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a><strong>启动</strong></h3><p>因为热更过程中，假设A服务先热更，A服务有可能访问到旧的B服务(<a href="https://huahua132.github.io/2023/10/06/think/reload_error/">AB问题</a>)，所以<strong>容器管理员</strong>必须保证没有重入问题，我使用了skynet.queue来做保证。</p><h3 id="通知关闭"><a href="#通知关闭" class="headerlink" title="通知关闭"></a><strong>通知关闭</strong></h3><p>通知旧服务关闭我分为了<code>herald_exit</code>预告退出，<code>fix_exit</code>确认退出，<code>exit</code>退出，<code>check_exit</code>检查退出，<code>cancel_exit</code>取消退出5个回调为什么要分这么细，肯定是有原因了，一开始只有一个<code>exit</code>的回调。</p><ul><li><strong>herald_exit 预告退出</strong> 由于有些服务需要退出前做一些处理，比如我实现的web_master_m&#x2F;web_slave_m模块，web_master_m会监听一个端口，当web_master_m要热更时，旧服务需要先关闭监听端口，让新服务去监听。</li><li><strong>fix_exit 确认退出</strong> 收到这个回调这个服务就要开始执行关闭前的一些安全处理了。（要注意，确认退出了，不代表没有新的服务访问你了，可能在watch的间隙拿到你的地址或者有常驻的访问对象）</li><li><strong>cancel_exit取消退出</strong> 新服务启动失败了，比如热更web_master_m,调用start函数没有返回true,说明启动失败，这时候旧服务需要继续工作，保证健壮性。</li><li><strong>check_exit</strong> 这个是确认退出以后会轮询到exit回调为止，如果当前服务还有任务没有完成，不应该返回true，或者不实现这个回调处理。</li><li><strong>exit退出</strong> 表示已经进入退出销毁的倒计时，到这个阶段这个服务不应该还有任务（到这个阶段可以确定没有访问者了，除非你用原生的skynet.call或者send调用）。</li></ul><h3 id="通知更新"><a href="#通知更新" class="headerlink" title="通知更新"></a><strong>通知更新</strong></h3><p>watch机制能保证<strong>容器客户端</strong>一直持有最新的地址信息。</p><h2 id="容器客户端"><a href="#容器客户端" class="headerlink" title="容器客户端"></a><strong>容器客户端</strong></h2><ul><li><strong>注册访问</strong> 为了解决<a href="https://huahua132.github.io/2023/10/06/think/reload_error/">迟到访问问题</a>,访问服务之前要先注册<code>contriner_client:register</code>，确定服务启动好就知道需要访问哪些服务。比较特殊的情况是<code>cluster_server</code>集群服务，一开始并不知道需要访问哪些服务，就需要按照全部都访问的逻辑处理，但是可能存在服务不重启就新增模块的情况，就需要动态的去扩展，于是就新增了<code>monitor_new</code>监听新模块的流程，通过调用<code>contriner_client:monitor_all()</code>就可以监听所有热更服务的地址,用于解决这种情况。</li></ul><p><strong>特殊处理</strong> 因为普通的skynet服务不参与热更，所以它在什么时候注册访问可热更服务都可以，只是需要避免<strong>迟到访问问题</strong>，所有在服务启动好后就直接监听所有热更服务地址，就能很好的避免这个问题。</p><ul><li><strong>监听</strong> 通过sub&#x2F;pub机制保证一直能拿到新的地址。由于成为旧服务的时候，不能去访问新服务，此后不在更新服务地址。</li><li><strong>服务切换</strong> 服务切换由<code>new</code>生成的访问实例传入的<code>can_switch_func</code>控制，不传默认切换。使用者自己考量。</li><li><strong>记录需要访问</strong> 每次拿到服务地址都会用弱引用表记录，当该服务地址没有强引用时，弱引用也会清除。可以很方便的记录管理需要访问的服务。</li><li><strong>回复是否需要访问</strong> 判断是否在记录的访问地址中。</li></ul><h2 id="可热更服务"><a href="#可热更服务" class="headerlink" title="可热更服务"></a><strong>可热更服务</strong></h2><ul><li><strong>记录来访</strong> 每个<strong>容器客户端</strong>都会<strong>注册访问</strong>，此时记录来访地址。注册为弱访问者的不记录（用与解决出现环访问的情况，应该总有一个占主导地方），应该尽量避免出现环访问。</li><li><strong>检查安全退出</strong> 会启动一个轮询定时器，调用<code>check_exit</code>确定可以退出，再询问所有访问者是否还需要访问，直到可以退出并且没有访问者需要访问时就可以安全退出了。</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>重新梳理了一遍热更流程，目前最新的版本是最健全完善的版本。<br><a href="https://github.com/huahua132/skynet_fly">skynetfly源码地址</a></p>]]></content>
    
    
    <categories>
      
      <category>skynet_fly实现思路历程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>skynet_fly实现思路历程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于增加skynet_fly 日志服务</title>
    <link href="/2023/11/19/skynet_fly_ss/logservice/"/>
    <url>/2023/11/19/skynet_fly_ss/logservice/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在skynet_fly_demo中尝试用skynet_fly后台管理，想通过后台监控服务器的<code>历史运行状况</code>,<code>服务实时信息</code>，<code>错误日志报警</code>，等等。<code>历史运行状况</code>,<code>服务实时信息</code>这两个通过skynet的debug_console再加上我封装的集群，很方便的就做好了。之后考虑<code>错误日志报警的问题</code>,错误日志分为<code>主动打印的异常日志</code>和<code>被动触发lua断言错误</code>。</p><ol><li><strong>主动打印的异常日志</strong> 这个好解决，我封装的<code>log</code>模块提供了hook钩子函数，可以截获到日志打印。</li><li><strong>被动触发lua断言错误</strong> 由于在c层调用的<code>pcall</code>断言直接调用的skynet_error日志打印，没有经过我的自定义log模块，没办法截获。目前能想到的有两种方案。<ol><li>修改<code>lua</code>dispath消息分发的地方，再用一次pcall包裹，出错后使用<code>log</code>模块打印日志。<br> <strong>优点</strong><br> 可以使用c层的log服务，效率高一些。<br> <strong>缺点</strong><br> 截获点是发送日志消息的服务，截获点分散。</li><li>在<code>lua</code>层实现log服务，这样所有日志都可以截获处理了。<br> <strong>优点</strong><br> 截获点统一。<br> <strong>缺点</strong><br> lua效率慢一些。</li></ol></li></ol><p>由于日志报警功能通常都需要做CD，相同的异常都不会让它一直报，所以我选择第二种方案。</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> skynet = <span class="hljs-built_in">require</span> <span class="hljs-string">&quot;skynet&quot;</span><br><span class="hljs-keyword">local</span> skynet_util = <span class="hljs-built_in">require</span> <span class="hljs-string">&quot;skynet_util&quot;</span><br><span class="hljs-keyword">local</span> file_util = <span class="hljs-built_in">require</span> <span class="hljs-string">&quot;file_util&quot;</span><br><span class="hljs-keyword">local</span> time_util = <span class="hljs-built_in">require</span> <span class="hljs-string">&quot;time_util&quot;</span><br><span class="hljs-built_in">require</span> <span class="hljs-string">&quot;skynet.manager&quot;</span><br><br><span class="hljs-keyword">local</span> <span class="hljs-built_in">os</span> = <span class="hljs-built_in">os</span><br><span class="hljs-keyword">local</span> <span class="hljs-built_in">io</span> = <span class="hljs-built_in">io</span><br><span class="hljs-keyword">local</span> <span class="hljs-built_in">error</span> = <span class="hljs-built_in">error</span><br><span class="hljs-keyword">local</span> <span class="hljs-built_in">assert</span> = <span class="hljs-built_in">assert</span><br><span class="hljs-keyword">local</span> <span class="hljs-built_in">print</span> = <span class="hljs-built_in">print</span><br><span class="hljs-keyword">local</span> <span class="hljs-built_in">string</span> = <span class="hljs-built_in">string</span><br><span class="hljs-keyword">local</span> math_floor = <span class="hljs-built_in">math</span>.<span class="hljs-built_in">floor</span><br><span class="hljs-keyword">local</span> <span class="hljs-built_in">type</span> = <span class="hljs-built_in">type</span><br><span class="hljs-keyword">local</span> <span class="hljs-built_in">table</span> = <span class="hljs-built_in">table</span><br><br><span class="hljs-keyword">local</span> SELF_ADDRESS = skynet.<span class="hljs-built_in">self</span>()<br><br><span class="hljs-keyword">local</span> file = <span class="hljs-literal">nil</span><br><span class="hljs-keyword">local</span> file_path = skynet.<span class="hljs-built_in">getenv</span>(<span class="hljs-string">&#x27;logpath&#x27;</span>)<br><span class="hljs-keyword">local</span> file_name = skynet.<span class="hljs-built_in">getenv</span>(<span class="hljs-string">&#x27;logfilename&#x27;</span>)<br><span class="hljs-keyword">local</span> daemon = skynet.<span class="hljs-built_in">getenv</span>(<span class="hljs-string">&#x27;daemon&#x27;</span>)<br><span class="hljs-keyword">local</span> hook_hander_list = &#123;&#125;<br><br><span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">open_file</span><span class="hljs-params">()</span></span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> daemon <span class="hljs-keyword">then</span><br>        <span class="hljs-keyword">return</span><br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">if</span> file <span class="hljs-keyword">then</span><br>        file:<span class="hljs-built_in">close</span>()<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-built_in">print</span>(file_path,file_name)<br>    <span class="hljs-built_in">os</span>.<span class="hljs-built_in">execute</span>(<span class="hljs-string">&#x27;mkdir -p &#x27;</span> .. file_path)<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">os</span>.<span class="hljs-built_in">execute</span>(<span class="hljs-string">&quot;mkdir -p &quot;</span> .. file_path) <span class="hljs-keyword">then</span><br>        <span class="hljs-built_in">error</span>(<span class="hljs-string">&quot;create dir err&quot;</span>)<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">local</span> file_p = file_util.path_join(file_path,file_name)<br>    file = <span class="hljs-built_in">io</span>.<span class="hljs-built_in">open</span>(file_p, <span class="hljs-string">&#x27;a+&#x27;</span>)<br>    <span class="hljs-built_in">assert</span>(file, <span class="hljs-string">&quot;can`t open file &quot;</span> .. file_p)<br><span class="hljs-keyword">end</span><br><br>skynet.register_protocol &#123;<br>name = <span class="hljs-string">&quot;text&quot;</span>,<br>id = skynet.PTYPE_TEXT,<br><span class="hljs-built_in">unpack</span> = skynet.<span class="hljs-built_in">tostring</span>,<br>dispatch = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(_, address, msg)</span></span><br>        <span class="hljs-keyword">local</span> cur_time = time_util.skynet_int_time()<br>        <span class="hljs-keyword">local</span> second,m = math_floor(cur_time / <span class="hljs-number">100</span>), cur_time % <span class="hljs-number">100</span><br>        <span class="hljs-keyword">local</span> time_date = <span class="hljs-built_in">os</span>.<span class="hljs-built_in">date</span>(<span class="hljs-string">&#x27;[%Y%m%d:%H:%M:%S &#x27;</span>,second)<br>        <span class="hljs-keyword">local</span> log_str = time_date .. m .. <span class="hljs-string">&#x27;]&#x27;</span> .. msg<br>        <span class="hljs-keyword">if</span> file <span class="hljs-keyword">then</span><br>            file:<span class="hljs-built_in">write</span>(log_str .. <span class="hljs-string">&#x27;\n&#x27;</span>)<br>            file:<span class="hljs-built_in">flush</span>()<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-built_in">print</span>(log_str)<br>        <span class="hljs-keyword">end</span><br><br>        <span class="hljs-keyword">if</span> address ~= SELF_ADDRESS <span class="hljs-keyword">then</span><br>            <span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span>,#hook_hander_list <span class="hljs-keyword">do</span><br>                hook_hander_list[i](msg)<br>            <span class="hljs-keyword">end</span><br>        <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br>&#125;<br><br>skynet.register_protocol &#123;<br>name = <span class="hljs-string">&quot;SYSTEM&quot;</span>,<br>id = skynet.PTYPE_SYSTEM,<br><span class="hljs-built_in">unpack</span> = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(...)</span></span> <span class="hljs-keyword">return</span> ... <span class="hljs-keyword">end</span>,<br>dispatch = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span><br><span class="hljs-comment">-- reopen signal</span><br>        open_file()<br><span class="hljs-keyword">end</span><br>&#125;<br><br><span class="hljs-keyword">local</span> CMD = &#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CMD.add_hook</span><span class="hljs-params">(file_name)</span></span><br>    <span class="hljs-keyword">local</span> func = <span class="hljs-built_in">require</span>(file_name)<br>    <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">type</span>(func) == <span class="hljs-string">&#x27;function&#x27;</span>, <span class="hljs-string">&quot;err file &quot;</span> .. file_name)<br>    <span class="hljs-built_in">table</span>.<span class="hljs-built_in">insert</span>(hook_hander_list, func)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br><span class="hljs-keyword">end</span><br><br>skynet.start(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span><br>    open_file()<br>    skynet_util.lua_dispatch(CMD,&#123;&#125;)<br><span class="hljs-keyword">end</span>)<br></code></pre></td></tr></table></figure><p>只需要lua的log服务新增一个add_hook命令。需要截获调用命令即可。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过增加log日志服务并且提供截获处理的方式，进一步提高了skynet_fly框架的业务灵活性。</p><p><a href="https://github.com/huahua132/skynet_fly">skynetfly源码地址</a></p>]]></content>
    
    
    <categories>
      
      <category>skynet_fly实现思路历程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>skynet_fly实现思路历程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于新增定时器的扩展 整点报时</title>
    <link href="/2023/10/22/skynet_fly_ss/time_point/"/>
    <url>/2023/10/22/skynet_fly_ss/time_point/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>对于游戏来说，经常有一些跨天整点的活动，比如英雄联盟手游的峡谷之巅每天12点到0点开放。做这种功能就需要分别在每天的12点和0点触发事件调用。</p><h1 id="如何新增"><a href="#如何新增" class="headerlink" title="如何新增"></a>如何新增</h1><p>一开始想在<code>timer.lua</code>去新增一些新增一些方法，但是想保持<code>timer.lua</code>足够简单，就独立了一个文件用继承的方式来扩展。</p><h1 id="提供功能"><a href="#提供功能" class="headerlink" title="提供功能"></a>提供功能</h1><p>可以像设置闹钟一样设置。</p><ul><li>设置每分钟的哪一秒。</li><li>设置每小时几分几秒。</li><li>设置每天的几时几分几秒。</li><li>设置每周的周几几时几分几秒。</li><li>设置每月的第几天几时几分几秒。</li><li>设置每年的几月几天几时几分几秒。</li><li>设置每年的几天几时几分几秒。</li></ul><h1 id="特殊处理"><a href="#特殊处理" class="headerlink" title="特殊处理"></a>特殊处理</h1><p>当月或者当年没有该天适配到最后一天。</p><h1 id="代码设计模式"><a href="#代码设计模式" class="headerlink" title="代码设计模式"></a>代码设计模式</h1><p>因为每个类型需要设置的参数都不一样，然后参数又较多，就使用了建造者模式，这样构造代码更易读一些。</p><h1 id="调用示例"><a href="#调用示例" class="headerlink" title="调用示例"></a>调用示例</h1><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs lua"><br><span class="hljs-keyword">local</span> ti_12 = timer_point:new(timer_point.EVERY_MINUTE):set_sec(<span class="hljs-number">10</span>):builder(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span><br><span class="hljs-built_in">log</span>.<span class="hljs-built_in">error</span>(<span class="hljs-string">&quot;每分钟:&quot;</span>,<span class="hljs-built_in">os</span>.<span class="hljs-built_in">date</span>(<span class="hljs-string">&quot;%Y%m%d-%H:%M:%S&quot;</span>,time_util.<span class="hljs-built_in">time</span>()))<br><span class="hljs-keyword">end</span>)<br><br><span class="hljs-keyword">local</span> ti_13 = timer_point:new(timer_point.EVERY_HOUR):set_min(<span class="hljs-number">5</span>):set_sec(<span class="hljs-number">20</span>):builder(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span><br><span class="hljs-built_in">log</span>.<span class="hljs-built_in">error</span>(<span class="hljs-string">&quot;每小时:&quot;</span>,<span class="hljs-built_in">os</span>.<span class="hljs-built_in">date</span>(<span class="hljs-string">&quot;%Y%m%d-%H:%M:%S&quot;</span>,time_util.<span class="hljs-built_in">time</span>()))<br><span class="hljs-keyword">end</span>)<br><br><span class="hljs-keyword">local</span> ti_14 = timer_point:new(timer_point.EVERY_DAY):set_hour(<span class="hljs-number">6</span>):set_min(<span class="hljs-number">5</span>):set_sec(<span class="hljs-number">20</span>):builder(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span><br><span class="hljs-built_in">log</span>.<span class="hljs-built_in">error</span>(<span class="hljs-string">&quot;每天:&quot;</span>,<span class="hljs-built_in">os</span>.<span class="hljs-built_in">date</span>(<span class="hljs-string">&quot;%Y%m%d-%H:%M:%S&quot;</span>,time_util.<span class="hljs-built_in">time</span>()))<br><span class="hljs-keyword">end</span>)<br><br><span class="hljs-keyword">local</span> ti_15 = timer_point:new(timer_point.EVERY_WEEK):set_wday(<span class="hljs-number">1</span>):set_hour(<span class="hljs-number">6</span>):set_min(<span class="hljs-number">5</span>):set_sec(<span class="hljs-number">20</span>):builder(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span><br><span class="hljs-built_in">log</span>.<span class="hljs-built_in">error</span>(<span class="hljs-string">&quot;每周:&quot;</span>,<span class="hljs-built_in">os</span>.<span class="hljs-built_in">date</span>(<span class="hljs-string">&quot;%Y%m%d-%H:%M:%S&quot;</span>,time_util.<span class="hljs-built_in">time</span>()))<br><span class="hljs-keyword">end</span>)<br><br><span class="hljs-keyword">local</span> ti_16 = timer_point:new(timer_point.EVERY_MOUTH):set_day(<span class="hljs-number">1</span>):set_hour(<span class="hljs-number">6</span>):set_min(<span class="hljs-number">5</span>):set_sec(<span class="hljs-number">20</span>):builder(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span><br><span class="hljs-built_in">log</span>.<span class="hljs-built_in">error</span>(<span class="hljs-string">&quot;每月:&quot;</span>,<span class="hljs-built_in">os</span>.<span class="hljs-built_in">date</span>(<span class="hljs-string">&quot;%Y%m%d-%H:%M:%S&quot;</span>,time_util.<span class="hljs-built_in">time</span>()))<br><span class="hljs-keyword">end</span>)<br><br><span class="hljs-keyword">local</span> ti_17 = timer_point:new(timer_point.EVERY_YEAR):set_month(<span class="hljs-number">1</span>):set_day(<span class="hljs-number">1</span>):set_hour(<span class="hljs-number">6</span>):set_min(<span class="hljs-number">5</span>):set_sec(<span class="hljs-number">20</span>):builder(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span><br><span class="hljs-built_in">log</span>.<span class="hljs-built_in">error</span>(<span class="hljs-string">&quot;每年:&quot;</span>,<span class="hljs-built_in">os</span>.<span class="hljs-built_in">date</span>(<span class="hljs-string">&quot;%Y%m%d-%H:%M:%S&quot;</span>,time_util.<span class="hljs-built_in">time</span>()))<br><span class="hljs-keyword">end</span>)<br><br><span class="hljs-keyword">local</span> ti_18 = timer_point:new(timer_point.EVERY_YEAR_DAY):set_yday(<span class="hljs-number">1</span>):set_hour(<span class="hljs-number">6</span>):set_min(<span class="hljs-number">5</span>):set_sec(<span class="hljs-number">20</span>):builder(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span><br><span class="hljs-built_in">log</span>.<span class="hljs-built_in">error</span>(<span class="hljs-string">&quot;每年第几天:&quot;</span>,<span class="hljs-built_in">os</span>.<span class="hljs-built_in">date</span>(<span class="hljs-string">&quot;%Y%m%d-%H:%M:%S&quot;</span>,time_util.<span class="hljs-built_in">time</span>()))<br><span class="hljs-keyword">end</span>)<br></code></pre></td></tr></table></figure><h1 id="快进时间"><a href="#快进时间" class="headerlink" title="快进时间"></a>快进时间</h1><p>这种以天为单位触发的任务，不太好测试，需要增加快进时间的测试手段，修改了skynet源码并提交了requests,如果云大不合并的话，以后skynet_fly submodule指向自己的fork版本算了。</p><h1 id="快进时间修改过程"><a href="#快进时间修改过程" class="headerlink" title="快进时间修改过程"></a>快进时间修改过程</h1><p>刚开始天真的以为修改一下skynet_time.c的get_time就行了，但是仅改动get_time，增加加速时间，相当于直接从A时间跳到B时间，而A时间到B时间过程中的定时器任务可能还没有执行，时间却在加速流逝，这是因为skynet的timer线程只负责流逝时间和触发定时器任务，触发后加入到对应ctx的消息队列，由work线程消费，timer线程和work线程是同步执行的。<br>如果我们起了一个每分钟执行一次的定时任务。如果加速时间从11点到12点，完全看timer在流逝过程中，work线程的处理速度，大概率不能执行60次，所以需要把这个加速过程串行处理才行。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>skynet_fly新增定点触发的定时器，扩展定时器的功能，使得skynet_fly可以为游戏开发提供更便捷的工具。</p><p><a href="https://github.com/huahua132/skynet_fly">skynetfly源码地址</a></p>]]></content>
    
    
    <categories>
      
      <category>skynet_fly实现思路历程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>skynet_fly实现思路历程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于room_game可热更匹配房间类游戏架构的优化</title>
    <link href="/2023/10/15/skynet_fly_ss/room_game_up/"/>
    <url>/2023/10/15/skynet_fly_ss/room_game_up/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><pre><code class="hljs">在用这种架构模式实现中国象棋游戏的过程中，发现之前的设计有些诟病的地方。</code></pre><ol><li>gate和fd没必要暴露给业务层。</li><li>登录后连接大厅就行，不用强制进房间，这样能适配的业务功能更广泛，进不进房间应该由业务决定，退出房间也一样，退出不代表登出。</li><li>缺少通用的发消息接口。</li><li>消息处理函数不够优雅。</li><li>业务层缺少CMD命令注册入口。</li><li>table缺少主动访问hall大厅和alloc的接口。</li></ol><h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><pre><code class="hljs">新版本的room_game主要针对以上六点做了相关优化。</code></pre><ol><li>去掉gate,fd 对上层业务的传递，提供发消息的接口。</li><li>登录仅仅连接大厅，提供桌子的相关操作接口。</li><li>login,hall,table都提供，并且接口保持统一，通用。</li><li>消息是否转发判断逻辑为，大厅服没有注册处理，转发到桌子服，还没有桌子服，或者桌子服没有处理，视为丢弃消息打印日志即可。</li><li>提供业务注册CMD消息的入口，并限制命令不可重复注册。</li><li>提供相关接口。</li></ol><h1 id="接口介绍"><a href="#接口介绍" class="headerlink" title="接口介绍"></a>接口介绍</h1><pre><code class="hljs">架构的接口可以分为回调接口和主动调用接口。</code></pre><h2 id="回调接口"><a href="#回调接口" class="headerlink" title="回调接口"></a>回调接口</h2><pre><code class="hljs">就是模块挂载的插件需要实现的方法。</code></pre><h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><ul><li><p><code>init(interface_mgr)</code>,初始化。<br>参数：<br><code>interface_mgr</code>是主动接口入口。</p></li><li><p><code>unpack(msg,sz)</code>,解包。<br>参数：<br><code>msg</code> 网络包消息。<br><code>sz</code> 网络包长度。</p></li><li><p><code>send(gate,fd,packname,pack_body)</code>，发包函数。<br>参数：<br><code>gate</code> 网关服务id。<br><code>fd</code> 连接绑定的id。<br><code>packname</code>包名。<br><code>pack_body</code>包内容。</p></li><li><p><code>check(packname,pack_body)</code>，客户端建立连接后，第一条消息应该为登录消息，这里进行登录检查。<br>参数:<br><code>packname</code>包名。<br><code>pack_body</code>包内容。<br>返回值：<br>成功返回：<br><code>player_id</code>玩家id。<br>失败返回：<br><code>false</code><br><code>errorcode</code>失败错误码。<br><code>errormsg</code>失败消息内容。</p></li><li><p><code>login_failed(player_id,errcode,errmsg)</code>，登录失败。<br><code>player_id</code>玩家id。<br><code>errorcode</code>失败错误码。<br><code>errormsg</code>失败消息内容。</p></li></ul><p>参数传递为check失败或者hall大厅connect连接失败传递的错误码。</p><ul><li><p><code>login_succ(player_id,login_res)</code>，登录成功。<br><code>player_id</code>玩家id。<br><code>login_res</code>大厅服返回的登录结果。</p></li><li><p><code>login_out(player_id)</code>登出，玩家主动登出，或者玩家断线超时了被踢出。<br><code>player_id</code>玩家id。</p></li><li><p><code>disconnect(player_id)</code>掉线。<br><code>player_id</code>玩家id。</p></li><li><p><code>logining(player_id)</code>正在登录中，正在处理登录消息，通常客户端狂发登录消息导致。<br><code>player_id</code>玩家id。</p></li><li><p><code>repeat_login(player_id)</code>重复登录。多连接登录了，此处可以给旧连接发错误码，旧连接将被踢断开。<br><code>player_id</code>玩家id。</p></li><li><p>&#96;register_cmd</p></li><li><p>&#96; 注册命令表。</p></li></ul><h3 id="大厅"><a href="#大厅" class="headerlink" title="大厅"></a>大厅</h3><ul><li><p><code>init(interface_mgr)</code>,初始化。<br>参数：<br><code>interface_mgr</code>是主动接口入口。</p></li><li><p><code>unpack(msg,sz)</code>,解包。<br>参数：<br><code>msg</code> 网络包消息。<br><code>sz</code> 网络包长度。</p></li><li><p><code>send(gate,fd,packname,pack_body)</code>，发包函数。<br>参数：<br><code>gate</code> 网关服务id。<br><code>fd</code> 连接绑定的id。<br><code>packname</code>包名。<br><code>pack_body</code>包内容。</p></li><li><p><code>connect(player_id)</code>,连接大厅。<br>参数：<br><code>player_id</code>玩家id。</p></li></ul><p>返回值：<br>不同意连接：<br><code>false</code><br><code>errorcode</code>失败错误码。<br><code>errormsg</code>失败消息内容。<br>传递到<code>login_faild</code></p><p>同意连接：<br><code>login_res</code>连接成功内容，将传递到<code>login_succ</code></p><ul><li><p><code>disconnect(player_id)</code>，掉线。<br>参数：<br><code>player_id</code>玩家id。</p></li><li><p><code>reconnect(player_id)</code>，重连。<br>参数：<br><code>player_id</code>玩家id。<br>返回值：与connect相同即可。</p></li><li><p><code>goout(player_id)</code>，登出，也就是agent对象要被删除了。<br><code>player_id</code>玩家id。</p></li><li><p><code>register_cmd</code> 注册命令表。</p></li><li><p><code>handle_end</code> 消息处理结束。</p></li></ul><h3 id="分配"><a href="#分配" class="headerlink" title="分配"></a>分配</h3><ul><li><p><code>init(interface_mgr)</code>,初始化。<br>参数：<br><code>interface_mgr</code>是主动接口入口。</p></li><li><p><code>match(player_id)</code>，匹配。<br>参数：<br><code>player_id</code>玩家id。</p></li></ul><p>返回值：<br>匹配到：尝试进入桌子。<br><code>table_id</code><br>没有匹配到:会尝试创建新桌子。<br><code>nil</code></p><ul><li><p><code>createtable(table_name, table_id, config, create_player_id)</code>创建桌子<br>参数：<br><code>table_name</code>桌子名称，也就是mod_config参数里面填的instance_name。<br><code>table_id</code>桌子唯一id。<br><code>config</code> 桌子在mod_config中的填写的配置。<br><code>create_player_id</code>创建人，match匹配的创建人没有，表示是系统创建的。</p></li><li><p><code>entertable(table_id,player_id)</code>玩家进入桌子。<br>参数：<br><code>table_id</code>桌子唯一id。<br><code>player_id</code>玩家id。</p></li><li><p><code>leavetable(table_id,player_id)</code>离开桌子。<br>参数：<br><code>table_id</code>桌子唯一id。<br><code>player_id</code>玩家id。</p></li><li><p><code>dismisstable(table_id)</code>解散桌子，所有玩家都离开后，调用。<br>参数：<br><code>table_id</code>桌子唯一id。<br><code>player_id</code>玩家id。</p></li><li><p><code>tablefull()</code> 桌子已满，创建桌子触发<br>返回值<br><code>false</code><br><code>errorcode</code>失败错误码。<br><code>errormsg</code>失败消息内容。</p></li><li><p><code>table_not_exists()</code> 桌子不存在，进入桌子触发<br>返回值<br><code>false</code><br><code>errorcode</code>失败错误码。<br><code>errormsg</code>失败消息内容。</p></li><li><p><code>register_cmd</code> 注册命令表。</p></li></ul><h3 id="桌子"><a href="#桌子" class="headerlink" title="桌子"></a>桌子</h3><ul><li><p><code>init(interface_mgr)</code>,初始化。<br>参数：<br><code>interface_mgr</code>是主动接口入口。</p></li><li><p><code>send(gate,fd,packname,pack_body)</code>，发包函数。<br>参数：<br><code>gate</code> 网关服务id。<br><code>fd</code> 连接绑定的id。<br><code>packname</code>包名。<br><code>pack_body</code>包内容。</p></li><li><p><code>table_creator(table_id)</code>桌子创建者。<br>参数：<br><code>table_id</code>新建的table_id。</p></li></ul><p>返回值：<br>table<br>字段：<br><code>enter(player_id)</code>,进入玩家。<br>参数：<br><code>player_id</code> 玩家id。<br>返回值：<br>成功：<br><code>true</code><br>失败：<br><code>false</code><br><code>errorcode</code>失败错误码。<br><code>errormsg</code>失败消息内容。</p><p><code>leave(player_id)</code>，离开玩家。<br>参数：<br><code>player_id</code> 玩家id。<br>返回值：<br>成功：<br><code>true</code><br>失败：<br><code>false</code><br><code>errorcode</code>失败错误码。<br><code>errormsg</code>失败消息内容。</p><p><code>disconnect(player_id)</code>，玩家掉线。<br>参数：<br><code>player_id</code> 玩家id。</p><p><code>reconnect(player_id)</code>，重连。<br>参数：<br><code>player_id</code> 玩家id。</p><p><code>handle</code> 消息处理表<br>table<br>key <code>packname</code>包名<br>value <code>handle_func(player_id,packname,pack_body)</code>处理函数<br>参数：<br><code>player_id</code>玩家id。<br><code>packname</code>包名。<br><code>pack_body</code>包内容。</p><ul><li><p><code>handle_end</code> 消息处理结束。</p></li><li><p><code>register_cmd</code> 注册命令表。</p></li></ul><h2 id="主动调用接口"><a href="#主动调用接口" class="headerlink" title="主动调用接口"></a>主动调用接口</h2><h3 id="登录-1"><a href="#登录-1" class="headerlink" title="登录"></a>登录</h3><p><code>is_online(player_id)</code>是否在线。<br><code>send_msg(player_id,packname,pack_body)</code>发送消息。<br><code>send_msg_by_player_list(player_list,packname,pack_body)</code>发送消息给部分玩家。<br><code>broad_cast_msg(packname,pack_body)</code>广播发送消息。</p><h3 id="大厅-1"><a href="#大厅-1" class="headerlink" title="大厅"></a>大厅</h3><p><code>is_online(player_id)</code>是否在线。<br><code>create_join_table(player_id,table_name)</code>创建进入房间。<br><code>match_join_table(player_id,table_name)</code>匹配进入房间。<br><code>join_table(player_id,table_name,table_id)</code>进入房间。<br><code>leave_table(player_id,table_name,table_id)</code>离开桌子。<br><code>goout(player_id)</code>登出。<br><code>handle(packname,func)</code>设置消息处理函数。<br><code>send_msg(player_id,packname,pack_body)</code>发送消息。<br><code>send_msg_by_player_list(player_list,packname,pack_body)</code>发送消息给部分玩家。<br><code>broad_cast_msg(packname,pack_body)</code>广播发送消息。<br><code>get_hall_server_id()</code>获取大厅id。<br><code>get_alloc_server_id(player_id)</code>获取分配服id。<br><code>get_table_server_id(player_id)</code>获取桌子服id。<br><code>get_table_id()</code>获取桌子id。</p><h3 id="分配-1"><a href="#分配-1" class="headerlink" title="分配"></a>分配</h3><p><code>create_table(table_name)</code> 创建桌子。<br><code>dismisstable(table_id)</code> 销毁桌子。<br><code>get_empty_map()</code>获取空桌列表。</p><h3 id="桌子-1"><a href="#桌子-1" class="headerlink" title="桌子"></a>桌子</h3><p><code>new(table_id)</code>创建绑定table_id的接口对象。<br><code>kick_out_all()</code>踢出该桌子所有玩家。<br><code>kick_player(player_id)</code>踢出单个玩家。<br><code>send_msg(player_id,packname,pack_body)</code>发送消息。<br><code>send_msg_by_player_list(player_list,packname,pack_body)</code>发送消息给部分玩家。<br><code>broad_cast_msg(packname,pack_body)</code>广播发送消息。<br><code>send_hall(player_id,cmd,...)</code>用send的方式给大厅发消息。<br><code>call_hall(player_id,cmd,...)</code>用call的方式给大厅发消息。<br><code>send_alloc(cmd,...)</code>用send的方式给分配服发消息。<br><code>call_alloc(cmd,...)</code>用call的方式给分配服发消息。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过优化架构，提高了架构易用性，扩展性和使用便捷性。</p>]]></content>
    
    
    <categories>
      
      <category>skynet_fly实现思路历程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>skynet_fly实现思路历程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>skynet_fly热更新存在的问题</title>
    <link href="/2023/10/06/think/reload_error/"/>
    <url>/2023/10/06/think/reload_error/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近有空在用skynet_fly写中国象棋的游戏，发现了room_game房间类游戏基础架构有些许不够好的地方，就对room_game房间类游戏基础架构做了优化，具体优化有空会另外写一篇blog，这里主要记录一个我在优化的时候，突然想到的一个热更问题。</p><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><h2 id="触发场景分析"><a href="#触发场景分析" class="headerlink" title="触发场景分析"></a>触发场景分析</h2><p>假如有A、B 两个服务，代码如下：</p><ul><li><strong>A服务</strong></li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> contriner_client = <span class="hljs-built_in">require</span> <span class="hljs-string">&quot;contriner_client&quot;</span><br><span class="hljs-keyword">local</span> timer = <span class="hljs-built_in">require</span> <span class="hljs-string">&quot;timer&quot;</span><br><span class="hljs-keyword">local</span> <span class="hljs-built_in">log</span> = <span class="hljs-built_in">require</span> <span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-keyword">local</span> CMD = &#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CMD.start</span><span class="hljs-params">()</span></span><br>    timer:new(timer.second,<span class="hljs-number">0</span>,CMD.send_msg_to_b)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CMD.exit</span><span class="hljs-params">()</span></span><br><br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CMD.send_msg_to_b</span><span class="hljs-params">()</span></span><br>    <span class="hljs-keyword">local</span> b_client = contriner_client:new(<span class="hljs-string">&quot;B_m&quot;</span>)      <span class="hljs-comment">--用于访问B服务</span><br>    <span class="hljs-keyword">local</span> ret = b_client:mod_call(<span class="hljs-string">&quot;hello&quot;</span>)<br>    <span class="hljs-built_in">log</span>.info(<span class="hljs-string">&quot;send_msg_to_b:&quot;</span>,ret)<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">return</span> CMD<br></code></pre></td></tr></table></figure><ul><li><strong>B服务</strong></li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> CMD = &#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CMD.start</span><span class="hljs-params">()</span></span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CMD.exit</span><span class="hljs-params">()</span></span><br><br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CMD.hello</span><span class="hljs-params">()</span></span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;HEELO A&quot;</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">return</span> CMD<br></code></pre></td></tr></table></figure><p>很简单的一个示例，A服务间隔1秒给B服务发送hello消息。<br>然后我们修改代码如下：</p><ul><li><strong>A服务</strong></li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> contriner_client = <span class="hljs-built_in">require</span> <span class="hljs-string">&quot;contriner_client&quot;</span><br><span class="hljs-keyword">local</span> timer = <span class="hljs-built_in">require</span> <span class="hljs-string">&quot;timer&quot;</span><br><span class="hljs-keyword">local</span> <span class="hljs-built_in">log</span> = <span class="hljs-built_in">require</span> <span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-keyword">local</span> CMD = &#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CMD.start</span><span class="hljs-params">()</span></span><br>    timer:new(timer.second,<span class="hljs-number">0</span>,CMD.send_msg_to_b)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CMD.exit</span><span class="hljs-params">()</span></span><br><br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CMD.send_msg_to_b</span><span class="hljs-params">()</span></span><br>    <span class="hljs-comment">-- local b_client = contriner_client:new(&quot;B_m&quot;)      --用于访问B服务</span><br>    <span class="hljs-comment">-- local ret = b_client:mod_call(&quot;hello&quot;)</span><br>    <span class="hljs-comment">-- log.info(&quot;send_msg_to_b:&quot;,ret)</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">return</span> CMD<br></code></pre></td></tr></table></figure><ul><li><strong>B服务</strong></li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> CMD = &#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CMD.start</span><span class="hljs-params">()</span></span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CMD.exit</span><span class="hljs-params">()</span></span><br><br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">-- function CMD.hello()</span><br><span class="hljs-comment">--     return &quot;HEELO A&quot;</span><br><span class="hljs-comment">-- end</span><br><br><span class="hljs-keyword">return</span> CMD<br></code></pre></td></tr></table></figure><p>再执行热更，我们修改了A,B服务，我们不想让AB服务继续发送消息了，所有直接B服务直接去掉了hello命令，A服务也去掉了向B服务发送消息的代码。此时看起来没什么问题。<br>这时就会有一个问题，旧的A服务监听到了B服务更新了，此时它的消息会发送到新的B服务，那么问题就出现了。此时新的B服务hello函数并不存在。</p><h1 id="解决方案的思考"><a href="#解决方案的思考" class="headerlink" title="解决方案的思考"></a>解决方案的思考</h1><ul><li><strong>方案一</strong><br>  目前能想到的是，当一个服务是旧版本时，不能去切换访问新的服务，这种方案要保证旧服务需要联系的其他旧服务暂时都不下线。还有就是必须所有服务热更之前就要关闭掉该服务的新服务切换。</li></ul><h1 id="深入思考出现的问题"><a href="#深入思考出现的问题" class="headerlink" title="深入思考出现的问题"></a>深入思考出现的问题</h1><pre><code class="hljs">热更过程中，假设A服务先热更，A服务有可能访问到旧的B服务。也是有问题的。</code></pre><ul><li><p><strong>解决方案</strong><br>  要解决这个问题就必须保证所有服务热更完之前，对服务id的查询暂时先阻塞。<br>  解决方案是contriner_mgr的所有cmd命令用queue队列包裹起来，这样load启动完所有需要加载的热更模块之前所有query都得先排队，不过这样需要去避免<strong>环队列问题</strong>，load和start过程中不能有服务去调用query。所以在start完之前，需要把contriner_client:new命令暂时禁用掉。<br>  如果是非可热更模块服务就没有这个限制。</p></li><li><p><strong>环队列问题</strong><br>  假设队列里面有A,B两个函数，队列执行顺序为 <code>B&gt;A&gt;</code>,也就是先执行A，再执行B。<br>  前提是<strong>B</strong>的函数执行是因为<strong>A</strong>函数的call调用发起的。<br>  此时就会出现<strong>A</strong>在等<strong>B</strong>的回应，<strong>B</strong>在等<strong>A</strong>先跑完。</p></li></ul><p>做了上诉解决方案的修改后，解决了新旧版本串调的问题，此时又多了一个问题。</p><h1 id="旧服务何时销毁退出"><a href="#旧服务何时销毁退出" class="headerlink" title="旧服务何时销毁退出"></a>旧服务何时销毁退出</h1><p>之前旧服务被新服务顶替之后，就可以确定自己不再会新的访问者了，现在是可能存在访问者，不能再像之前一样只需要判断自己还有没有需要处理的数据。</p><ul><li><p><strong>解决方案</strong><br>  记录来访者地址，检查是否可以退出时，询问来访者是否不需要访问自己了或者已经退出了，当所有来访者都退出了，说明此服务可以退出了。这种处理方式有<strong>环问题</strong>。</p></li><li><p><strong>边界问题</strong></p><ol><li>当旧服务可以退出时，会不会出现全新的来访者。<br> 除非手动指定id去调用，不然不会出现全新的访问者。新的query查询都会查到新服务，想到这里又想到一个要退出的旧服务可能访问新服务的问题，<strong>迟到访问问题</strong>。</li></ol></li></ul><h1 id="迟到访问问题"><a href="#迟到访问问题" class="headerlink" title="迟到访问问题"></a>迟到访问问题</h1><pre><code class="hljs">热更之前A服务没有访问过B服务，就是还没有查询过B服务的地址，热更结束之后，旧A服务想访问B了，此时又会查询到新服务。</code></pre><ul><li><p><strong>解决方案</strong><br>  只要用到contriner_client的任何服务，都需要先先注册好需要访问的服务，没有注册的不能访问。</p></li><li><p><strong>环问题</strong><br>  A访问B，B访问A，都退出不了。<br>  引入弱访问者，AB互相联系，应该有一个占主导地位的发起方。主导发起方不用管被访问者是否退出。</p></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><pre><code class="hljs">此次发现并解决了热更可能存在的诸多问题。</code></pre>]]></content>
    
    
    <categories>
      
      <category>一些想法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>一些想法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于增加skynet_fly 日志分割模块</title>
    <link href="/2023/09/10/skynet_fly_ss/logrotate/"/>
    <url>/2023/09/10/skynet_fly_ss/logrotate/</url>
    
    <content type="html"><![CDATA[<h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>通过群友对skynet_fly的使用测试，发现使用系统日志分割系统会有两个问题。</p><ol><li><strong>软件问题</strong> 可能有些系统并不会默认装载logrotate分割软件。</li><li><strong>权限问题</strong> 非root用户可能无法在<code>/etc/logrotate.d/</code>新增文件。</li></ol><p>就此埋下了我想实现一个内置日志分割模块的决心。</p><h1 id="项目修改"><a href="#项目修改" class="headerlink" title="项目修改"></a>项目修改</h1><ol><li>修改原来的<code>run.sh</code>不再启动即配置日志分割。</li><li>把使用系统日志分割变成一个可选项，增加了<code>create_logrotate.sh</code>，可以主动调用配置。</li><li>内置新增<code>log_rotate_m.lua</code>日志分割模块。</li></ol><h1 id="提供功能"><a href="#提供功能" class="headerlink" title="提供功能"></a>提供功能</h1><p>我没有去增加太多的配置项，我是按照我个人使用日志分割的场景来做的，后续如果有优秀建议，也可修改。</p><p>主要提供了两个功能，<strong>切割</strong>，<strong>保留历史日志文件整理</strong>。</p><ul><li><strong>切割</strong> 我目前写死了<strong>每天凌晨</strong>进行切割和整理，还做了文件至少多大才切割。</li><li><strong>保留历史日志文件整理</strong> 提供了保留多少天内，和保留多少个文件的配置。</li></ul><h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><p>到点重命名日志文件，通过hup消息通知<code>skynet</code>日志服务重新打开日志文件，这种方式不会丢失日志，也不会占用内存。</p><h1 id="配置项说明"><a href="#配置项说明" class="headerlink" title="配置项说明"></a>配置项说明</h1><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">return</span> &#123;<br>    logrotate_m = &#123;<br>        launch_seq = <span class="hljs-number">1</span>,<br>        launch_num = <span class="hljs-number">1</span>,<br>        default_arg = &#123;<br>            file_path = <span class="hljs-string">&#x27;./&#x27;</span>,          <span class="hljs-comment">--文件路径</span><br>            filename = <span class="hljs-string">&#x27;server.log&#x27;</span>,   <span class="hljs-comment">--文件名</span><br>            limit_size = <span class="hljs-number">0</span>,            <span class="hljs-comment">--最小分割大小</span><br>            max_age = <span class="hljs-number">7</span>,               <span class="hljs-comment">--最大保留天数</span><br>            max_backups = <span class="hljs-number">7</span>,           <span class="hljs-comment">--最大保留文件数</span><br>            sys_cmd = <span class="hljs-string">[[</span><br><span class="hljs-string">                /usr/bin/pkill -HUP -f skynet.logrotate_config.lua\n</span><br><span class="hljs-string">            ]]</span>,              <span class="hljs-comment">--系统命令</span><br>        &#125;<br>    &#125;,<br><br>    test_m = &#123;<br>        launch_seq = <span class="hljs-number">2</span>,<br>        launch_num = <span class="hljs-number">1</span>,<br>    &#125;,<br>&#125;<br></code></pre></td></tr></table></figure><p>sys_cmd就是调用系统命令给skynet发送HUP信号，skynet logger服务收到HUP信号就会重新打开日志文件。</p><h1 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h1><p><a href="https://github.com/huahua132/skynet_fly/tree/master/examples/logrotate">examples&#x2F;logrotate</a></p><h1 id="模块实现路径"><a href="#模块实现路径" class="headerlink" title="模块实现路径"></a>模块实现路径</h1><p><a href="https://github.com/huahua132/skynet_fly/blob/master/lualib/module/logrotate_m.lua">lualib&#x2F;module&#x2F;logrotate_m.lua</a></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>增加skynet_fly内置日志分割，为skynet_fly扩展了可选使用功能。<br><a href="https://github.com/huahua132/skynet_fly">skynetfly源码地址</a></p>]]></content>
    
    
    <categories>
      
      <category>skynet_fly实现思路历程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>skynet_fly实现思路历程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>blog编写环境搭建</title>
    <link href="/2023/09/03/record/blog/"/>
    <url>/2023/09/03/record/blog/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>偶然可能换电脑了，需要重新搭建起编写blog的环境。</p><h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><ol><li>安装git,拉取blog工程。</li><li>设置git环境。      <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">git config --global user.name &quot;你的GitHub用户名&quot;<br>git config --global user.email &quot;你的GitHub注册邮箱&quot;<br>ssh-keygen -t rsa -C &quot;你的GitHub注册邮箱&quot;<br></code></pre></td></tr></table></figure></li><li>配置ssh密钥。</li><li>安装nodejs <a href="https://link.zhihu.com/?target=https://nodejs.org/en/download/">https://link.zhihu.com/?target=https%3A//nodejs.org/en/download/</a></li><li>npm install -g hexo-cli</li><li>到工程根目录测试hexo 命令</li></ol><h1 id="hexo-命令"><a href="#hexo-命令" class="headerlink" title="hexo 命令"></a>hexo 命令</h1><ul><li>hexo clean 清理构建</li><li>hexo g 构建</li><li>hexo s 发布本地服务</li><li>hexo d 发布到github</li></ul>]]></content>
    
    
    <categories>
      
      <category>notebook</category>
      
    </categories>
    
    
    <tags>
      
      <tag>notebook</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于增加skynet_fly lua服务启动的后置加载</title>
    <link href="/2023/08/20/skynet_fly_ss/after_load/"/>
    <url>/2023/08/20/skynet_fly_ss/after_load/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>skynet lua服务默认启动加载是使用<code>skynet/lualib/loader.lua</code>，<code>loader.lua</code> 会加载并执行<code>config</code>中配置的preload路径的lua文件，这个操作的好处是可以把所有服务的一些前置环境操作，或者一些常用工具函数写到全局变量中(我更倾向于封装成工具模块通过<code>require</code>引用，不去污染全局环境，尽量保持原生环境)。在skynet_fly框架中，我就利用preload做了<code>luapath</code>的设置来达到不用手写path的目的。在这之前我都没有想改动<code>preload</code>的想法，直到有一天，我萌生了想给<code>skynet_fly</code>日志增加钩子函数的想法，因为在工作中也在严重日志中增加了邮件推送，不过是直接修改的日志服务，不满足开闭原则，不够优雅。</p><h2 id="增加日志钩子函数"><a href="#增加日志钩子函数" class="headerlink" title="增加日志钩子函数"></a>增加日志钩子函数</h2><p>那么如何给日志服务增加钩子函数又满足开闭原则呢？，我目前能想到的，有两种方案。</p><h3 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h3><p>在log服务中实现钩子函数。<br>业务层弃用<strong>skynet logger原生日志服务</strong>，改用<strong>lua自定义日志服务</strong>并在logger服务启动后利用消息的方式通知logger服务需要加载哪些钩子函数文件实现。</p><ul><li><p><strong>优势</strong></p><ol><li>钩子函数由日志服务执行，业务逻辑不用处理，不影响业务服务吞吐量。</li></ol></li><li><p><strong>劣势</strong></p><ol><li>用lua写日志服务性能远远低于c层的日志服务，c比lua快10倍。</li><li>skynet原生大量代码依赖原生日志服务，如果自定义要么保留原生日志，要么修改大量源码。</li><li>想要利用signal_hup信号来切割日志也需要修改源码。</li></ol></li></ul><h3 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h3><p>在log模块中实现钩子函数。<br>log模块中简单的调用增加钩子函数的API,在<strong>preload</strong>中设置钩子函数，这样每个启动lua服务都挂上钩子函数。</p><ul><li><p><strong>优势</strong></p><ol><li>最小改动。</li></ol></li><li><p><strong>劣势</strong></p><ol><li>增加了业务层log的调用开销。</li></ol></li></ul><p>通过对比两种<strong>方案</strong>，我选用了方案二，原因如下：<br>    1. 尽量保持skynet源码不改动。<br>    2. c实现的日志服务速度更快。</p><h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><p>在使用preload去加载钩子函数的时候，想到这个是偏业务的实现，并不是所有项目都要在log日志外挂一个钩子函数，也可能每个项目钩子函数实现不同，这时候有人可能会想到，skynet中的preload不是可以配置的吗，但是我想大部分项目都依赖一个preload文件，突然有一个项目不同，岂不是要拷贝一份再新增不同，或者全部堆叠在一个文件中，我觉得这是很糟糕的设计。不满足开闭原则，本身skynet_fly项目就需要依赖框架的preload.lua文件，当然有个解决方案就是在自定义的preload中再次load preload.lua，手动链式依赖。但是我不想这样设计，我希望我用代码生成config能不手改就不手改，况且这个还是路径，手写挺麻烦的。解决这个问题很简单，把前置加载单个文件，改为前置加载多个文件，skynet_fly默认加载框架的<code>preload.lua</code>，其他项目需要额外加载只需要在main.lua中显示增加。这里又想到了preload有个不好的地方，preload中<code>require</code>的文件是不能热更的，应该在这之前还没有调用<code>skynet.codecache off</code>。所以就想着增加<code>afterload</code>,afterload是lua服务最后加载的，如果是可热更模块已经执行了<code>skynet.codecache off</code>。</p><h1 id="使用注意点"><a href="#使用注意点" class="headerlink" title="使用注意点"></a>使用注意点</h1><p>加载顺序是preload-main-afterload<br>可想而知afterload执行代码，不可能在main<code>require</code>期间生效。</p><h1 id="改动"><a href="#改动" class="headerlink" title="改动"></a>改动</h1><p>后续发现在loader中就关闭cache，这样preload中的require也能检测热更了。</p><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><pre><code class="hljs">skynet_fly/examples/log_hookskynet_fly/examples/pre_after_load</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>修改了preload和afterload能让skynet_fly在微服务多项目架构增加更多的灵活性和扩展性。<br><a href="https://github.com/huahua132/skynet_fly">skynetfly源码地址</a></p>]]></content>
    
    
    <categories>
      
      <category>skynet_fly实现思路历程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>skynet_fly实现思路历程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux系统常用命令记录</title>
    <link href="/2023/08/12/record/linux/"/>
    <url>/2023/08/12/record/linux/</url>
    
    <content type="html"><![CDATA[<h1 id="gdb调试"><a href="#gdb调试" class="headerlink" title="gdb调试"></a>gdb调试</h1><h2 id="打开core文件"><a href="#打开core文件" class="headerlink" title="打开core文件"></a>打开core文件</h2><p><code>gdb filename core</code></p><h2 id="查看错误堆栈"><a href="#查看错误堆栈" class="headerlink" title="查看错误堆栈"></a>查看错误堆栈</h2><p><code>bt</code></p><h1 id="centos-gcc版本升级"><a href="#centos-gcc版本升级" class="headerlink" title="centos gcc版本升级"></a>centos gcc版本升级</h1><p><code>sudo yum install centos-release-scl</code><br><code>sudo yum install devtoolset-9-gcc*</code><br><code>scl enable devtoolset-9 bash</code></p><h1 id="如何使用systemd运行程序"><a href="#如何使用systemd运行程序" class="headerlink" title="如何使用systemd运行程序"></a>如何使用systemd运行程序</h1><p><code>cd /etc/systemd/system</code><br><code>vim myapp.service</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sh">[Unit]<br>Description=myapp<br>After=network.target<br><br>[Service]<br>Type=simple<br>ExecStart=/path/to/myapp arg1 arg2<br><br>[Install]<br>WantedBy=multi-user.target<br></code></pre></td></tr></table></figure><p><code>systemctl start myapp</code></p><p>##好处</p><ul><li>守护进程运行</li><li>可以写好启动配置，方便后续启动</li></ul>]]></content>
    
    
    <categories>
      
      <category>notebook</category>
      
    </categories>
    
    
    <tags>
      
      <tag>notebook</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux不产生core原因</title>
    <link href="/2023/07/28/record/record/"/>
    <url>/2023/07/28/record/record/</url>
    
    <content type="html"><![CDATA[<ol><li>首先可能ulimit限制了。<br><code>ulimit -a</code></li></ol><p>如果core 限制大小为0，需要修改。<br>调用命令<br><code>ulimit -c unlimited</code></p><ol start="2"><li>考虑产生位置问题<br>查看 <code>/proc/sys/kernel/core_pattern</code>文件内容。<br>如果文件内容不是core，通知命令<br><code>sudo bash -c &quot;echo core &gt; /proc/sys/kernel/core_pattern&quot;</code>修改</li></ol>]]></content>
    
    
    <categories>
      
      <category>record</category>
      
    </categories>
    
    
    <tags>
      
      <tag>record</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于cluster 远程rpc调用</title>
    <link href="/2023/07/28/skynet_fly_ss/cluster_rpc/"/>
    <url>/2023/07/28/skynet_fly_ss/cluster_rpc/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>cluster 远程rpc是依赖<a href="https://blog.codingnow.com/2017/03/skynet_cluster.html">skynet的cluster模式</a>实现的。<br>    skynet_fly远程rpc调用的实现注重什么：<br>    * 与热更模板系统完美融合。<br>    * 简单易用的API设计。<br>    * 支持多结点。<br>    * 支持服务发现。</p><h1 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h1><p>因为远程rpc调用结点偶尔下线，上线都是常有的事，所以不建议用来做强生效性消息(就是调用了，一定要执行成功)。<br>skynet_fly cluster rpc 默认启用<code>__nowaiting</code>就是结点连不上也不会等待，rpc远程调用适合做查询，弱通知。</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>基于skynet cluster mode 模式，扩展了<code>cluster_sever</code>,<code>cluster_client_m</code>,<code>cluster_client</code>3个文件。<br><img src="/img/skynet_fly/cluster_rpc.png"></p><ul><li><p><code>cluster_sever.lua</code><br>它是一个skynet服务。<br><strong>负责</strong></p><ol><li>cluster rpc服务开启监听。</li><li>后续服务发现机制的服务注册。</li><li>担任rpc调用入口服务。</li></ol></li><li><p><code>cluster_client_m.lua</code><br>它是一个skynet_fly可热更模块。<br><strong>负责</strong></p><ol><li>cluster 服务配置加载。</li><li>后续cluster服务发现。</li><li>担任远程rpc调用代理。</li><li>对接cluster_server消息。</li></ol></li><li><p><code>cluster_client.lua</code><br>它是一个lua模块。<br><strong>负责</strong></p><ol><li>封装简化远程rpc调用。</li><li>保持内部rpc调用相同的调用方法。</li></ol></li></ul><h1 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h1><p>examples&#x2F;cluster_server_1<br>examples&#x2F;cluster_server_2<br>examples&#x2F;cluster_client</p><p>cluster_server_1和cluster_server_2代码一样，监听端口配置不同，为了模拟相同服务配置在2台机器上。<br><strong>启动步骤</strong></p><p>cluster_server_1</p><ol><li>构建 <code>sh ../../binshell/make_server.sh ../../</code></li><li>修改配置，打开<code>cluster_server_1_config.lua</code>文件，修改svr_name&#x3D;cluster_server</li><li>启动script&#x2F;run.sh</li></ol><p>cluster_server_2</p><ol><li>构建 <code>sh ../../binshell/make_server.sh ../../</code></li><li>修改配置，打开<code>cluster_server_1_config.lua</code>文件，修改svr_name&#x3D;cluster_server，修改svr_id &#x3D; 2,修改debug_port改为没有被使用的端口。</li><li>启动script&#x2F;run.sh</li></ol><p>cluster_client</p><ol><li>构建 <code>sh ../../binshell/make_server.sh ../../</code></li><li>修改配置，打开<code>cluster_server_1_config.lua</code>文件，修改debug_port改为没有被使用的端口。</li><li>启动script&#x2F;run.sh</li></ol><ul><li>服务端</li></ul><p>main.lua</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> skynet = <span class="hljs-built_in">require</span> <span class="hljs-string">&quot;skynet&quot;</span><br><span class="hljs-keyword">local</span> contriner_launcher = <span class="hljs-built_in">require</span> <span class="hljs-string">&quot;contriner_launcher&quot;</span><br><br>skynet.start(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span><br>skynet.<span class="hljs-built_in">error</span>(<span class="hljs-string">&quot;start cluster_server!!!&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;</span>)<br>contriner_launcher.run()<br><br>skynet.uniqueservice(<span class="hljs-string">&quot;cluster_server&quot;</span>)<br>skynet.<span class="hljs-built_in">exit</span>()<br><span class="hljs-keyword">end</span>)<br></code></pre></td></tr></table></figure><p>load_mods.lua</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">return</span> &#123;<br><span class="hljs-comment">--共享配置</span><br>share_config_m = &#123;<br>launch_seq = <span class="hljs-number">1</span>,<br>launch_num = <span class="hljs-number">1</span>,<br>default_arg = &#123;<br><span class="hljs-comment">--cluster_server用的配置</span><br>cluster_server = &#123;<br>host = <span class="hljs-string">&quot;127.0.0.1:9688&quot;</span>,  <span class="hljs-comment">--rpc监听端口</span><br>&#125;<br>&#125;<br>&#125;,<br><br>test_m = &#123;<br>launch_seq = <span class="hljs-number">2</span>,<br>launch_num = <span class="hljs-number">6</span>,<br>mod_args = &#123;<br>&#123;instance_name = <span class="hljs-string">&quot;test_one&quot;</span>&#125;,<br>&#123;instance_name = <span class="hljs-string">&quot;test_one&quot;</span>&#125;,<br>&#123;instance_name = <span class="hljs-string">&quot;test_one&quot;</span>&#125;,<br>&#123;instance_name = <span class="hljs-string">&quot;test_two&quot;</span>&#125;,<br>&#123;instance_name = <span class="hljs-string">&quot;test_two&quot;</span>&#125;,<br>&#123;instance_name = <span class="hljs-string">&quot;test_two&quot;</span>&#125;,<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>test_m.lua</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> <span class="hljs-built_in">log</span> = <span class="hljs-built_in">require</span> <span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-keyword">local</span> skynet = <span class="hljs-built_in">require</span> <span class="hljs-string">&quot;skynet&quot;</span><br><span class="hljs-keyword">local</span> contriner_client = <span class="hljs-built_in">require</span> <span class="hljs-string">&quot;contriner_client&quot;</span><br><br>contriner_client:register(<span class="hljs-string">&quot;share_config_m&quot;</span>)<br><span class="hljs-keyword">local</span> <span class="hljs-built_in">string</span> = <span class="hljs-built_in">string</span><br><br><span class="hljs-keyword">local</span> g_config = <span class="hljs-literal">nil</span><br><br><span class="hljs-keyword">local</span> CMD = &#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CMD.hello</span><span class="hljs-params">(who)</span></span><br><span class="hljs-built_in">log</span>.info(<span class="hljs-built_in">string</span>.<span class="hljs-built_in">format</span>(<span class="hljs-string">&quot;%s send hello msg for me&quot;</span>,who))<br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CMD.ping</span><span class="hljs-params">()</span></span><br><span class="hljs-keyword">local</span> confclient = contriner_client:new(<span class="hljs-string">&quot;share_config_m&quot;</span>)<br><span class="hljs-keyword">local</span> conf = confclient:mod_call(<span class="hljs-string">&#x27;query&#x27;</span>,<span class="hljs-string">&#x27;cluster_server&#x27;</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">string</span>.<span class="hljs-built_in">format</span>(<span class="hljs-string">&quot;pong %s %s %s&quot;</span>,g_config.instance_name,conf.host,skynet.<span class="hljs-built_in">self</span>())<br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CMD.start</span><span class="hljs-params">(config)</span></span><br>g_config = <span class="hljs-built_in">config</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CMD.exit</span><span class="hljs-params">()</span></span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">return</span> CMD<br></code></pre></td></tr></table></figure><ul><li>客户端</li></ul><p>main.lua</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> skynet = <span class="hljs-built_in">require</span> <span class="hljs-string">&quot;skynet&quot;</span><br><span class="hljs-keyword">local</span> contriner_launcher = <span class="hljs-built_in">require</span> <span class="hljs-string">&quot;contriner_launcher&quot;</span><br><br>skynet.start(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span><br>skynet.<span class="hljs-built_in">error</span>(<span class="hljs-string">&quot;start cluster_client!!!&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;</span>)<br>contriner_launcher.run()<br>skynet.<span class="hljs-built_in">exit</span>()<br><span class="hljs-keyword">end</span>)<br></code></pre></td></tr></table></figure><p>load_mods.lua</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">return</span> &#123;<br>cluster_client_m = &#123;<br>launch_seq = <span class="hljs-number">1</span>,<br>launch_num = <span class="hljs-number">1</span>,<br>default_arg = &#123;<br>node_map = &#123;<br>[<span class="hljs-string">&#x27;cluster_server&#x27;</span>] = &#123;<br>[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;127.0.0.1:9688&quot;</span>,<br>[<span class="hljs-number">2</span>] = <span class="hljs-string">&quot;127.0.0.1:9689&quot;</span>,<br>&#125;<br>&#125;<br>&#125;<br>&#125;,<br><br>test_m = &#123;<br>launch_seq = <span class="hljs-number">2</span>,<br>launch_num = <span class="hljs-number">1</span>,<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>test_m</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> skynet = <span class="hljs-built_in">require</span> <span class="hljs-string">&quot;skynet&quot;</span><br><span class="hljs-keyword">local</span> <span class="hljs-built_in">log</span> = <span class="hljs-built_in">require</span> <span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-keyword">local</span> cluster_client = <span class="hljs-built_in">require</span> <span class="hljs-string">&quot;cluster_client&quot;</span><br><span class="hljs-keyword">local</span> CMD = &#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CMD.start</span><span class="hljs-params">()</span></span><br>skynet.fork(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span><br><span class="hljs-keyword">local</span> cli = cluster_client:new(<span class="hljs-string">&quot;cluster_server&quot;</span>,<span class="hljs-string">&quot;test_m&quot;</span>) <span class="hljs-comment">--访问cluster_server的test_m模板</span><br><br>cli:one_balance_send(<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-string">&quot;one_balance_send&quot;</span>)<br>cli:one_mod_send(<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-string">&quot;one_mod_send&quot;</span>)<br>cli:set_svr_id(<span class="hljs-number">1</span>):byid_balance_send(<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-string">&quot;byid_balance_send&quot;</span>)<br>cli:set_svr_id(<span class="hljs-number">1</span>):byid_mod_send(<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-string">&quot;byid_mod_send&quot;</span>)<br><br><span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span>,<span class="hljs-number">3</span> <span class="hljs-keyword">do</span><br><span class="hljs-built_in">log</span>.info(<span class="hljs-string">&quot;balance ping &quot;</span>,i,cli:one_balance_call(<span class="hljs-string">&quot;ping&quot;</span>))<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span>,<span class="hljs-number">3</span> <span class="hljs-keyword">do</span><br><span class="hljs-built_in">log</span>.info(<span class="hljs-string">&quot;mod ping &quot;</span>,i,cli:one_mod_call(<span class="hljs-string">&quot;ping&quot;</span>))<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span>,<span class="hljs-number">3</span> <span class="hljs-keyword">do</span><br><span class="hljs-built_in">log</span>.info(<span class="hljs-string">&quot;byid ping &quot;</span>,i,cli:set_svr_id(<span class="hljs-number">2</span>):byid_balance_call(<span class="hljs-string">&quot;ping&quot;</span>))<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span>,<span class="hljs-number">3</span> <span class="hljs-keyword">do</span><br><span class="hljs-built_in">log</span>.info(<span class="hljs-string">&quot;byid ping &quot;</span>,i,cli:set_svr_id(<span class="hljs-number">1</span>):byid_mod_call(<span class="hljs-string">&quot;ping&quot;</span>))<br><span class="hljs-keyword">end</span><br><br>cli:all_mod_send(<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-string">&quot;all_mod_send&quot;</span>)<br><span class="hljs-keyword">local</span> ret = cli:all_mod_call(<span class="hljs-string">&quot;ping&quot;</span>)<br><span class="hljs-built_in">log</span>.info(<span class="hljs-string">&quot;all_mod_call: &quot;</span>,ret)<br><br>cli:all_balance_send(<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-string">&quot;all_balance_send&quot;</span>)<br><span class="hljs-keyword">local</span> ret = cli:all_balance_call(<span class="hljs-string">&quot;ping&quot;</span>)<br><span class="hljs-built_in">log</span>.info(<span class="hljs-string">&quot;all_balance_call: &quot;</span>,ret)<br><br>cli:one_broadcast(<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-string">&quot;one_broadcast&quot;</span>)<br>cli:all_broadcast(<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-string">&quot;all_broadcast&quot;</span>)<br>cli:set_svr_id(<span class="hljs-number">1</span>):byid_broadcast(<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-string">&quot;byid_broadcast&quot;</span>)<br><br>cli:set_instance_name(<span class="hljs-string">&quot;test_one&quot;</span>)<br>cli:set_svr_id(<span class="hljs-number">2</span>)<br>cli:one_balance_send_by_name(<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-string">&quot;one_balance_send_by_name&quot;</span>)<br>cli:one_mod_send_by_name(<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-string">&quot;one_mod_send_by_name&quot;</span>)<br>cli:byid_balance_send_by_name(<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-string">&quot;byid_balance_send_by_name&quot;</span>)<br>cli:byid_mod_send_by_name(<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-string">&quot;byid_mod_send_by_name&quot;</span>)<br><br><span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span>,<span class="hljs-number">3</span> <span class="hljs-keyword">do</span><br><span class="hljs-built_in">log</span>.info(<span class="hljs-string">&quot;one_balance_call_by_name ping &quot;</span>,i,cli:one_balance_call_by_name(<span class="hljs-string">&quot;ping&quot;</span>))<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span>,<span class="hljs-number">3</span> <span class="hljs-keyword">do</span><br><span class="hljs-built_in">log</span>.info(<span class="hljs-string">&quot;one_mod_call_by_name ping &quot;</span>,i,cli:one_mod_call_by_name(<span class="hljs-string">&quot;ping&quot;</span>))<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span>,<span class="hljs-number">3</span> <span class="hljs-keyword">do</span><br><span class="hljs-built_in">log</span>.info(<span class="hljs-string">&quot;byid_balance_call_by_name ping &quot;</span>,i,cli:byid_balance_call_by_name(<span class="hljs-string">&quot;ping&quot;</span>))<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span>,<span class="hljs-number">3</span> <span class="hljs-keyword">do</span><br><span class="hljs-built_in">log</span>.info(<span class="hljs-string">&quot;byid_mod_call_by_name ping &quot;</span>,i,cli:byid_mod_call_by_name(<span class="hljs-string">&quot;ping&quot;</span>))<br><span class="hljs-keyword">end</span><br><br>cli:all_mod_send_by_name(<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-string">&quot;all_mod_send_by_name&quot;</span>)<br><span class="hljs-keyword">local</span> ret = cli:all_mod_call_by_name(<span class="hljs-string">&quot;ping&quot;</span>)<br><span class="hljs-built_in">log</span>.info(<span class="hljs-string">&quot;all_mod_call_by_name: &quot;</span>,ret)<br><br>cli:all_balance_send_by_name(<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-string">&quot;all_balance_send_by_name&quot;</span>)<br><span class="hljs-keyword">local</span> ret = cli:all_balance_call_by_name(<span class="hljs-string">&quot;ping&quot;</span>)<br><span class="hljs-built_in">log</span>.info(<span class="hljs-string">&quot;all_balance_call_by_name: &quot;</span>,ret)<br><br>cli:one_broadcast_by_name(<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-string">&quot;one_broadcast_by_name&quot;</span>)<br>cli:all_broadcast_by_name(<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-string">&quot;all_broadcast_by_name&quot;</span>)<br>cli:byid_broadcast_by_name(<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-string">&quot;byid_broadcast_by_name&quot;</span>)<br><span class="hljs-keyword">end</span>)<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CMD.exit</span><span class="hljs-params">()</span></span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">return</span> CMD<br></code></pre></td></tr></table></figure><h1 id="基于redis做的服务发现对比etcd如何"><a href="#基于redis做的服务发现对比etcd如何" class="headerlink" title="基于redis做的服务发现对比etcd如何"></a>基于redis做的服务发现对比etcd如何</h1><p>通常都是基于etcd做服务发现，etcd 之所以适合用于服务发现,主要有以下几个原因:</p><ol><li><p>支持服务的自动注册和发现<br>etcd允许服务在启动时主动向etcd注册自己提供的服务,而客户端可以通过监听服务变更事件来发现可用的服务实例。这样就无需人工记录服务地址。</p></li><li><p>支持服务健康检查<br>etcd支持对保存的服务进行定期心跳检测,一旦服务失效就可以将其服务地址从注册表中删除或标记为不可用。</p></li><li><p>服务信息更新的事件通知<br>etcd支持watch机制,服务信息有变更时,可立即通知注册的客户端。这样客户端可以快速响应服务的变化。</p></li><li><p>简单灵活的HTTP API<br>etcd提供HTTP RESTful API用于读写服务注册表,使用简单且多语言都可以轻松访问。</p></li><li><p>服务注册表数据持久化<br>etcd会将服务注册表数据持久保存,这样即使etcd节点重启,注册表数据也不会丢失。</p></li><li><p>支持服务负载均衡<br>可以在etcd中保存服务的额外元数据,如服务的负载信息,用于实现服务负载均衡。</p></li></ol><p>综上,etcd作为一个高可用的分布式KV存储系统,非常适合用于服务注册与发现场景,成为微服务架构下的配置中心和服务注册表。</p><p>那么redis做服务发现可以保证以上几点呢？</p><ol><li><p>支持服务的自动注册和发现<br>redis的sub&#x2F;pub机制可以轻松实现。</p></li><li><p>支持服务健康检查<br>通知定期对服务的host进行设置，并设置过期时间和过期事件通知，从而可以监听服务是否健康。</p></li><li><p>服务信息更新的事件通知<br>redis通知开启notify-keyspace-events KA配置，客户端通过sub&#x2F;pub机制可以监听key的所有事件，set,expired等等。</p></li><li><p>简单灵活的HTTP API<br>redis仅仅支持tcp长连接，虽然通用性差一下，当时通信效率更好。</p></li><li><p>服务注册表数据持久化<br>redis也有RDB和AOF持久化策略。</p></li><li><p>支持服务负载均衡<br>redis也可以使用hash结构保存结点额外元数据，服务的负载信息等等，也可以用于实现负载均衡。</p></li></ol><p>综上几点，可以说，redis也非常适合做服务发现。</p><h1 id="redis做服务发现实现"><a href="#redis做服务发现实现" class="headerlink" title="redis做服务发现实现"></a>redis做服务发现实现</h1><ul><li><p><strong>前提</strong><br>我们启动redis时，需要修改redis.conf<br>设置 <code>notify-keyspace-events KA</code><br>这样我们可以通过watch监听某些key的所有事件，包括set(设置)，expired(过期)。</p></li><li><p><strong>rpc基础函数封装</strong><br>给rpc设置独特的key命名，防止以后业务key命名冲突,我基于框架命名。<br><code>string.format(&quot;skynet_fly:rpc:%s:%s&quot;,svr_name,svr_id)</code></p></li></ul><p>主要需要实现3个方法，<code>register</code>,<code>get_node_host</code>,<code>watch</code>。</p><ul><li><strong>register</strong> 用于服务端服务开启时，间隔一秒去设置host信息，并设置2秒的过期时间。</li><li><strong>get_node_host</strong> 用于客户端去拿取结点的host信息。</li><li><strong>watch</strong> 用于客户端监听key的set和expired事件。</li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> redisf = <span class="hljs-built_in">require</span> <span class="hljs-string">&quot;redisf&quot;</span><br><span class="hljs-keyword">local</span> string_util = <span class="hljs-built_in">require</span> <span class="hljs-string">&quot;string_util&quot;</span><br><br><span class="hljs-keyword">local</span> <span class="hljs-built_in">setmetatable</span> = <span class="hljs-built_in">setmetatable</span><br><span class="hljs-keyword">local</span> <span class="hljs-built_in">assert</span> = <span class="hljs-built_in">assert</span><br><span class="hljs-keyword">local</span> <span class="hljs-built_in">string</span> = <span class="hljs-built_in">string</span><br><span class="hljs-keyword">local</span> <span class="hljs-built_in">tonumber</span> = <span class="hljs-built_in">tonumber</span><br><br><span class="hljs-keyword">local</span> M = &#123;&#125;<br><span class="hljs-keyword">local</span> meta = &#123;<span class="hljs-built_in">__index</span> = M&#125;<br><br><span class="hljs-keyword">local</span> g_dbindex = <span class="hljs-number">0</span>          <span class="hljs-comment">--redis几号数据库</span><br><span class="hljs-keyword">local</span> g_db_name = <span class="hljs-string">&quot;rpc&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">M:new</span><span class="hljs-params">()</span></span><br><span class="hljs-keyword">local</span> cli = redisf.new_client(g_db_name)<br><span class="hljs-keyword">local</span> t = &#123;<br>cli = cli<br>&#125;<br><span class="hljs-built_in">assert</span>(cli,<span class="hljs-string">&quot;can`t connect redis&quot;</span>,g_db_name)<br><span class="hljs-built_in">setmetatable</span>(t,meta)<br><span class="hljs-keyword">return</span> t<br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">--注册，设置连接信息2秒过期时间，需要1秒调用一次</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">M:register</span><span class="hljs-params">(svr_name,svr_id,host)</span></span><br><span class="hljs-built_in">assert</span>(svr_name,<span class="hljs-string">&quot;not svr_name&quot;</span>)<br><span class="hljs-built_in">assert</span>(svr_id,<span class="hljs-string">&quot;not svr_id&quot;</span>)<br><span class="hljs-built_in">assert</span>(host,<span class="hljs-string">&quot;not host&quot;</span>)<br><br><span class="hljs-keyword">local</span> key = <span class="hljs-built_in">string</span>.<span class="hljs-built_in">format</span>(<span class="hljs-string">&quot;skynet_fly:rpc:%s:%s&quot;</span>,svr_name,svr_id)<br><span class="hljs-built_in">self</span>.cli:set(key,host,<span class="hljs-string">&quot;EX&quot;</span>,<span class="hljs-number">2</span>)<br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">--获取结点的ip和端口</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">M:get_node_host</span><span class="hljs-params">(svr_name,svr_id)</span></span><br><span class="hljs-built_in">assert</span>(svr_name,<span class="hljs-string">&quot;not svr_name&quot;</span>)<br><span class="hljs-built_in">assert</span>(svr_id,<span class="hljs-string">&quot;not svr_id&quot;</span>)<br><br><span class="hljs-keyword">local</span> key = <span class="hljs-built_in">string</span>.<span class="hljs-built_in">format</span>(<span class="hljs-string">&quot;skynet_fly:rpc:%s:%s&quot;</span>,svr_name,svr_id)<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">self</span>.cli:get(key)<br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">--监听结点host</span><br><span class="hljs-comment">--redis config 需要配置 notify-keyspace-events KA</span><br><span class="hljs-comment">--可以监听key的所有操作事情包括过期</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">M:watch</span><span class="hljs-params">(svr_name,call_back)</span></span><br><span class="hljs-keyword">local</span> k = <span class="hljs-built_in">string</span>.<span class="hljs-built_in">format</span>(<span class="hljs-string">&quot;__keyspace@%d__:skynet_fly:rpc:%s:*&quot;</span>,g_dbindex,svr_name)<br><span class="hljs-keyword">return</span> redisf.new_watch(g_db_name,&#123;&#125;,&#123;k&#125;,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(event,key,psubkey)</span></span><br><span class="hljs-keyword">local</span> split_str = string_util.split(key,<span class="hljs-string">&#x27;:&#x27;</span>)<br><span class="hljs-keyword">local</span> svr_id = <span class="hljs-built_in">tonumber</span>(split_str[#split_str])<br><span class="hljs-keyword">if</span> event == <span class="hljs-string">&#x27;set&#x27;</span> <span class="hljs-keyword">then</span><br><span class="hljs-keyword">local</span> host = <span class="hljs-built_in">self</span>:get_node_host(svr_name,svr_id)<br><span class="hljs-keyword">if</span> host <span class="hljs-keyword">then</span><br>call_back(event,svr_name,svr_id,host)<br><span class="hljs-keyword">else</span><br>call_back(<span class="hljs-string">&quot;get_failed&quot;</span>,svr_name,svr_id)<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">elseif</span> event == <span class="hljs-string">&#x27;expired&#x27;</span> <span class="hljs-keyword">then</span><br>call_back(event,svr_name,svr_id,<span class="hljs-literal">nil</span>)<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span>)<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">return</span> M<br></code></pre></td></tr></table></figure><ul><li><p><strong>服务端修改</strong><br>考虑到兼容性和扩展性，只是在<code>cluster_server.lua</code>增加了register的配置，不想使用服务发现也可以，后续想用etcd做服务发现也好扩展。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">--共享配置</span><br>share_config_m = &#123;<br>launch_seq = <span class="hljs-number">1</span>,<br>launch_num = <span class="hljs-number">1</span>,<br>default_arg = &#123;<br><span class="hljs-comment">--cluster_server用的配置</span><br>cluster_server = &#123;<br>host = <span class="hljs-string">&quot;127.0.0.1:9688&quot;</span>,<br>register = <span class="hljs-string">&quot;redis&quot;</span>,        <span class="hljs-comment">--连接信息注册到redis</span><br>&#125;,<br><br>redis = &#123;<br><span class="hljs-comment">--rpc连接配置</span><br>rpc = &#123;<br>host = <span class="hljs-string">&#x27;127.0.0.1&#x27;</span>,<br>port = <span class="hljs-number">6379</span>,<br>auth = <span class="hljs-string">&#x27;123456&#x27;</span>,<br>db = <span class="hljs-number">0</span>,<br>&#125;,<br>&#125;,<br>&#125;<br>&#125;,<br></code></pre></td></tr></table></figure><p>需要在redis配置中配置名称为rpc的配置。<br>cluster_server增加如下代码</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> register = conf.register<br><span class="hljs-keyword">if</span> register == <span class="hljs-string">&#x27;redis&#x27;</span> <span class="hljs-keyword">then</span> <span class="hljs-comment">--注册到redis</span><br><span class="hljs-keyword">local</span> rpccli = rpc_redis:new()<br><span class="hljs-comment">--一秒写一次</span><br>timer:new(timer.second,<span class="hljs-number">0</span>,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span><br>rpccli:register(g_svr_name,g_svr_id,conf.host)<br><span class="hljs-keyword">end</span>)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>一秒一次是调用注册，如果服务下线了，客户端将收到key过期的通知。</p></li><li><p><strong>客户端</strong><br>考虑到兼容性和扩展性，只是在<code>cluster_server.lua</code>增加了watch的配置，不想使用服务发现也可以，后续想用etcd做服务发现也好扩展。<br>load_mods.lua</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs lua">share_config_m = &#123;<br>launch_seq = <span class="hljs-number">1</span>,<br>launch_num = <span class="hljs-number">1</span>,<br>default_arg = &#123;<br>redis = &#123;<br><span class="hljs-comment">--rpc连接配置</span><br>rpc = &#123;<br>host = <span class="hljs-string">&#x27;127.0.0.1&#x27;</span>,<br>port = <span class="hljs-number">6379</span>,<br>auth = <span class="hljs-string">&#x27;123456&#x27;</span>,<br>db = <span class="hljs-number">0</span>,<br>&#125;,<br>&#125;,<br>&#125;<br>&#125;,<br><br>cluster_client_m = &#123;<br>launch_seq = <span class="hljs-number">2</span>,<br>launch_num = <span class="hljs-number">1</span>,<br>default_arg = &#123;<br>node_map = &#123;<br>[<span class="hljs-string">&#x27;cluster_server_byredis&#x27;</span>] = <span class="hljs-literal">true</span>,   <span class="hljs-comment">--连接cluster_server_byredis服务</span><br>&#125;,<br>watch = <span class="hljs-string">&#x27;redis&#x27;</span>,  <span class="hljs-comment">--监听redis的方式做服务发现</span><br>&#125;<br>&#125;,<br><br></code></pre></td></tr></table></figure></li></ul><p>cluster_client_m.lua</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">if</span> watch == <span class="hljs-string">&#x27;redis&#x27;</span> <span class="hljs-keyword">then</span><br><span class="hljs-comment">--redis服务发现方式</span><br><span class="hljs-keyword">local</span> rpccli = rpc_redis:new()<br><span class="hljs-keyword">for</span> svr_name,node <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(node_map) <span class="hljs-keyword">do</span><br>g_redis_watch_cancel_map[svr_name] = rpccli:watch(svr_name,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(event,name,id,host)</span></span><br><span class="hljs-keyword">if</span> event == <span class="hljs-string">&#x27;set&#x27;</span> <span class="hljs-keyword">then</span>            <span class="hljs-comment">--设置</span><br><span class="hljs-keyword">local</span> old_host = get_node_host(name,id)<br><span class="hljs-keyword">if</span> old_host ~= host <span class="hljs-keyword">then</span><br>del_node(name,id)<br>add_node(name,id,host)<br><span class="hljs-built_in">log</span>.<span class="hljs-built_in">error</span>(<span class="hljs-string">&quot;change cluster node :&quot;</span>,name,id,old_host,host)<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">elseif</span> event == <span class="hljs-string">&#x27;expired&#x27;</span> <span class="hljs-keyword">then</span>    <span class="hljs-comment">--过期</span><br>del_node(name,id)<br><span class="hljs-built_in">log</span>.<span class="hljs-built_in">error</span>(<span class="hljs-string">&quot;down cluster node :&quot;</span>,name,id)<br><span class="hljs-keyword">elseif</span> event == <span class="hljs-string">&#x27;get_failed&#x27;</span> <span class="hljs-keyword">then</span> <span class="hljs-comment">--拿不到配置，通常是因为redis挂了，或者key被意外删除，或者redis出现性能瓶颈了</span><br>del_node(name,id)<br><span class="hljs-built_in">log</span>.<span class="hljs-built_in">error</span>(<span class="hljs-string">&quot;get_failed cluster node :&quot;</span>,name,id)<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span>)<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">else</span><br><span class="hljs-comment">--本机配置方式</span><br><span class="hljs-keyword">for</span> svr_name,node <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(node_map) <span class="hljs-keyword">do</span><br><span class="hljs-keyword">for</span> svr_id,host <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(node) <span class="hljs-keyword">do</span><br>add_node(svr_name,svr_id,host)<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>完成使用实例可以查看运行,<code>examples/cluster_client_byredis</code>，<code>examples/cluster_server_byredis_1</code>,<code>examples/cluster_server_byredis_2</code>。<br>跟没有使用服务发现的示例对比，区别主要在load_mods.lua配置上面。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>cluster_rpc API保持了易用性，服务发现机制也保留了扩展性,后续想支持ectd可以非常方便，不过cluster_rpc只方便跟skynet的项目做对接，后续看要不要实现grpc。</p><p><a href="https://github.com/huahua132/skynet_fly">skynetfly源码地址</a></p>]]></content>
    
    
    <categories>
      
      <category>skynet_fly实现思路历程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>skynet_fly实现思路历程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于room_game可热更分配房间类游戏架构</title>
    <link href="/2023/07/22/skynet_fly_ss/room_game/"/>
    <url>/2023/07/22/skynet_fly_ss/room_game/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>room_game是skynet_fly基于热更系统实现的分配房间类游戏架构。<br>    room_game注重什么：<br>    * 框架与业务解耦。<br>    * 可热更。<br>    * 协议使用自由，目前提供protobuf和json协议。<br>    * socket和websocket通用。</p><h1 id="架构介绍"><a href="#架构介绍" class="headerlink" title="架构介绍"></a>架构介绍</h1><p>room_game架构由多个skynet服务组成,由<strong>gate网关</strong>，<strong>login登录服</strong>,<strong>hall大厅服</strong>，<strong>alloc分配服</strong>,<strong>room房间服</strong>组成。<br>room_game针对玩家登录、登出事情处理好了服务之间消息处理。预留了相关事件的接口，开发新游戏只需要针对相关接口做对应的处理就行。</p><p><img src="/img/skynet_fly/room_game.png"></p><ul><li><p><strong>gate网关</strong><br>room_game可以选择使用gate或者ws_gate，gate用的是skynet原生的gate，ws_gate是skynet_fly基于skynet的websocket实现的。<br>ws_gate是基于master&#x2F;slave模式，slave可以开多个，可以充分利用多核优势。</p></li><li><p><strong>login登录服</strong><br>登录服依赖 <strong>share_config_m</strong>配置。<br>下面是写在load_mods.lua的配置。<br>登录服是不支持热更的，因为agent是跟player_id绑定的，登录需要一直记录player_id和对应管理agent的hall大厅对重连做保障。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">--共享配置</span><br>share_config_m = &#123;<br>launch_seq = <span class="hljs-number">1</span>,<br>launch_num = <span class="hljs-number">1</span>,<br>default_arg = &#123;<br><span class="hljs-comment">--room_game_login用的配置</span><br>room_game_login = &#123;<br>gateservice = <span class="hljs-string">&quot;gate&quot;</span>, <span class="hljs-comment">--gate 或者 wsgate</span><br><span class="hljs-comment">--gate连接配置</span><br>gateconf = &#123;<br>address = <span class="hljs-string">&#x27;127.0.0.1&#x27;</span>,<br>port = <span class="hljs-number">8001</span>,<br>maxclient = <span class="hljs-number">2048</span>,<br>&#125;,<br>login_plug = <span class="hljs-string">&quot;login_plug&quot;</span>,<br>&#125;<br>&#125;<br>&#125;,<br></code></pre></td></tr></table></figure><p>其中<code>login_plug</code>表示登录服需要引入的登录插件。<br>其中插件需要实现全部接口,不然会被assert断言导致启动失败。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-built_in">assert</span>(login_plug.init,<span class="hljs-string">&quot;login_plug not init&quot;</span>)   <span class="hljs-comment">--初始化</span><br><span class="hljs-built_in">assert</span>(login_plug.<span class="hljs-built_in">unpack</span>,<span class="hljs-string">&quot;login_plug not unpack&quot;</span>)              <span class="hljs-comment">--解包函数</span><br><span class="hljs-built_in">assert</span>(login_plug.check,<span class="hljs-string">&quot;login_plug not check&quot;</span>)   <span class="hljs-comment">--登录检查</span><br><span class="hljs-built_in">assert</span>(login_plug.login_succ,<span class="hljs-string">&quot;login_plug not login_succ&quot;</span>)   <span class="hljs-comment">--登录成功</span><br><span class="hljs-built_in">assert</span>(login_plug.login_failed,<span class="hljs-string">&quot;login_plug not login_failed&quot;</span>)  <span class="hljs-comment">--登录失败</span><br><span class="hljs-built_in">assert</span>(login_plug.disconnect,<span class="hljs-string">&quot;login_plug not disconnect&quot;</span>)      <span class="hljs-comment">--掉线</span><br><span class="hljs-built_in">assert</span>(login_plug.login_out,<span class="hljs-string">&quot;login_plug not login_out&quot;</span>)        <span class="hljs-comment">--登出</span><br><span class="hljs-built_in">assert</span>(login_plug.time_out,<span class="hljs-string">&quot;login_plug not time_out&quot;</span>)   <span class="hljs-comment">--登录超时时间</span><br><br><span class="hljs-built_in">assert</span>(login_plug.logining,<span class="hljs-string">&quot;login_plug not logining&quot;</span>)          <span class="hljs-comment">--正在登录中</span><br><span class="hljs-built_in">assert</span>(login_plug.repeat_login,<span class="hljs-string">&quot;login_plug not repeat_login&quot;</span>)  <span class="hljs-comment">--重复登录</span><br></code></pre></td></tr></table></figure></li><li><p><code>init()</code> 插件可能需要做一些初始化的工作，比如加载pb协议。</p></li><li><p><code>unpack(msg,sz)</code> 客户端消息解包函数。</p></li><li><p><code>check(gate,fd,packname,req)</code> 登录检查函数，成功应该返回玩家id，登录失败通常返回nil,errcode,errmsg，errcode,errmsg将传入login_failed中。</p></li><li><p><code>login_failed(gate,fd,player_id,errcode,errmsg)</code> 登录失败，这里可以给客户端发送登录失败的错误信息。</p></li><li><p><code>login_succ(gate,fd,player_id,login_res)</code> 登录成功，这里可以给客户端发送登录成功。</p></li><li><p><code>login_out(player_id)</code> 登出回调。</p></li><li><p><code>disconnect(gate,fd,player_id)</code> 掉线回调。</p></li><li><p><code>logining(gate,fd,player_id)</code> 正在登入中。上一个登录请求还没有处理完。</p></li><li><p><code>repeat_login(gate,fd,player_id)</code> 被挤号。 一般这里通知在其他设备登录。</p></li><li><p><strong>hall大厅服</strong><br>大厅服可以启动多个，用于管理agent，记录玩家绑定的alloc服务和room服务，保证断线重连可以重回房间。<br>大厅服支持热更，热更之后的玩家都会登录到新的服务，旧的服务一直维持到该服务中的所有玩家登出。<br>大厅服配置</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">--大厅服</span><br>room_game_hall_m = &#123;<br>launch_seq = <span class="hljs-number">2</span>,<br>launch_num = <span class="hljs-number">6</span>,<br>default_arg = &#123;<br>hall_plug = <span class="hljs-string">&quot;hall_plug&quot;</span>,<br>&#125;<br>&#125;,<br></code></pre></td></tr></table></figure><p>其中<code>hall_plug</code>表示大厅服需要实现的插件接口。</p></li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-built_in">assert</span>(hall_plug.init,<span class="hljs-string">&quot;not init&quot;</span>)             <span class="hljs-comment">--初始化</span><br><span class="hljs-built_in">assert</span>(hall_plug.<span class="hljs-built_in">unpack</span>,<span class="hljs-string">&quot;not unpack&quot;</span>)         <span class="hljs-comment">--解包函数</span><br><span class="hljs-built_in">assert</span>(hall_plug.dispatch,<span class="hljs-string">&quot;not dispatch&quot;</span>)     <span class="hljs-comment">--消息分发</span><br><span class="hljs-built_in">assert</span>(hall_plug.connect,<span class="hljs-string">&quot;not connect&quot;</span>)       <span class="hljs-comment">--连接大厅</span><br><span class="hljs-built_in">assert</span>(hall_plug.disconnect,<span class="hljs-string">&quot;not disconnect&quot;</span>) <span class="hljs-comment">--掉线</span><br><span class="hljs-built_in">assert</span>(hall_plug.reconnect,<span class="hljs-string">&quot;not reconnect&quot;</span>)   <span class="hljs-comment">--重连</span><br><span class="hljs-built_in">assert</span>(hall_plug.goout,<span class="hljs-string">&quot;not goout&quot;</span>)           <span class="hljs-comment">--退出</span><br></code></pre></td></tr></table></figure><ul><li><p><code>init()</code> 初始化。</p></li><li><p><code>unpack(msg,sz)</code> 客户端消息解包。</p></li><li><p><code>dispatch(gate,fd,packname,req,CMD)</code> 处理消息，返回值为true表示大厅已经处理消息，为false，表示需要转发到<strong>room</strong>房间服去处理。</p></li><li><p><code>connect(gate,fd,player_id)</code> 连接到大厅。</p></li><li><p><code>disconnect(gate,fd,player_id)</code> 掉线。</p></li><li><p><code>reconnect(gate,fd,player_id)</code> 重连。</p></li><li><p><code>goout(player_id)</code> 登出。</p></li><li><p><strong>alloc分配服</strong><br>分配服只有一个，我觉得单服设计应该简单一点。<br>可以热更。热更后，旧的分配服不会再进入玩家了。<br>分配服配置</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">--分配服</span><br>room_game_alloc_m = &#123;<br>launch_seq = <span class="hljs-number">3</span>,<br>launch_num = <span class="hljs-number">1</span>,<br>default_arg = &#123;<br>alloc_plug = <span class="hljs-string">&quot;alloc_plug&quot;</span>,<br>MAX_TABLES = <span class="hljs-number">10000</span>,<br>&#125;<br>&#125;,<br></code></pre></td></tr></table></figure><p>其中MAX_TABLES是最大桌子数量，alloc用了简单轮询机制去给room服分配房间。<br>alloc_plug表示分配服需要实现的插件接口。</p></li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-built_in">assert</span>(alloc_plug.init,<span class="hljs-string">&quot;not alloc init&quot;</span>)           <span class="hljs-comment">--初始化</span><br><span class="hljs-built_in">assert</span>(alloc_plug.<span class="hljs-built_in">match</span>,<span class="hljs-string">&quot;not match&quot;</span>)       <span class="hljs-comment">--匹配</span><br><span class="hljs-built_in">assert</span>(alloc_plug.tablefull,<span class="hljs-string">&quot;not tablefull&quot;</span>)       <span class="hljs-comment">--桌子已满</span><br><span class="hljs-built_in">assert</span>(alloc_plug.createtable,<span class="hljs-string">&quot;not createtable&quot;</span>)   <span class="hljs-comment">--创建桌子</span><br><span class="hljs-built_in">assert</span>(alloc_plug.entertable,<span class="hljs-string">&quot;not entertable&quot;</span>)     <span class="hljs-comment">--进入桌子</span><br><span class="hljs-built_in">assert</span>(alloc_plug.leavetable,<span class="hljs-string">&quot;not leavetable&quot;</span>)     <span class="hljs-comment">--离开桌子</span><br><span class="hljs-built_in">assert</span>(alloc_plug.dismisstable,<span class="hljs-string">&quot;not dismisstable&quot;</span>) <span class="hljs-comment">--解散桌子</span><br></code></pre></td></tr></table></figure><ul><li><p><code>init()</code> 初始化.</p></li><li><p><code>match(player_id)</code> 匹配桌子。返回桌子id匹配成功，返回nil匹配失败，失败之后会去创建桌子，如果桌子爆满会调用tablefull接口。</p></li><li><p><code>createtable(table_id)</code> 创建了一个桌子。</p></li><li><p><code>entertable(table_id,player_id)</code> 玩家进入桌子。</p></li><li><p><code>leavetable(table_id,player_id)</code> 玩家离开桌子。</p></li><li><p><code>dismisstable(table_id)</code> 桌子被销毁了。</p></li><li><p><code>tablefull()</code> 桌子已经满了。  这里可以nil,errcode,errmsg，会被登录服接住，之后出现在登录服的login_failed接口中。</p></li><li><p><strong>room房间服</strong><br>可以开多个。<br>可以热更。<br>房间服配置。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">--房间服</span><br>room_game_room_m = &#123;<br>launch_seq = <span class="hljs-number">4</span>,<br>launch_num = <span class="hljs-number">6</span>,<br>default_arg = &#123;<br>room_plug = <span class="hljs-string">&quot;room_plug&quot;</span>,<br>room_conf = &#123;<br>player_num = <span class="hljs-number">2</span>,<br>&#125;<br>&#125;<br>&#125;,<br></code></pre></td></tr></table></figure><p>room_plug表示房间服需要实现的插件接口。</p></li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-built_in">assert</span>(room_plug.init,<span class="hljs-string">&quot;not room_plug init&quot;</span>)                 <span class="hljs-comment">--初始化</span><br><span class="hljs-built_in">assert</span>(room_plug.table_creator,<span class="hljs-string">&quot;not table_creator&quot;</span>)         <span class="hljs-comment">--桌子建造者</span><br><br><span class="hljs-keyword">local</span> tmp_table = room_plug.table_creator(<span class="hljs-number">1</span>,g_room_conf,ROOM_CMD)<br><br><span class="hljs-built_in">assert</span>(tmp_table.enter,<span class="hljs-string">&quot;table_creator not enter&quot;</span>)           <span class="hljs-comment">--坐下</span><br><span class="hljs-built_in">assert</span>(tmp_table.leave,<span class="hljs-string">&quot;table_creator not leave&quot;</span>)           <span class="hljs-comment">--离开</span><br><span class="hljs-built_in">assert</span>(tmp_table.disconnect,<span class="hljs-string">&quot;table_creator not disconnect&quot;</span>) <span class="hljs-comment">--掉线</span><br><span class="hljs-built_in">assert</span>(tmp_table.reconnect,<span class="hljs-string">&quot;table_creator not reconnect&quot;</span>)   <span class="hljs-comment">--重连</span><br><span class="hljs-built_in">assert</span>(tmp_table.handler,<span class="hljs-string">&quot;table_creator not handler&quot;</span>)       <span class="hljs-comment">--消息处理</span><br></code></pre></td></tr></table></figure><ul><li><code>init()</code> 初始化</li><li><code>table_creator(table_id,room_conf,ROOM_CMD)</code> 创建游戏桌子，返回一个游戏桌子闭包，提供基础接口处理。</li><li><code>table.enter(player)</code> 玩家桌下。</li><li><code>table.leave(player)</code> 玩家离开。</li><li><code>table.disconnect(player)</code> 玩家掉线。</li><li><code>table.reconnect(player)</code> 玩家重连。</li><li><code>table.handler(player,packname,req)</code> 消息处理。</li></ul>]]></content>
    
    
    <categories>
      
      <category>skynet_fly实现思路历程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>skynet_fly实现思路历程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于redis的封装</title>
    <link href="/2023/07/08/skynet_fly_ss/redis/"/>
    <url>/2023/07/08/skynet_fly_ss/redis/</url>
    
    <content type="html"><![CDATA[<h1 id="为什么要封装redis？"><a href="#为什么要封装redis？" class="headerlink" title="为什么要封装redis？"></a>为什么要封装redis？</h1><ol><li>适用skynet_fly生态。</li><li>redis连接配置可以写在mod_config中。</li></ol><h1 id="对于实现方式的思考"><a href="#对于实现方式的思考" class="headerlink" title="对于实现方式的思考"></a>对于实现方式的思考</h1><ul><li><p><strong>方式一</strong><br>  用skynet_fly 热更模块的方式，这样连接配置就可以写在mod_config，还可以配置连接多个不同的redis。<br>  <strong>优势</strong>：<br>  1. 配置redis连接方便。<br>  2. 固定redis连接数量。<br>  <strong>劣势</strong><br>  1. 多了一次消息的打包解包。<br>  2. redis的sub&#x2F;pub，订阅通知不好处理。<br>  3. redis的scan命令，数据存在被刷新的可能。</p></li><li><p><strong>方式二</strong><br>  按lua模块实现，去<strong>配置中心</strong>拿取配置。<br>  <strong>优势</strong><br>  1. 配置redis连接方便。<br>  2. 独占订阅连接。<br>  3. 直连redis。<br>  4. 独立的scan命令游标。<br>  <strong>劣势</strong><br>  1. 连接随服务数量增长。</p></li></ul><p>用脚思考，直接选二。</p><h1 id="基于方式二的实现"><a href="#基于方式二的实现" class="headerlink" title="基于方式二的实现"></a>基于方式二的实现</h1><p>先弄个配置中心，简单的key-value形式，非常简单。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> skynet = <span class="hljs-built_in">require</span> <span class="hljs-string">&quot;skynet&quot;</span><br><span class="hljs-keyword">local</span> timer = <span class="hljs-built_in">require</span> <span class="hljs-string">&quot;timer&quot;</span><br><br><span class="hljs-keyword">local</span> g_config = <span class="hljs-literal">nil</span><br><span class="hljs-keyword">local</span> CMD = &#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CMD.start</span><span class="hljs-params">(config)</span></span><br>g_config = <span class="hljs-built_in">config</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CMD.query</span><span class="hljs-params">(k)</span></span><br><span class="hljs-keyword">return</span> g_config[k]<br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CMD.exit</span><span class="hljs-params">()</span></span><br>timer:new(timer.minute,<span class="hljs-number">1</span>,skynet.<span class="hljs-built_in">exit</span>)<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">return</span> CMD<br></code></pre></td></tr></table></figure><p>配合<code>contriner_client.lua</code>模块，就可以轻松拿取配置。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> cli = contriner_client:new(<span class="hljs-string">&#x27;share_config_m&#x27;</span>)<br><span class="hljs-keyword">local</span> conf_map = cli:mod_call(<span class="hljs-string">&#x27;query&#x27;</span>,<span class="hljs-string">&#x27;redis&#x27;</span>)<br></code></pre></td></tr></table></figure><p>接下来就可以收割redisf.lua的实现了</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> skynet = <span class="hljs-built_in">require</span> <span class="hljs-string">&quot;skynet&quot;</span><br><span class="hljs-keyword">local</span> contriner_client = <span class="hljs-built_in">require</span> <span class="hljs-string">&quot;contriner_client&quot;</span><br><span class="hljs-keyword">local</span> redis = <span class="hljs-built_in">require</span> <span class="hljs-string">&quot;skynet.db.redis&quot;</span><br><span class="hljs-keyword">local</span> sha2 = <span class="hljs-built_in">require</span> <span class="hljs-string">&quot;sha2&quot;</span><br><span class="hljs-keyword">local</span> <span class="hljs-built_in">log</span> = <span class="hljs-built_in">require</span> <span class="hljs-string">&quot;log&quot;</span><br><br><span class="hljs-keyword">local</span> <span class="hljs-built_in">setmetatable</span> = <span class="hljs-built_in">setmetatable</span><br><span class="hljs-keyword">local</span> <span class="hljs-built_in">assert</span> = <span class="hljs-built_in">assert</span><br><span class="hljs-keyword">local</span> <span class="hljs-built_in">pcall</span> = <span class="hljs-built_in">pcall</span><br><span class="hljs-keyword">local</span> <span class="hljs-built_in">ipairs</span> = <span class="hljs-built_in">ipairs</span><br><span class="hljs-keyword">local</span> <span class="hljs-built_in">type</span> = <span class="hljs-built_in">type</span><br><span class="hljs-keyword">local</span> <span class="hljs-built_in">string</span> = <span class="hljs-built_in">string</span><br><br><span class="hljs-keyword">local</span> g_sha_map = &#123;&#125;<br><br><span class="hljs-keyword">local</span> M = &#123;&#125;<br><span class="hljs-comment">--[[</span><br><span class="hljs-comment">函数作用域：M的成员函数</span><br><span class="hljs-comment">函数名称：new_client</span><br><span class="hljs-comment">描述:新建一个在share_config_m 中写的key为redis表的名为db_name的连接配置</span><br><span class="hljs-comment">参数：</span><br><span class="hljs-comment">- db_name (string): 连接配置名称</span><br><span class="hljs-comment">]]</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">M.new_client</span><span class="hljs-params">(db_name)</span></span><br><span class="hljs-keyword">local</span> cli = contriner_client:new(<span class="hljs-string">&#x27;share_config_m&#x27;</span>)<br><span class="hljs-keyword">local</span> conf_map = cli:mod_call(<span class="hljs-string">&#x27;query&#x27;</span>,<span class="hljs-string">&#x27;redis&#x27;</span>)<br><span class="hljs-built_in">assert</span>(conf_map <span class="hljs-keyword">and</span> conf_map[db_name],<span class="hljs-string">&quot;not redis conf&quot;</span>)<br><br><span class="hljs-keyword">local</span> conf = conf_map[db_name]<br><span class="hljs-keyword">local</span> ok,conn = <span class="hljs-built_in">pcall</span>(redis.connect,conf)<br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> ok <span class="hljs-keyword">then</span><br><span class="hljs-built_in">log</span>.fatal(<span class="hljs-string">&quot;redisf new_client err &quot;</span>,conn,conf)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">return</span> conn<br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">--[[</span><br><span class="hljs-comment">函数作用域：M的成员函数</span><br><span class="hljs-comment">函数名称：script_run</span><br><span class="hljs-comment">描述:运行redis脚本命令</span><br><span class="hljs-comment">参数：</span><br><span class="hljs-comment">- conn (redis_conn): new_client返回的连接对象</span><br><span class="hljs-comment">- script_str (string)：redis lua 脚本</span><br><span class="hljs-comment">- ...       脚本传递参数</span><br><span class="hljs-comment">]]</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">M.script_run</span><span class="hljs-params">(conn,script_str,...)</span></span><br><span class="hljs-built_in">assert</span>(conn)<br><span class="hljs-built_in">assert</span>(<span class="hljs-built_in">type</span>(script_str) == <span class="hljs-string">&#x27;string&#x27;</span>,<span class="hljs-string">&#x27;script_str not string&#x27;</span>)<br><br><span class="hljs-keyword">local</span> sha = g_sha_map[script_str]<br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> sha <span class="hljs-keyword">then</span><br>sha = sha2.sha1(script_str)<br>g_sha_map[script_str] = sha<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">local</span> ok,ret = <span class="hljs-built_in">pcall</span>(conn.evalsha,conn,sha,...)<br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> ok <span class="hljs-keyword">then</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">string</span>.<span class="hljs-built_in">find</span>(ret,<span class="hljs-string">&quot;NOSCRIPT&quot;</span>,<span class="hljs-literal">nil</span>,<span class="hljs-literal">true</span>) <span class="hljs-keyword">then</span><br>ret = conn:eval(script_str,...)<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">return</span> ret<br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">--[[</span><br><span class="hljs-comment">函数作用域：M的成员函数</span><br><span class="hljs-comment">函数名称：new_watch</span><br><span class="hljs-comment">描述:redis订阅</span><br><span class="hljs-comment">参数：</span><br><span class="hljs-comment">- db_name (string): 连接的redis名称</span><br><span class="hljs-comment">- subscribe_list (table): 订阅的固定key</span><br><span class="hljs-comment">- psubscribe_list (table): 订阅的匹配key</span><br><span class="hljs-comment">- call_back (function): 消息回调函数</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">返回值</span><br><span class="hljs-comment">- 取消订阅函数</span><br><span class="hljs-comment">]]</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">M.new_watch</span><span class="hljs-params">(db_name,subscribe_list,psubscribe_list,call_back)</span></span><br><span class="hljs-keyword">local</span> cli = contriner_client:new(<span class="hljs-string">&#x27;share_config_m&#x27;</span>)<br><span class="hljs-keyword">local</span> conf_map = cli:mod_call(<span class="hljs-string">&#x27;query&#x27;</span>,<span class="hljs-string">&#x27;redis&#x27;</span>)<br><span class="hljs-built_in">assert</span>(conf_map <span class="hljs-keyword">and</span> conf_map[db_name],<span class="hljs-string">&quot;not redis conf&quot;</span>)<br><span class="hljs-keyword">local</span> conf = conf_map[db_name]<br><br><span class="hljs-keyword">local</span> ok,watch = <span class="hljs-built_in">pcall</span>(redis.watch,conf)<br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> ok <span class="hljs-keyword">then</span><br><span class="hljs-built_in">log</span>.fatal(<span class="hljs-string">&quot;redisf new_watch err &quot;</span>,conf)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">for</span> _,key <span class="hljs-keyword">in</span> <span class="hljs-built_in">ipairs</span>(subscribe_list) <span class="hljs-keyword">do</span><br>watch:subscribe(key)<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">for</span> _,key <span class="hljs-keyword">in</span> <span class="hljs-built_in">ipairs</span>(psubscribe_list) <span class="hljs-keyword">do</span><br>watch:psubscribe(key)<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">local</span> is_cancel = <span class="hljs-literal">false</span><br><br>skynet.fork(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span><br><span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> is_cancel <span class="hljs-keyword">do</span><br><span class="hljs-keyword">local</span> ok,msg,key,psubkey = <span class="hljs-built_in">pcall</span>(watch.message,watch)<br><span class="hljs-keyword">if</span> ok <span class="hljs-keyword">then</span><br>call_back(msg,key,psubkey)<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> is_cancel <span class="hljs-keyword">then</span><br><span class="hljs-built_in">log</span>.fatal(<span class="hljs-string">&quot;watch.message err :&quot;</span>,msg,key,psubkey)<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">break</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span>)<br><br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span><br><span class="hljs-keyword">for</span> _,key <span class="hljs-keyword">in</span> <span class="hljs-built_in">ipairs</span>(subscribe_list) <span class="hljs-keyword">do</span><br>watch:unsubscribe(key)<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">for</span> _,key <span class="hljs-keyword">in</span> <span class="hljs-built_in">ipairs</span>(psubscribe_list) <span class="hljs-keyword">do</span><br>watch:punsubscribe(key)<br><span class="hljs-keyword">end</span><br>watch:disconnect()<br>is_cancel = <span class="hljs-literal">true</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">return</span> M<br></code></pre></td></tr></table></figure><h1 id="版本修改"><a href="#版本修改" class="headerlink" title="版本修改"></a>版本修改</h1><p>第一个版本有一些诟病的地方：</p><ol><li><p>没有考虑首次连接失败的情况</p><ul><li><strong>问题</strong><br> redis可能挂掉，重启啥的，上一个版本没有考虑到服务启动时连不上的问题，首次连接失败后，后续不会再尝试连接。</li><li><strong>解决方案</strong><br> 每次调用命令的时候都去检测连接是否存在，不存在先尝试连接。</li></ul></li><li><p>保护执行</p><ul><li><strong>问题</strong><br> 调用redis命令，有可能因为网络原因调用失败，导致lua层面断言。</li><li><strong>解决方案</strong><br> 调用命令都经过pcall，通过__index方法对命令进行pcall包裹再缓存函数。</li></ul></li><li><p>自定义命令扩展性</p><ul><li><strong>问题</strong><br> 原生命令产生的结果可能需要进行二次处理，业务层才能更方便的使用。</li><li><strong>解决方案</strong><br> 利用__index方法检查自定义command表是否有函数，有的话用pcall进行包裹再缓存函数。<br> 增加add_command函数，外部想扩展自定义函数只需要调用该命令即可。</li></ul></li></ol><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br></pre></td><td class="code"><pre><code class="hljs lua"> <span class="hljs-keyword">local</span> skynet = <span class="hljs-built_in">require</span> <span class="hljs-string">&quot;skynet&quot;</span><br><span class="hljs-keyword">local</span> contriner_client = <span class="hljs-built_in">require</span> <span class="hljs-string">&quot;contriner_client&quot;</span><br><span class="hljs-keyword">local</span> redis = <span class="hljs-built_in">require</span> <span class="hljs-string">&quot;skynet.db.redis&quot;</span><br><span class="hljs-keyword">local</span> string_util = <span class="hljs-built_in">require</span> <span class="hljs-string">&quot;string_util&quot;</span><br><span class="hljs-keyword">local</span> sha2 = <span class="hljs-built_in">require</span> <span class="hljs-string">&quot;sha2&quot;</span><br><span class="hljs-keyword">local</span> <span class="hljs-built_in">log</span> = <span class="hljs-built_in">require</span> <span class="hljs-string">&quot;log&quot;</span><br><br><span class="hljs-keyword">local</span> <span class="hljs-built_in">setmetatable</span> = <span class="hljs-built_in">setmetatable</span><br><span class="hljs-keyword">local</span> <span class="hljs-built_in">assert</span> = <span class="hljs-built_in">assert</span><br><span class="hljs-keyword">local</span> <span class="hljs-built_in">pcall</span> = <span class="hljs-built_in">pcall</span><br><span class="hljs-keyword">local</span> <span class="hljs-built_in">ipairs</span> = <span class="hljs-built_in">ipairs</span><br><span class="hljs-keyword">local</span> <span class="hljs-built_in">pairs</span> = <span class="hljs-built_in">pairs</span><br><span class="hljs-keyword">local</span> <span class="hljs-built_in">type</span> = <span class="hljs-built_in">type</span><br><span class="hljs-keyword">local</span> <span class="hljs-built_in">string</span> = <span class="hljs-built_in">string</span><br><span class="hljs-keyword">local</span> <span class="hljs-built_in">select</span> = <span class="hljs-built_in">select</span><br><span class="hljs-keyword">local</span> tunpack = <span class="hljs-built_in">table</span>.<span class="hljs-built_in">unpack</span><br><span class="hljs-keyword">local</span> debug_getinfo = <span class="hljs-built_in">debug</span>.<span class="hljs-built_in">getinfo</span><br><br><span class="hljs-keyword">local</span> g_sha_map = &#123;&#125;<br><br><span class="hljs-keyword">local</span> M = &#123;&#125;<br><span class="hljs-keyword">local</span> command = &#123;&#125;     <span class="hljs-comment">--自定义命令函数</span><br><br><span class="hljs-keyword">local</span> cmdfuncs = &#123;&#125;    <span class="hljs-comment">--命令函数缓存</span><br><br><span class="hljs-comment">--[[</span><br><span class="hljs-comment">函数作用域：M的成员函数</span><br><span class="hljs-comment">函数名称：script_run</span><br><span class="hljs-comment">描述:运行redis脚本命令</span><br><span class="hljs-comment">参数：</span><br><span class="hljs-comment">- self (redis_conn): new_client返回的连接对象</span><br><span class="hljs-comment">- script_str (string)：redis lua 脚本</span><br><span class="hljs-comment">- ...       脚本传递参数</span><br><span class="hljs-comment">]]</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">command:script_run</span><span class="hljs-params">(script_str,...)</span></span><br><span class="hljs-keyword">local</span> conn = <span class="hljs-built_in">self</span>.conn<br><span class="hljs-built_in">assert</span>(conn,<span class="hljs-string">&quot;not connect redis &quot;</span>)<br><span class="hljs-built_in">assert</span>(<span class="hljs-built_in">type</span>(script_str) == <span class="hljs-string">&#x27;string&#x27;</span>,<span class="hljs-string">&#x27;script_str not string&#x27;</span>)<br><br><span class="hljs-keyword">local</span> sha = g_sha_map[script_str]<br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> sha <span class="hljs-keyword">then</span><br>sha = sha2.sha1(script_str)<br>g_sha_map[script_str] = sha<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">local</span> isok,ret = <span class="hljs-built_in">pcall</span>(conn.evalsha,conn,...)<br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> isok <span class="hljs-keyword">then</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">string</span>.<span class="hljs-built_in">find</span>(ret,<span class="hljs-string">&quot;NOSCRIPT&quot;</span>,<span class="hljs-literal">nil</span>,<span class="hljs-literal">true</span>) <span class="hljs-keyword">then</span><br>ret = conn:eval(script_str,...)<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">return</span> ret<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">get_line_info</span><span class="hljs-params">()</span></span><br><span class="hljs-keyword">local</span> info = debug_getinfo(<span class="hljs-number">3</span>,<span class="hljs-string">&quot;Sl&quot;</span>)<br><span class="hljs-keyword">local</span> lineinfo = info.short_src .. <span class="hljs-string">&quot;:&quot;</span> .. info.currentline<br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">--给redis命令施加保护执行</span><br><span class="hljs-keyword">local</span> mt = &#123;<br><span class="hljs-built_in">__index</span> = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(t,k)</span></span><br><span class="hljs-keyword">local</span> f = cmdfuncs[k]<br><span class="hljs-keyword">if</span> f <span class="hljs-keyword">then</span><br>t[k] = f<br><span class="hljs-keyword">return</span> f<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">local</span> f = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(self,...)</span></span><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">self</span>.conn <span class="hljs-keyword">then</span><br><span class="hljs-keyword">local</span> ok,conn = <span class="hljs-built_in">pcall</span>(redis.connect,<span class="hljs-built_in">self</span>.conf)<br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> ok <span class="hljs-keyword">then</span><br><span class="hljs-built_in">log</span>.<span class="hljs-built_in">error</span>(<span class="hljs-string">&quot;connect redis err &quot;</span>,get_line_info(),conn,k,<span class="hljs-built_in">self</span>.conf)<br><span class="hljs-keyword">return</span><br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">self</span>.conn = conn<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">local</span> cmd = command[k]<br><span class="hljs-keyword">if</span> cmd <span class="hljs-keyword">then</span><br><span class="hljs-keyword">local</span> ret = &#123;<span class="hljs-built_in">pcall</span>(cmd,<span class="hljs-built_in">self</span>,...)&#125;<br><span class="hljs-keyword">local</span> isok = ret[<span class="hljs-number">1</span>]<br><span class="hljs-keyword">local</span> err = ret[<span class="hljs-number">2</span>]<br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> isok <span class="hljs-keyword">then</span><br><span class="hljs-built_in">log</span>.<span class="hljs-built_in">error</span>(<span class="hljs-string">&quot;call redis command faild &quot;</span>,get_line_info(),err,k,...)<br><span class="hljs-keyword">return</span><br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> <span class="hljs-built_in">select</span>(<span class="hljs-number">2</span>,tunpack(ret))<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">local</span> isok,ret = <span class="hljs-built_in">pcall</span>(<span class="hljs-built_in">self</span>.conn[k],<span class="hljs-built_in">self</span>.conn,...)<br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> isok <span class="hljs-keyword">then</span><br><span class="hljs-built_in">log</span>.<span class="hljs-built_in">error</span>(<span class="hljs-string">&quot;call redis faild &quot;</span>,get_line_info(),ret,k,...)<br><span class="hljs-keyword">return</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">return</span> ret<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br>t[k] = f<br><span class="hljs-comment">--缓存命令函数</span><br>cmdfuncs[k] = f<br><span class="hljs-keyword">return</span> f<br><span class="hljs-keyword">end</span>&#125;<br><br><span class="hljs-comment">--[[</span><br><span class="hljs-comment">函数作用域：M的成员函数</span><br><span class="hljs-comment">函数名称：new_client</span><br><span class="hljs-comment">描述:新建一个在share_config_m 中写的key为redis表的名为db_name的连接配置</span><br><span class="hljs-comment">参数：</span><br><span class="hljs-comment">- db_name (string): 连接配置名称</span><br><span class="hljs-comment">]]</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">M.new_client</span><span class="hljs-params">(db_name)</span></span><br><span class="hljs-keyword">local</span> cli = contriner_client:new(<span class="hljs-string">&#x27;share_config_m&#x27;</span>)<br><span class="hljs-keyword">local</span> conf_map = cli:mod_call(<span class="hljs-string">&#x27;query&#x27;</span>,<span class="hljs-string">&#x27;redis&#x27;</span>)<br><span class="hljs-built_in">assert</span>(conf_map <span class="hljs-keyword">and</span> conf_map[db_name],<span class="hljs-string">&quot;not redis conf&quot;</span>)<br><br><span class="hljs-keyword">local</span> conf = conf_map[db_name]<br><span class="hljs-keyword">local</span> t_conn = &#123;<br>conf = conf,<br>conn = <span class="hljs-literal">false</span><br>&#125;<br><span class="hljs-built_in">setmetatable</span>(t_conn,mt)<br>t_conn:get(<span class="hljs-string">&quot;ping&quot;</span>)       <span class="hljs-comment">--尝试调一下</span><br><span class="hljs-keyword">return</span> t_conn<br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">--[[</span><br><span class="hljs-comment">函数作用域：M的成员函数</span><br><span class="hljs-comment">函数名称：add_command</span><br><span class="hljs-comment">描述:增加自定义command命令</span><br><span class="hljs-comment">参数：</span><br><span class="hljs-comment">- M (table): 定义的函数模块</span><br><span class="hljs-comment">]]</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">M.add_command</span><span class="hljs-params">(M)</span></span><br><span class="hljs-keyword">for</span> k,func <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(M) <span class="hljs-keyword">do</span><br><span class="hljs-built_in">assert</span>(<span class="hljs-keyword">not</span> command[k],<span class="hljs-string">&quot;command is exists &quot;</span> .. k)<br>command[k] = func<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><span class="hljs-comment">--[[</span><br><span class="hljs-comment">函数作用域：M的成员函数</span><br><span class="hljs-comment">函数名称：new_watch</span><br><span class="hljs-comment">描述:redis订阅</span><br><span class="hljs-comment">参数：</span><br><span class="hljs-comment">- db_name (string): 连接的redis名称</span><br><span class="hljs-comment">- subscribe_list (table): 订阅的固定key</span><br><span class="hljs-comment">- psubscribe_list (table): 订阅的匹配key</span><br><span class="hljs-comment">- call_back (function): 消息回调函数</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">返回值</span><br><span class="hljs-comment">- 取消订阅函数</span><br><span class="hljs-comment">]]</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">M.new_watch</span><span class="hljs-params">(db_name,subscribe_list,psubscribe_list,call_back)</span></span><br><span class="hljs-keyword">local</span> cli = contriner_client:new(<span class="hljs-string">&#x27;share_config_m&#x27;</span>)<br><span class="hljs-keyword">local</span> conf_map = cli:mod_call(<span class="hljs-string">&#x27;query&#x27;</span>,<span class="hljs-string">&#x27;redis&#x27;</span>)<br><span class="hljs-built_in">assert</span>(conf_map <span class="hljs-keyword">and</span> conf_map[db_name],<span class="hljs-string">&quot;not redis conf&quot;</span>)<br><span class="hljs-keyword">local</span> conf = conf_map[db_name]<br><br><span class="hljs-keyword">local</span> is_cancel = <span class="hljs-literal">false</span><br><span class="hljs-keyword">local</span> ok,watch<br><br>skynet.fork(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span><br><span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> watch <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> is_cancel <span class="hljs-keyword">do</span><br>ok,watch = <span class="hljs-built_in">pcall</span>(redis.watch,conf)<br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> ok <span class="hljs-keyword">then</span><br><span class="hljs-built_in">log</span>.<span class="hljs-built_in">error</span>(<span class="hljs-string">&quot;redisf connect watch err &quot;</span>,conf)<br><span class="hljs-keyword">end</span><br>skynet.sleep(<span class="hljs-number">100</span>)<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">for</span> _,key <span class="hljs-keyword">in</span> <span class="hljs-built_in">ipairs</span>(subscribe_list) <span class="hljs-keyword">do</span><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> is_cancel <span class="hljs-keyword">then</span><br>watch:subscribe(key)<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">for</span> _,key <span class="hljs-keyword">in</span> <span class="hljs-built_in">ipairs</span>(psubscribe_list) <span class="hljs-keyword">do</span><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> is_cancel <span class="hljs-keyword">then</span><br>watch:psubscribe(key)<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> is_cancel <span class="hljs-keyword">do</span><br><span class="hljs-keyword">local</span> ok,msg,key,psubkey = <span class="hljs-built_in">pcall</span>(watch.message,watch)<br><span class="hljs-keyword">if</span> ok <span class="hljs-keyword">then</span><br>call_back(msg,key,psubkey)<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> is_cancel <span class="hljs-keyword">then</span><br><span class="hljs-built_in">log</span>.<span class="hljs-built_in">error</span>(<span class="hljs-string">&quot;watch.message err :&quot;</span>,msg,key,psubkey)<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span>)<br><br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span><br>is_cancel = <span class="hljs-literal">true</span><br><span class="hljs-keyword">if</span> watch <span class="hljs-keyword">then</span><br><span class="hljs-keyword">for</span> _,key <span class="hljs-keyword">in</span> <span class="hljs-built_in">ipairs</span>(subscribe_list) <span class="hljs-keyword">do</span><br>watch:unsubscribe(key)<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">for</span> _,key <span class="hljs-keyword">in</span> <span class="hljs-built_in">ipairs</span>(psubscribe_list) <span class="hljs-keyword">do</span><br>watch:punsubscribe(key)<br><span class="hljs-keyword">end</span><br>watch:disconnect()<br>watch = <span class="hljs-literal">nil</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">return</span> M<br></code></pre></td></tr></table></figure><h1 id="外部扩展"><a href="#外部扩展" class="headerlink" title="外部扩展"></a>外部扩展</h1><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> redisf = <span class="hljs-built_in">require</span> <span class="hljs-string">&quot;redisf&quot;</span><br><br><span class="hljs-keyword">local</span> tinsert = <span class="hljs-built_in">table</span>.<span class="hljs-built_in">insert</span><br><span class="hljs-keyword">local</span> tunpack = <span class="hljs-built_in">table</span>.<span class="hljs-built_in">unpack</span><br><span class="hljs-keyword">local</span> <span class="hljs-built_in">pairs</span> = <span class="hljs-built_in">pairs</span><br><br><span class="hljs-keyword">local</span> M = &#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">M:hgetall</span><span class="hljs-params">(key)</span></span><br><span class="hljs-keyword">local</span> conn = <span class="hljs-built_in">self</span>.conn<br><span class="hljs-keyword">local</span> ret = conn:hgetall(key)<br><span class="hljs-keyword">local</span> res = &#123;&#125;<br><br><span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span>,#ret,<span class="hljs-number">2</span> <span class="hljs-keyword">do</span><br><span class="hljs-keyword">local</span> k = ret[i]<br><span class="hljs-keyword">local</span> v = ret[i + <span class="hljs-number">1</span>]<br>res[k] = v<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">return</span> res<br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">M:hmset</span><span class="hljs-params">(key,map)</span></span><br><span class="hljs-keyword">local</span> conn = <span class="hljs-built_in">self</span>.conn<br><span class="hljs-keyword">local</span> args_list = &#123;&#125;<br><span class="hljs-keyword">for</span> k,v <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(map) <span class="hljs-keyword">do</span><br>tinsert(args_list,k)<br>tinsert(args_list,v)<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">return</span> conn:hmset(key,tunpack(args_list))<br><span class="hljs-keyword">end</span><br><br>redisf.add_command(M)<br><br><span class="hljs-keyword">return</span> redisf<br></code></pre></td></tr></table></figure><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>测试可以看skynet_fly源码下的test模块。<br><a href="https://github.com/huahua132/skynet_fly">skynetfly源码地址</a></p>]]></content>
    
    
    <categories>
      
      <category>skynet_fly实现思路历程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>skynet_fly实现思路历程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于定时器的封装</title>
    <link href="/2023/07/02/skynet_fly_ss/timer/"/>
    <url>/2023/07/02/skynet_fly_ss/timer/</url>
    
    <content type="html"><![CDATA[<h1 id="为什么要封装定时器？"><a href="#为什么要封装定时器？" class="headerlink" title="为什么要封装定时器？"></a>为什么要封装定时器？</h1><ol><li>skynet只提供定时器注册回调，缺少传参，注销，延伸等等常用方法。</li></ol><h1 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h1><p>一开始尝试用分配定时器id的方式实现，这种方式要考虑<strong>id重用</strong>的情况，虽然说<code>int64</code>走一个轮回要很久，但是这种情况还是要处理，走了一个轮回后，就有可能前面的id还被占用着，后续的id分配效率会降低。这种实现方式不是很稳定可靠。<br>后续想了一下还是用面向对象的思想，因为前一种方式无非是timer模块用一个map对应id映射定时器信息表，注册好了返回一个id，供使用者做后续<strong>注销</strong>，<strong>延期</strong>，既然返回id是返回，为什么不直接返回table呢，反正返回的也是table的引用，并没有增加什么开销，感觉分配id的操作有点画蛇添足了。<br>还是用面向对象思想，定时器实例提供<strong>创建定时器</strong>， <strong>取消定时器</strong>，<strong>延长定时器</strong>等等方法。<br>定时器实例可以设置定时回调几次或者循环调用。后续可以继续实现按<strong>时间节点</strong>触发的定时器，比如每天上午8点，每周一零点。</p><h1 id="特殊处理"><a href="#特殊处理" class="headerlink" title="特殊处理"></a>特殊处理</h1><p>通常注册一个定时器立马调用skynet.timeout，但是如果你的定时器需要取消，我觉得这样并不好，特别是你注册的时间较长，又会注销，过程中又触发注册很频繁的话，这样会浪费掉很多内存，因为skynet注册一个定时器就会占用一个<strong>lua携程</strong>直到定时器触发回调才释放。如果你注册触发时间为1天，那么会积压1天内注册的定时器。所以我没有直接调用skynet.timeout，而是用一个间隔60秒的check循环，如果中途注销了，循环就结束了，这样非常有效的解决了这个问题，虽然多一些定时器注册回调，但是换来了稳定性，使用者不用担心有内存暴涨的风险。</p><h1 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h1><ul><li><p><strong>创建定时器</strong><br>  <code>timer:new()</code><br>  3个必传参数<br>  <code>expire</code> 回调时间，保留skynet.time_out的100等于1秒。<br>  <code>timer</code> 触发次数，0次表示循环触发。<br>  <code>callback</code> 回调函数。</p><p>  后面省略传参是回调函数的参数。</p></li><li><p><strong>取消定时器</strong><br>  <code>timeobj:cancel()</code></p></li><li><p><strong>延长定时器</strong><br>  <code>timeobj:extend(ex_expire)</code><br>  参数<br>  <code>ex_expire</code> 延长时间，如果创建定时器的时间为5秒，创建时间为：8:10:30,在定时器触发之前调用 timeobj:extend(100)，定时器会再8:10:36秒触发，在定时器触发之后调用无效。</p></li></ul><p><a href="https://github.com/huahua132/skynet_fly">skynetfly源码地址</a></p>]]></content>
    
    
    <categories>
      
      <category>skynet_fly实现思路历程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>skynet_fly实现思路历程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于skynet_fly热更新实现</title>
    <link href="/2023/06/30/skynet_fly_ss/%E5%85%B3%E4%BA%8Eskynet_fly%E7%83%AD%E6%9B%B4%E6%96%B0%E5%AE%9E%E7%8E%B0/"/>
    <url>/2023/06/30/skynet_fly_ss/%E5%85%B3%E4%BA%8Eskynet_fly%E7%83%AD%E6%9B%B4%E6%96%B0%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h1><p>可以先看看这篇<a href="https://huahua132.github.io/2023/05/22/think/reload/">关于skynet做服务热更新</a><br>这里我主要阐述各方案比较之后觉得较好的方案三实现，我在skynet_fly也决定使用方案三，接下来进入正题。</p><p>主要思想围绕新服务替换旧服务的方案，通过讲述<strong>如何热更</strong>、<strong>rpc调用</strong>、<strong>服务切换</strong>、<strong>旧服务退出</strong>这4个点展开。<br>可以结合代码看文档，这样应该会更清晰，表达能力有限♥(ˆ◡ˆԅ)</p><ul><li><p><strong>如何热更</strong><br>通过设置关闭skynet.codecache，这样launch新服务的时候加载的就是新代码了。不过我不想写每个服务的时候都去做这个操作，我就抽象了一个服务，我在skynet_fly封装了hot_container.lua服务 路径<code>service/hot_container.lua</code>。我叫它<strong>热更服务容器</strong>。<br>这个服务启动的时候要传递<strong>MODULE_NAME</strong>,也就是要加载的可热更模板的代码实现。<br>hot_container会加载<strong>MODULE_NAME</strong>名称的lua代码文件，<strong>MODULE_NAME</strong>需要返回一个CMD命令表，也就是skynet lua消息的命令，必须实现<strong>start</strong>,<strong>exit</strong>命令。这样就是实现了可热更容器的抽象。<br><strong>hot_container</strong>是可热更容器的意思。通常我们热更模块实现代码命名为<strong>xxx_m.lua</strong>,我希望这成为skynet_fly的命令规范，并且放在命名为module的文件夹下。</p></li><li><p><strong>rpc调用</strong><br>skynet的rpc调用通过服务id或者服务别名调用。可热更服务不能简单的通过服务别名调用，因为可能出现旧服务和新服务同时存在的情况，我们需要一个管理记录可热更服务的服务，如此就诞生了contriner_mgr.lua服务 路径<code>service/contriner_mgr.lua</code>，我叫它<strong>容器管理员</strong>。<br>以及给需要<strong>rpc</strong>调用的客户配套的lua模块代码contriner_client.lua 路径<code>lualib/contriner_client.lua</code>，我叫它<strong>容器客户端</strong>。<br><strong>容器管理员</strong>提供了<strong>启动热更服务</strong>、<strong>关闭热更服务</strong>、<strong>关闭所有热更服务</strong>，<strong>查询热更模块id</strong>、<strong>监听热更模块</strong>、<strong>取消监听模块</strong>，5个命令，容器管理员服务是不可以热更的。</p></li></ul><ul><li><p><strong>启动热更服务</strong><br>  <code>load_modules MODULE_NAME</code>,通过传入module_name,contriner_mgr会加载<strong>loadmodsfile</strong>配置的文件,拿到此模板的配置，然后启动服务，启动完毕再通知旧服务<strong>exit</strong>，接下给监听的服务下发新的服务id和版本号。</p></li><li><p><strong>关闭热更服务</strong><br>  <code>kill_module MODULE_NAME</code>，比如我们产品可能有些功能不要了，就可以关闭该服务了。</p></li><li><p><strong>关闭所有热更服务</strong><br>  <code>kill_all</code>，停服时使用，需要做停服的数据收尾处理。</p></li><li><p><strong>查询热更模块id</strong><br>  <code>query MODULE_NAME</code>,查询模块服务id,在contriner_client中首次加载使用查询之后挂载监听。</p></li><li><p><strong>监听热更模块</strong><br>  <code>watch MODULE_NAME</code>,监听模块。</p></li><li><p><strong>取消监听模块</strong>,<br>  <code>unwatch MODULE_NAME</code>,取消监听。</p></li></ul><p><strong>容器客户端</strong>封装了对了<strong>热更管理员</strong>的交互我们在使用时感觉不到<strong>热更管理员</strong>♥(ˆ◡ˆԅ)的存在。<br><strong>容器客户端</strong>是使用面向对象的方式实现的，为了方便每个<strong>rpc调用对象</strong>有自己的<strong>服务切换处理</strong>。<br>提供了 <strong>new</strong>、<strong>mod_send</strong>、<strong>mod_call</strong>、<strong>balance_send</strong>、<strong>balance_call</strong>、<strong>broadcast</strong>方法。</p><ul><li><p><strong>new</strong><br>  创建一个<strong>rpc</strong>调用客户端，传入想要联系的<strong>MODULE_NAME</strong>和新服务切换的检查函数。<br>  MODULE_NAME服务地址本地没有的情况下会去<strong>query</strong> <strong>容器管理员</strong>，并且<strong>watch</strong>监听。</p></li><li><p><strong>mod_send</strong><br>  通过取模自己服务id<strong>映射</strong>一个热更服务id，然后对应id skynet.send消息。</p></li><li><p><strong>mod_call</strong><br>  同mod_call，不过是调用call。</p></li><li><p><strong>balance_send</strong><br>  简单轮询负载均衡,send消息</p></li><li><p><strong>balance_call</strong><br>  简单轮询负载均衡。call消息</p></li><li><p><strong>broadcast</strong><br>  广播 send消息</p></li></ul><p>以上发消息函数调用之前都会检测<strong>是否切服</strong>。</p><p>contriner_client还<strong>重写skynet.eixt 函数</strong>，在退出前<strong>注销监听</strong>。</p><ul><li><p><strong>服务切换</strong><br>  服务的实现就是通过contriner_client中的<strong>new</strong>函数传入is_can_switch函数，每次发消息都会调用这个函数。</p></li><li><p><strong>旧服务退出</strong><br>  <strong>容器管理员</strong>launch新服务后会发送exit消息给旧服务，旧服务自己决定什么时候退出。</p></li></ul><p>监听实现思路参考了skynet.sharedata实现，看源码一度怀疑监听机制会有次序bug，觉得在query和monitor之间插入一个load处理的话就暂时收不到新的配置了。不过后面看着看着想通了。<br>传入对象与新对象不同的话，会直接返回新对象。<br>在skynet_fly中我有引入一个版本号来处理这种情况。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CMD.monitor</span><span class="hljs-params">(name, obj)</span></span><br><span class="hljs-keyword">local</span> v = <span class="hljs-built_in">assert</span>(pool[name])<br><span class="hljs-keyword">if</span> obj ~= v.obj <span class="hljs-keyword">then</span><br>sharedata.host.incref(v.obj)<br><span class="hljs-keyword">return</span> v.obj<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">local</span> n = pool_count[name].n + <span class="hljs-number">1</span><br><span class="hljs-keyword">if</span> n &gt; pool_count[name].threshold <span class="hljs-keyword">then</span><br>n = n - check_watch(v.watch)<br>pool_count[name].threshold = n * <span class="hljs-number">2</span><br><span class="hljs-keyword">end</span><br>pool_count[name].n = n<br><br><span class="hljs-built_in">table</span>.<span class="hljs-built_in">insert</span>(v.watch, skynet.response())<br><br><span class="hljs-keyword">return</span> NORET<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h1 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h1><p>可以参考查看examples下的hot_module5示例，它是一个简单的数字炸弹游戏，热更是使用可以分为2部讲解，<strong>如何启动</strong>，<strong>如何rpc调用</strong>。</p><ul><li><strong>如何启动</strong><ul><li>第一步启动<strong>容器管理员</strong>。</li><li>第二步编写<code>load_mods.lua</code>。<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">return</span> &#123;<br>service_m = &#123;<br>launch_seq = <span class="hljs-number">1</span>,<br>launch_num = <span class="hljs-number">1</span>,<br>mod_args = <span class="hljs-literal">nil</span>,<br>default_arg = &#123;<br>player_num = <span class="hljs-number">2</span>,<br>min_num = <span class="hljs-number">1</span>,<br>max_num = <span class="hljs-number">100</span>,<br>&#125;<br>&#125;,<br><br>agent_m = &#123;<br>launch_seq = <span class="hljs-number">2</span>,<br>launch_num = <span class="hljs-number">2</span>,<br>mod_args = &#123;<br>&#123;<br>player_id = <span class="hljs-number">10001</span>,<br>nickname = <span class="hljs-string">&quot;张三&quot;</span>,<br>&#125;,<br>&#123;<br>player_id = <span class="hljs-number">10004</span>,<br>nickname = <span class="hljs-string">&quot;李四&quot;</span>,<br>hello = &#123;a = <span class="hljs-number">1</span>,b = <span class="hljs-number">2</span>&#125;<br>&#125;,<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>这是load_mods.lua的一个编写示例，像service_m、和agent_m是需要启动的热更模板。<br>每个模块有4个参数可以配置。</li></ul></li><li><strong>launch_seq</strong> 首次启动顺序，从小到大。</li><li><strong>launch_num</strong> 启动数量。</li><li><strong>default_arg</strong> 默认传入配置，热更模板内的<strong>start</strong>函数接收，当<strong>mod_args</strong>中没有对应服务下标的配置时启用。</li><li><strong>mod_args</strong> 是一个配置数组，为了应对相同服务可能配置不通的情况。</li></ul><p>有了mod_config之后，我们在main.lua中通过mod_config.lua启动。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> skynet = <span class="hljs-built_in">require</span> <span class="hljs-string">&quot;skynet&quot;</span><br><span class="hljs-keyword">local</span> contriner_launcher = <span class="hljs-built_in">require</span> <span class="hljs-string">&quot;contriner_launcher&quot;</span><br><br>skynet.start(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span><br>skynet.<span class="hljs-built_in">error</span>(<span class="hljs-string">&quot;start hot_module5!!!&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;</span>)<br>contriner_launcher.run()<br><br>skynet.<span class="hljs-built_in">exit</span>()<br><span class="hljs-keyword">end</span>)<br></code></pre></td></tr></table></figure><ul><li><p><strong>如何rpc调用</strong><br>rpc调用使用非常简单易用。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> service_client = contriner_client:new(<span class="hljs-string">&quot;service_m&quot;</span>) <span class="hljs-comment">--新建一个联系service_m的对象</span><br><span class="hljs-comment">--因为service_m可能启动多个，使用模除以的方式去映射一个服务id</span><br>service_client:mod_send(cmd,...)<br>service_client:mod_call(cmd,...)<br>service_client:mod_call(cmd,...)<br><br><span class="hljs-keyword">local</span> agent_client = contriner_client:new(<span class="hljs-string">&quot;agent_m&quot;</span>) <span class="hljs-comment">--新建一个联系agent_m的对象</span><br>agent_client:mod_send(cmd,...)<br></code></pre></td></tr></table></figure><p>contriner_client会帮我们管理好对应服务的id。</p></li><li><p><strong>功能改动</strong><br>在实现mysql连接模块的时候发现同一模板多个服务可以连接不同的数据库，当rpc客户端想要联系指定的数据库时并没有很好办法，于是就扩展了instance_name,使module_name下多了一个二级目录，扩展后的<code>contriner_client</code>多<strong>mod_call_by_name</strong>等等。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> game_client = contriner_client:new(<span class="hljs-string">&quot;mysql_m&quot;</span>,<span class="hljs-string">&quot;game&quot;</span>)<br><span class="hljs-keyword">local</span> ret = game_client:mod_call_by_name(<span class="hljs-string">&quot;query&quot;</span>,<span class="hljs-string">&quot;show tables;&quot;</span>)<br><span class="hljs-built_in">log</span>.<span class="hljs-built_in">error</span>(<span class="hljs-string">&quot;ret :&quot;</span>,ret)<br><br><span class="hljs-keyword">local</span> sql_str = <span class="hljs-string">&quot;insert into user(id,name) values(&#x27;1&#x27;,&#x27;skynet_fly&#x27;);&quot;</span><br><span class="hljs-built_in">log</span>.info(<span class="hljs-string">&quot;game insert:&quot;</span>,game_client:balance_call_by_name(<span class="hljs-string">&quot;query&quot;</span>,sql_str))<br><br><span class="hljs-keyword">local</span> sql_str = <span class="hljs-string">&quot;select * from user where name = &#x27;skynet_fly&#x27;;&quot;</span><br><span class="hljs-built_in">log</span>.info(<span class="hljs-string">&quot;game select:&quot;</span>,game_client:balance_call_by_name(<span class="hljs-string">&quot;query&quot;</span>,sql_str))<br><br><span class="hljs-keyword">local</span> hall_client = contriner_client:new(<span class="hljs-string">&quot;mysql_m&quot;</span>,<span class="hljs-string">&quot;hall&quot;</span>)<br><span class="hljs-built_in">log</span>.info(<span class="hljs-string">&quot;hall select:&quot;</span>,hall_client:balance_call_by_name(<span class="hljs-string">&quot;query&quot;</span>,sql_str))<br><span class="hljs-built_in">log</span>.<span class="hljs-built_in">error</span>(<span class="hljs-string">&quot;mysql_test_m over!!!&quot;</span>)<br></code></pre></td></tr></table></figure><p>对应的启动配置</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs lua"><br>mysql_m = &#123;<br>launch_seq = <span class="hljs-number">4</span>,<br>launch_num = <span class="hljs-number">4</span>,<br>mod_args = &#123;<br>&#123;<br>instance_name = <span class="hljs-string">&quot;game&quot;</span>,<br>db_conf = &#123;<br>host = <span class="hljs-string">&#x27;127.0.0.1&#x27;</span>,<br>port = <span class="hljs-string">&#x27;3306&#x27;</span>,<br>max_packet_size = <span class="hljs-number">1048576</span>,<br>user = <span class="hljs-string">&#x27;root&#x27;</span>,<br>password = <span class="hljs-string">&#x27;123456&#x27;</span>,<br>database = <span class="hljs-string">&#x27;gamedb&#x27;</span>,<br>&#125;<br>&#125;,<br>&#123;<br>instance_name = <span class="hljs-string">&quot;game&quot;</span>,<br>db_conf = &#123;<br>host = <span class="hljs-string">&#x27;127.0.0.1&#x27;</span>,<br>port = <span class="hljs-string">&#x27;3306&#x27;</span>,<br>max_packet_size = <span class="hljs-number">1048576</span>,<br>user = <span class="hljs-string">&#x27;root&#x27;</span>,<br>password = <span class="hljs-string">&#x27;123456&#x27;</span>,<br>database = <span class="hljs-string">&#x27;gamedb&#x27;</span>,<br>&#125;<br>&#125;,<br>&#123;<br>instance_name = <span class="hljs-string">&quot;hall&quot;</span>,<br>db_conf = &#123;<br>host = <span class="hljs-string">&#x27;127.0.0.1&#x27;</span>,<br>port = <span class="hljs-string">&#x27;3306&#x27;</span>,<br>max_packet_size = <span class="hljs-number">1048576</span>,<br>user = <span class="hljs-string">&#x27;root&#x27;</span>,<br>password = <span class="hljs-string">&#x27;123456&#x27;</span>,<br>database = <span class="hljs-string">&#x27;halldb&#x27;</span>,<br>&#125;<br>&#125;,<br>&#123;<br>instance_name = <span class="hljs-string">&quot;hall&quot;</span>,<br>db_conf = &#123;<br>host = <span class="hljs-string">&#x27;127.0.0.1&#x27;</span>,<br>port = <span class="hljs-string">&#x27;3306&#x27;</span>,<br>max_packet_size = <span class="hljs-number">1048576</span>,<br>user = <span class="hljs-string">&#x27;root&#x27;</span>,<br>password = <span class="hljs-string">&#x27;123456&#x27;</span>,<br>database = <span class="hljs-string">&#x27;halldb&#x27;</span>,<br>&#125;<br>&#125;,<br>&#125;<br>&#125;,<br></code></pre></td></tr></table></figure><p>这样就可以配置rpc调用不同的数据库了。<br>之后在实现<code>examples/digitalbomb</code>数字炸弹时发现需要<strong>指定玩家id去映射服务</strong>，还有<strong>外部需要拿服务ID的需求</strong>，于是又扩展了对应函数。</p></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这里就讲解完了，如果有不明白或者觉得不好的地方，欢迎提<strong>issues</strong>。<br>下一遍我准备写一下skynet_fly的配置脚本工具生成。<br><a href="https://github.com/huahua132/skynet_fly">skynetfly源码地址</a></p>]]></content>
    
    
    <categories>
      
      <category>skynet_fly实现思路历程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>skynet_fly实现思路历程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于skynet_fly的一键构建服务配置</title>
    <link href="/2023/06/30/skynet_fly_ss/%E5%85%B3%E4%BA%8Eskynet_fly%E7%9A%84%E4%B8%80%E9%94%AE%E6%9E%84%E5%BB%BA%E6%9C%8D%E5%8A%A1%E9%85%8D%E7%BD%AE/"/>
    <url>/2023/06/30/skynet_fly_ss/%E5%85%B3%E4%BA%8Eskynet_fly%E7%9A%84%E4%B8%80%E9%94%AE%E6%9E%84%E5%BB%BA%E6%9C%8D%E5%8A%A1%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="为什么要做这个？"><a href="#为什么要做这个？" class="headerlink" title="为什么要做这个？"></a>为什么要做这个？</h1><ol><li>skynet启动用的skynet_config新增一个目录都要去增加一个path并重启，我就想有没有办法不用手写<strong>path</strong>，用脚本写。</li><li>热更服务的path如果有新增模块引入，之前没有埋伏路径，增加了新路径，岂不是会找不到，很难受，这样。</li><li>新增一个服务模块每次都有手写一个config好麻烦。</li><li>热更服务需要通过curl连接 debug_console服务去执行热更。</li></ol><p>所以这个事情必须要做。</p><h1 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h1><p>本想着能不能像go-zero框架实现一个类似一键生成工具。但是我觉得这样还要安装一个工具挺麻烦的，就直接用shell+lua的方式来写，自带的环境，方便执行。<br>实现时，不知道使用者要把skynet_fly放在那个文件夹，所有考虑了skynet_fly可以放在同磁盘任意文件夹下。<br>构建一个服务需要在服务根目录执行使用<code>skynet_fly_path/binshell/ skynet_fly_path svr_name thread</code>构建。<br>比如如何是examples&#x2F;webapp,你就需要先cd到examples&#x2F;webapp,执行<code>sh ../../binshell/make_server.sh ../../</code><br>然后就会生成webapp_config.lua script一系列执行脚本。<br>实现细节写在 <code>script</code>和<code>binshell</code>文件夹下。</p><ul><li><strong>关于生成skynet_config</strong><br>path路径生成规则都是由近到远的查找规则， 优先级 本服务svr下文件下 &gt; skynet_fly文件夹 &gt; skynet文件夹</li></ul><ul><li>cpath c服务模块查找 写死<code>skynet_fly_path/cservice/?.so; .. skynet_path/cservice/?.so;</code></li><li>lua_cpath c模块查找 写死<code>skynet_fly_path .. &quot;luaclib/?.so;&quot; .. skynet_path .. &quot;luaclib/?.so;&quot;</code></li><li>luaservice c服务查找 写死server_path .. “?.lua;” ..<br>       server_path .. “service&#x2F;?.lua;” ..<br>       skynet_fly_path .. “service&#x2F;?.lua;” ..<br>       common_path .. “service&#x2F;?.lua;” ..<br>      skynet_path .. “service&#x2F;?.lua;”,</li><li>lua_path 动态生成构建。</li></ul><p> 构建查找规则如下图</p><p><img src="/img/skynet_fly/dir.bmp"><br>以chinese_chess(server)为例。<br>lua_path 查找优先级为:</p><ol><li>递归查找chinese_chess文件夹下非service文件夹</li><li>递归查找common文件夹下非service文件夹</li><li>递归查找skynet_fly&#x2F;lualib</li><li>递归查找skynet_fly&#x2F;3rd</li><li>递归查找skynet_fly&#x2F;skynet&#x2F;lualib</li></ol> <figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">--创建 lua文件 查找规则，优先级 server下非service文件夹 &gt; server上上级目录common文件夹非service文件夹 &gt; skynet_fly lualib下所有文件夹 &gt; skynet lualib下所以文件夹</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">M.create_luapath</span><span class="hljs-params">(skynet_fly_path)</span></span><br><span class="hljs-keyword">local</span> server_path = <span class="hljs-string">&#x27;./&#x27;</span><br><span class="hljs-keyword">local</span> skynet_path = skynet_fly_path .. <span class="hljs-string">&#x27;/skynet&#x27;</span><br><span class="hljs-keyword">local</span> common_path = <span class="hljs-string">&#x27;../../common&#x27;</span><br><br><span class="hljs-comment">--server下非service文件夹</span><br><span class="hljs-keyword">local</span> lua_path = server_path .. <span class="hljs-string">&#x27;?.lua;\n&#x27;</span><br><span class="hljs-keyword">for</span> file_name,file_path,file_info <span class="hljs-keyword">in</span> M.diripairs(server_path) <span class="hljs-keyword">do</span><br><span class="hljs-keyword">if</span> file_info.mode == <span class="hljs-string">&#x27;directory&#x27;</span> <span class="hljs-keyword">and</span> file_name ~= <span class="hljs-string">&#x27;service&#x27;</span> <span class="hljs-keyword">then</span><br>lua_path = lua_path .. file_path .. <span class="hljs-string">&#x27;/?.lua;\n&#x27;</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">--server上上级目录common所有文件夹</span><br>lua_path = lua_path .. common_path .. <span class="hljs-string">&#x27;?.lua;\n&#x27;</span><br><span class="hljs-keyword">for</span> file_name,file_path,file_info <span class="hljs-keyword">in</span> M.diripairs(common_path) <span class="hljs-keyword">do</span><br><span class="hljs-keyword">if</span> file_info.mode == <span class="hljs-string">&#x27;directory&#x27;</span> <span class="hljs-keyword">and</span> file_name ~= <span class="hljs-string">&#x27;service&#x27;</span> <span class="hljs-keyword">then</span><br>lua_path = lua_path .. file_path .. <span class="hljs-string">&#x27;/?.lua;\n&#x27;</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">--skynet_fly lualib下所有文件夹</span><br>lua_path = lua_path .. skynet_fly_path .. <span class="hljs-string">&#x27;/lualib/?.lua;\n&#x27;</span><br><span class="hljs-keyword">for</span> file_name,file_path,file_info <span class="hljs-keyword">in</span> M.diripairs(skynet_fly_path .. <span class="hljs-string">&#x27;/lualib&#x27;</span>) <span class="hljs-keyword">do</span><br><span class="hljs-keyword">if</span> file_info.mode == <span class="hljs-string">&#x27;directory&#x27;</span> <span class="hljs-keyword">then</span><br>lua_path = lua_path .. file_path .. <span class="hljs-string">&#x27;/?.lua;\n&#x27;</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">--skynet_fly 3rd下所以文件夹</span><br><span class="hljs-keyword">for</span> file_name,file_path,file_info <span class="hljs-keyword">in</span> M.diripairs(skynet_fly_path .. <span class="hljs-string">&#x27;/3rd&#x27;</span>) <span class="hljs-keyword">do</span><br><span class="hljs-keyword">if</span> file_info.mode == <span class="hljs-string">&#x27;directory&#x27;</span> <span class="hljs-keyword">then</span><br>lua_path = lua_path .. file_path .. <span class="hljs-string">&#x27;/?.lua;\n&#x27;</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">--skynet lualib下所以文件夹</span><br>lua_path = lua_path .. skynet_path .. <span class="hljs-string">&#x27;/lualib/?.lua;\n&#x27;</span><br><span class="hljs-keyword">for</span> file_name,file_path,file_info <span class="hljs-keyword">in</span> M.diripairs(skynet_path .. <span class="hljs-string">&#x27;/lualib&#x27;</span>) <span class="hljs-keyword">do</span><br><span class="hljs-keyword">if</span> file_info.mode == <span class="hljs-string">&#x27;directory&#x27;</span> <span class="hljs-keyword">then</span><br>lua_path = lua_path .. file_path .. <span class="hljs-string">&#x27;/?.lua;\n&#x27;</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">return</span> lua_path<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p> skynet_fly服务启动时会加载<code>lualib/preload.lua</code>文件，我在那里做了重新构建新的luapath，<strong>再也不用手写path啦</strong>。<br> 同时热更服务也不用担心新加的路径没有写到path中。</p><ul><li><strong>构建运维脚本</strong><br>skynet_fly会生成run.sh,restart.sh,kill_mod.sh,check_reload.sh,stop.sh一系列脚本，方便运维管理。<br>其中run.sh执行之后会生成logrotate的日志切割配置，重命名方式。通过发送hup信号。<br>重点讲一下check_reload.sh</li></ul><p><code>check_reload.sh</code></p><ul><li>检测可热更服务在关闭skynet.codecache之后require的lua模块是否有修改，检测的是文件最后修改时间。</li><li>对比mod_config.lua 和mod_config.lua.old 是否有改变。<br>如果有改动更新对应模块。</li><li>对比mod_config.lua 和mod_config.lua.old 是否有模块配置删除，有的话通知下线。</li></ul><p> 其他脚本都好理解。</p><h1 id="如何使用"><a href="#如何使用" class="headerlink" title=" 如何使用"></a> 如何使用</h1><p>构建一个服务需要在服务根目录执行使用<code>skynet_fly_path/binshell/ skynet_fly_path svr_name thread</code>构建。<br>比如构建examples&#x2F;webapp,你就需要先cd到examples&#x2F;webapp,如何执行<code>sh ../../binshell/make_server.sh ../../</code></p><p>调用 binshell&#x2F;make_server.sh 传入1个参数。<br>skynetfly_path的相对路径。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>后续可能增加一键构建服务模板，一键构建db model等等。<br><a href="https://github.com/huahua132/skynet_fly">skynetfly源码地址</a></p>]]></content>
    
    
    <categories>
      
      <category>skynet_fly实现思路历程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>skynet_fly实现思路历程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于skynet做服务热更新</title>
    <link href="/2023/05/22/think/reload/"/>
    <url>/2023/05/22/think/reload/</url>
    
    <content type="html"><![CDATA[<h1 id="为什么要做热更新"><a href="#为什么要做热更新" class="headerlink" title="为什么要做热更新"></a>为什么要做热更新</h1><p>那当然是因为产品需要更新功能，但是服务功能模块又可以有用户在使用，又不想停止服务又想更新功能，就有了需要热更新的需求。<br><strong>无状态</strong>的服务非常好更新，例如查询服务，直接重启服务也可以，只是出现短暂的服务不可用。更新难的是<strong>有状态</strong>的服务，不能直接重启，重启就可能出现数据丢失了。</p><h1 id="热更方式"><a href="#热更方式" class="headerlink" title="热更方式"></a>热更方式</h1><ul><li><strong>在原本的lua虚拟机中更新</strong><br>这种方式通过重新加载读取_G.package.loaded中的文件，去覆盖旧_env中的数据，要处理好table被引用、全局变量、闭包的upvalue,而且还会出现本身旧状态数据不适应新版本处理函数的情况，比如一个函数检测一个状态的值等不等于一个枚举值，旧版本枚举值等于1，新版本等于2，但是旧版本状态数据是1，这个时候你热更还需要抉择状态数据是用旧的还是要改成新的，而且有些状态数据是运行时玩家之间的API交互产生的结果，比如A玩家击杀了B玩家，B玩家状态是挂了，但是标记挂了的枚举在新版本改了，此时的热更肯定不符合预期，所以这种热更方式只适合更新bug。少量更改人为可预见行为，才使用。</li></ul><p>比如skynet提供的inject注入方式。</p><ul><li><strong>旧服务顶替新服务的方式</strong><br>这种方式处理起来不复杂而且稳定可控性强,有点类似重启服务然后更新,但是我们可以做到无缝衔接,新服务到岗之后再停止旧服务,传统的进程服务,可能就是启动新服务,然后把旧服务流量切换到新服务上面,等服务没有流量以后再关掉旧服务。<br>skynet可以直接在进程内就实现这个需求,skynet服务lua沙盒就像一个一个微小的进程,我们在内部实现一个服务做出服务网关,记录所以可热更服务的地址,服务通过向网关注册时的名字联系,发消息都通过网关,然后我们关闭掉skynet.codecache,服务更新之后网关记录新服务地址，通知旧服务下岗，做到无缝热更。</li></ul><p>不过还需要考虑新服务上线，旧服务还不能下岗的情况，比如一把游戏还没有结束。</p><h2 id="新服务顶替旧服务实现方案的一些思考"><a href="#新服务顶替旧服务实现方案的一些思考" class="headerlink" title="新服务顶替旧服务实现方案的一些思考"></a>新服务顶替旧服务实现方案的一些思考</h2><p>所有方案都是利用关闭掉skynet的code.cache来实现业务代码的热更，过程中抽象三种角色。</p><ul><li><p><strong>客户端</strong><br>  所有需要RPC调用某个可热更服务的服务。</p></li><li><p><strong>热更服务管理员</strong><br>  需要在恰当的时间进行切流，比如新服务启动了，也有可能新服务启动了，暂时不切流（比如一把游戏还没有结束）。</p></li><li><p><strong>可热更服务</strong><br>  新服务启动了，旧服务要考虑在什么时候销毁。</p></li><li><p><strong>方案一</strong><br>  热更服务管理员做网关，<strong>客户端</strong>发消息都通过热更服务管理员转发，热更服务管理员还负责启动新服务和通知旧服务关闭，这也是我在工作中实现并使用的方案。不过有些值得诟病的缺点，比如经过转发的消息从1v1变成了1v1v1,消息从2次打包解包变成3次打包解包，微微增加一点系统开销，还有就是没有提供AB面切流的实现，不方便给有状态的服务进行更新。</p></li><li><p><strong>方案二</strong><br>  热更服务管理员做<strong>配置中心</strong>，<strong>客户端</strong>发消息先尝试调用本地记录地址，如果没有或者失败(服务已经退出)或者下岗，询问<strong>配置中心</strong>要新的地址，<strong>可热更服务</strong>启动需要向<strong>配置中心</strong>注册，新的<strong>可热更新服务</strong>注册后，<strong>配置中心</strong>通知旧的<strong>可热更服务</strong>可以下岗了，旧的<strong>可热更服务</strong>根据自身情况决定什么时候退出。如果是有状态的需要维持到状态结束，这个可以通过<strong>可热更服务</strong>去控制，根据自身情况<strong>反馈</strong>给<strong>客户端</strong>。比如一局游戏还没结束，正常处理请求，结束后用户想开始下一把，此时通知<strong>客户端</strong>我要下岗了，此方案就能解决消息多一次打解包，有状态服务的通讯保持。此方案没有什么诟病的地方有点类似redis切片集群方案，一个key不在这个redis节点，通知客户端move到目标节点地址，可以考虑配置中心通知旧服务下岗时接收一下新服务地址，到时候客户发消息过来，如果要<strong>move</strong>就可以直接<strong>切换地址</strong>，不需要向配置中心要了。</p><p>  <a href="https://github.com/huahua132/skynet_fly">方案二实现</a><br>  实现过程中，发现方案二有2个问题</p><ul><li><strong>问题一</strong><br>  给可热更服务发消息必须用call，不能用send，因为<strong>可热更服务</strong>需要<strong>反馈</strong>自身状态。稍微有点影响性能，但是比方案一还是要好。</li><li><strong>问题二</strong><br>  客户缓存的旧地址长时间不访问，过了一段时间再访问，地址的目标服务可能已经<strong>更替</strong>了,不过这种情况要<code>uint32</code>自增的id走了一个轮回,如果机器上是4字节的话,也就是已经新建了<code>16777215(0x00ffffff)</code>个服务,才有可能重用服务id,虽然很难出现,但是还是要处理这种情况,这里考虑🤔加个版本号加模块名的<strong>校验</strong>。(测试的时候改下skynet源码的服务id分配，比如id到100就轮转),实现并增加了测试代码<strong>hot_module3</strong>。</li></ul></li><li><p><strong>方案三</strong><br>  热更服务管理员还是做配置中心，<strong>客户端</strong>发消息用本地记录地址，如果没有<strong>客户端</strong>只要询问一次配置中心地址，然后通过sub&#x2F;pub机制更新新服务地址，此时就会有一个问题，客户拥有新，旧地址，需要考虑需不需要继续和旧地址通信，此时从方案二的服务切流变成客户切流。<br>  <a href="https://github.com/huahua132/skynet_fly">方案三实现</a><br>  方案三的好处就是解决了方案二每次使用call的问题。</p><ul><li><strong>客户端</strong>自己决定什么时候切换到新服务(一般就是状态结束了切换)</li><li><strong>服务</strong> 服务就是看自己什么时候退出(一般就是没有用户状态了退出)</li></ul></li></ul><h1 id="关闭codecache的性能影响测试"><a href="#关闭codecache的性能影响测试" class="headerlink" title="关闭codecache的性能影响测试"></a>关闭codecache的性能影响测试</h1><p>skynet.codecache开启状态是把加载(require )过得lua代码文件缓存到内存，下次其他服务再加载的时候就直接用缓存就行，不需要再去读取代码文件了。<br>我们利用关闭掉codecache来实现热更只会稍微影响新服务启动的速度。<br>    <a href="https://github.com/huahua132/skynet_fly">code_cache_test</a></p><pre><code class="hljs">cache情况下启动1万个服务需要2.65s关闭cache情况下启动1万个服务需要3.69s通过测试，新服务的启动速度下降28%，影响不大。</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过多方案的实现分析，最终确定<strong>方案三</strong>在性能和灵活性上面最具优势，后续决定在方案三的基础上补充，一键检测热更功能（有变动才热更）。</p>]]></content>
    
    
    <categories>
      
      <category>一些想法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>一些想法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>平衡二叉树的lua实现</title>
    <link href="/2023/05/21/data_struct/avltree/"/>
    <url>/2023/05/21/data_struct/avltree/</url>
    
    <content type="html"><![CDATA[<h1 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h1><ul><li><strong>有序性</strong> 所以结点都是<strong>左子树比自己小，右子树比自己大</strong>。</li><li><strong>平衡性</strong> 所以结点左右子树<strong>高度差绝对值</strong>小于等于一。</li><li><strong>唯一性</strong> 结点key唯一，不能重复。</li></ul><p><img src="/img/data_struct/avltree.png"></p><h1 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h1><ul><li><strong>适合有序性数据存储</strong> 二叉树的天然有序性</li><li><strong>适合范围查找</strong>基于有序的范围查找时间复杂度为<strong>o(log n) + m</strong></li></ul><h1 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h1><ul><li><strong>内存地址分散</strong> 每个结点都是独立数据块，存储<strong>地址分散</strong>，操作速度非常依赖<strong>存储设备的寻址速度</strong>，基于机械硬盘运行将会非常慢。</li></ul><h1 id="操作时间复杂度"><a href="#操作时间复杂度" class="headerlink" title="操作时间复杂度"></a>操作时间复杂度</h1><ul><li><strong>插入，查询，删除</strong> 时间复杂度都是<strong>o(log n)</strong></li></ul><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>通过动手实现一个平衡二叉树，加深对平衡二叉树的了解，其实二年前用C++也实现过，所以这次想尝试用lua实现，发现用lua实现和用c++实现的区别是，在删除和增加结点的的时候，因为c++有指针，所以可以直接这样写 <code>node = new(tree_node)</code>,lua<br>没有就只能<code>parent.left = new(tree_node)</code>，所以递归函数传参需要把父节点的table传递进入，而c++只需要传递父节点成员的指针引用或者二级指针，实现的时候一定要理清逻辑，脑子里想不明白的时候就画图，特别注意别出现环引用。</p><p>一个平衡二叉树包含基本插入，删除，查询三个API,lua的实现我增加了一个range范围查询的API。</p><h2 id="结构定义"><a href="#结构定义" class="headerlink" title="结构定义"></a>结构定义</h2><p>标准的二叉树定义,左右子结点，结点高度，k,v值，基于k有序。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">new_node</span><span class="hljs-params">(k,v)</span></span><br><span class="hljs-keyword">return</span> &#123;<br>left = <span class="hljs-literal">nil</span>,<br>right = <span class="hljs-literal">nil</span>,<br>depth = <span class="hljs-number">1</span>,<br>k = k,<br>v = v,<br>&#125;<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><p>开胃菜查询，查询是平衡二叉树里面最简单的,根据k值决定是去左边找还是右边找，类似二分查找。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">find_node</span><span class="hljs-params">(node,k)</span></span><br><span class="hljs-keyword">if</span> node.k == k <span class="hljs-keyword">then</span><br><span class="hljs-keyword">return</span> node.v<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">if</span> node.k &gt; k <span class="hljs-keyword">then</span><br><span class="hljs-keyword">if</span> node.left <span class="hljs-keyword">then</span><br><span class="hljs-keyword">return</span> find_node(node.left,k)<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">if</span> node.right <span class="hljs-keyword">then</span><br><span class="hljs-keyword">return</span> find_node(node.right,k)<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>比例下图👇查找4,<strong>路径</strong>就是root[5]-&gt;left[3]-&gt;right[4]<br><img src="/img/data_struct/alvtreefind.png"></p><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>普通的二叉树插入也非常简单，跟查询一样的寻路，找到空的树枝挂上去就行。平衡二叉树就需要操作平衡调整。<br>为什么要做平衡操作，试想一下，普通二叉树我们插入1到10，会一直插入到最右边的结点，就会退化成链表了。</p><p><img src="/img/data_struct/alvtreelist.png"></p><p>此时的二叉树就跟链表差不多，查询，插入，删除基本上就是o(n)的时间复杂度了。<br>我们再看看平衡二叉树。</p><p><img src="/img/data_struct/alvtreeba.png"></p><ul><li><strong>失衡</strong> 所以结点左右子树<strong>高度差绝对值</strong>小于等于一。</li><li><strong>检测失衡</strong> 插入结点经过的路径结点都需要检测。<strong>按照压栈的顺序执行，先入后出</strong>。</li><li><strong>更新树高</strong> 插入结点经过的路径结点都需要更新树高，<strong>检测失衡前要先更新树高，按照压栈的顺序执行，先入后出</strong>。</li></ul><p>插入结点3后，树<strong>失衡</strong>，此时对二叉树进行<strong>左旋调整</strong>，插入结点4，5后又再次<strong>失衡</strong>，再次进行<strong>左旋调整</strong>。<br>这里我提到了<strong>左旋调整</strong>，<strong>右旋调整</strong>，我们需要列出树的<strong>失衡</strong>状态，根据失衡的定义我们可以列出如下<strong>6种失衡4种调整</strong>。</p><p><img src="/img/data_struct/alvtreero.png"></p><p>我们只需要实现<strong>左旋调整</strong>和<strong>右旋调整</strong>，<strong>先左后右</strong>和<strong>先右后左</strong>就是调用左、右调整，只不过是先调整子节点，再调整父节点。</p><p>我们以左旋调整为例，看图。</p><p><img src="/img/data_struct/alvtreeroch.png"></p><p>调整过程我们需要改变3个指针指向。</p><ul><li><strong>父指针</strong> 从指向<strong>自身</strong>改为指向<strong>右子节点</strong>(从指向1改为指向3)</li><li><strong>自身右指针</strong> 从指向<strong>自身右子节点</strong>改为指向<strong>右子节点的左子节点</strong>(从指向3改为指向2)</li><li><strong>右子结点左指针</strong> 从指向<strong>右子节点左子结点</strong>改为指向<strong>自身</strong>(从指向2改为指向1)</li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">--获取高度</span><br><span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">get_depth</span><span class="hljs-params">(node)</span></span><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node <span class="hljs-keyword">then</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">return</span> node.depth<br><span class="hljs-keyword">end</span><br><span class="hljs-comment">--更新高度</span><br><span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">update_depth</span><span class="hljs-params">(node)</span></span><br><span class="hljs-keyword">local</span> l_depth = get_depth(node.left)<br><span class="hljs-keyword">local</span> r_depth = get_depth(node.right)<br>node.depth = l_depth &gt; r_depth <span class="hljs-keyword">and</span> l_depth + <span class="hljs-number">1</span> <span class="hljs-keyword">or</span> r_depth + <span class="hljs-number">1</span><br><span class="hljs-keyword">end</span><br><span class="hljs-comment">--获取平衡值</span><br><span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">get_node_balance</span><span class="hljs-params">(node)</span></span><br><span class="hljs-keyword">local</span> l_depth = get_depth(node.left)<br><span class="hljs-keyword">local</span> r_depth = get_depth(node.right)<br><span class="hljs-keyword">return</span> l_depth - r_depth<br><span class="hljs-keyword">end</span><br><span class="hljs-comment">--左旋</span><br><span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ll_rotate</span><span class="hljs-params">(parent,node)</span></span><br><span class="hljs-keyword">local</span> son = node.right<br><span class="hljs-comment">--父指针change</span><br><span class="hljs-keyword">if</span> parent.root <span class="hljs-keyword">then</span><br>parent.root = son<br><span class="hljs-keyword">elseif</span> parent.left == node <span class="hljs-keyword">then</span><br>parent.left = son<br><span class="hljs-keyword">else</span><br>parent.right = son<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">local</span> son_l = son.left<br><span class="hljs-comment">--右子结点左指针change</span><br>node.right.left = node<br><span class="hljs-comment">--自身右指针change</span><br>node.right = son_l<br><span class="hljs-comment">--更新结点高度</span><br>update_depth(node)<br>update_depth(son)<br><span class="hljs-keyword">end</span><br><span class="hljs-comment">--右旋</span><br><span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">rr_rotate</span><span class="hljs-params">(parent,node)</span></span><br><span class="hljs-keyword">local</span> son = node.left<br><span class="hljs-comment">--父指针change</span><br><span class="hljs-keyword">if</span> parent.root <span class="hljs-keyword">then</span><br>parent.root = son<br><span class="hljs-keyword">elseif</span> parent.left == node <span class="hljs-keyword">then</span><br>parent.left = son<br><span class="hljs-keyword">else</span><br>parent.right = son<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">local</span> son_r = son.right<br><span class="hljs-comment">--左子结点右指针change</span><br>node.left.right = node<br><span class="hljs-comment">--自身右指针change</span><br>node.left = son_r<br><span class="hljs-comment">--更新结点高度</span><br>update_depth(node)<br>update_depth(son)<br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">--先左后右</span><br><span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">lr_rotate</span><span class="hljs-params">(parent,node)</span></span><br>ll_rotate(node,node.left)<br>rr_rotate(parent,node)<br><span class="hljs-keyword">end</span><br><span class="hljs-comment">--先右后左</span><br><span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">rl_rotate</span><span class="hljs-params">(parent,node)</span></span><br>rr_rotate(node,node.right)<br>ll_rotate(parent,node)<br><span class="hljs-keyword">end</span><br><span class="hljs-comment">--左边失衡</span><br><span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">balance_left</span><span class="hljs-params">(parent,node)</span></span><br><span class="hljs-keyword">local</span> l_balance = get_node_balance(node.left)<br><span class="hljs-keyword">if</span> l_balance &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">then</span><br>rr_rotate(parent,node)<br><span class="hljs-keyword">else</span><br>lr_rotate(parent,node)<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><span class="hljs-comment">--右边失衡</span><br><span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">balance_right</span><span class="hljs-params">(parent,node)</span></span><br><span class="hljs-keyword">local</span> r_balance = get_node_balance(node.right)<br><span class="hljs-keyword">if</span> r_balance &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">then</span><br>rl_rotate(parent,node)<br><span class="hljs-keyword">else</span><br>ll_rotate(parent,node)<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><span class="hljs-comment">--检测失衡并调整</span><br><span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">avl_node</span><span class="hljs-params">(parent,node)</span></span><br><span class="hljs-keyword">local</span> balance = get_node_balance(node)<br><span class="hljs-keyword">if</span> balance &gt; <span class="hljs-number">1</span> <span class="hljs-keyword">then</span><br>balance_left(parent,node)<br><span class="hljs-keyword">elseif</span> balance &lt; <span class="hljs-number">-1</span> <span class="hljs-keyword">then</span><br>balance_right(parent,node)<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add_node</span><span class="hljs-params">(parent,node,k,v)</span></span><br><span class="hljs-keyword">if</span> node.k == k <span class="hljs-keyword">then</span><br><span class="hljs-keyword">return</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">if</span> node.k &gt; k <span class="hljs-keyword">then</span><br><span class="hljs-keyword">if</span> node.left <span class="hljs-keyword">then</span><br>add_node(node,node.left,k,v)<br><span class="hljs-keyword">else</span><br>node.left = new_node(k,v)<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">if</span> node.right <span class="hljs-keyword">then</span><br>add_node(node,node.right,k,v)<br><span class="hljs-keyword">else</span><br>node.right = new_node(k,v)<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br>update_depth(node)<br>avl_node(parent,node)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>完整的插入过程可以分为2个步骤，按照压栈的过程，先入后出。</p><ul><li><strong>进</strong> 进的时候栈会记录<strong>路径</strong>。</li><li><strong>出</strong> 把路过的结点进行<strong>更新树高</strong>和<strong>检测失衡和调整失衡</strong>。</li></ul><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>删除结点有4种情况需要考虑🤔</p><ol><li><strong>叶子结点</strong> 没有左右子结点的，直接删除就行。</li><li><strong>仅有左子结点</strong> 让父节点继承。</li><li><strong>仅有右子结点</strong> 让父节点继承。</li><li><strong>左右子结点都有</strong> <strong>中序遍历</strong>遍历的前继或者后继结点代替自己。</li></ol><p><strong>如何找前继或者后继结点</strong><br>如图，我们看下<strong>中序遍历</strong>结点的位置情况。<br><img src="/img/data_struct/alvtreedel.png"></p><ul><li><strong>前继结点位置</strong> <strong>左结点</strong>或者左节点的<strong>最右</strong>结点。</li><li><strong>后继结点位置</strong> <strong>右结点</strong>或者右节点的<strong>最左</strong>结点。</li></ul><p>删除结点的过程中我们不能忘了把路过的结点进行更新<strong>更新树高</strong>和<strong>检测失衡和调整失衡</strong>。<br>删除比较特殊的是删除<strong>左右子结点都有</strong>的结点时，会进行<strong>前继结点位置</strong>或者<strong>后继结点位置</strong>位置的深入，这个路径的结点都需要<strong>更新树高</strong>。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">del_node</span><span class="hljs-params">(parent,node,k,v)</span></span><br><span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">del</span><span class="hljs-params">(p,n,next)</span></span><br><span class="hljs-keyword">if</span> p.root <span class="hljs-keyword">then</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">next</span> <span class="hljs-keyword">then</span><br>p.root = <span class="hljs-built_in">next</span><br><span class="hljs-keyword">else</span><br>p.root = <span class="hljs-literal">nil</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">elseif</span> p.left == n <span class="hljs-keyword">then</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">next</span> <span class="hljs-keyword">then</span><br>p.left = <span class="hljs-built_in">next</span><br><span class="hljs-keyword">else</span><br>p.left = <span class="hljs-literal">nil</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">next</span> <span class="hljs-keyword">then</span><br>p.right = <span class="hljs-built_in">next</span><br><span class="hljs-keyword">else</span><br>p.right = <span class="hljs-literal">nil</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">local</span> res = <span class="hljs-literal">false</span><br><span class="hljs-keyword">if</span> node.k == k <span class="hljs-keyword">then</span><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node.left <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> node.right <span class="hljs-keyword">then</span><br>del(parent,node)<br><span class="hljs-keyword">elseif</span> <span class="hljs-keyword">not</span> node.left <span class="hljs-keyword">then</span><br>del(parent,node,node.right)<br>node.right = <span class="hljs-literal">nil</span><br><span class="hljs-keyword">elseif</span> <span class="hljs-keyword">not</span> node.right <span class="hljs-keyword">then</span><br>del(parent,node,node.left)<br>node.left = <span class="hljs-literal">nil</span><br><span class="hljs-keyword">else</span><br><span class="hljs-comment">--找node在中序遍历的前继节点或者后继节点</span><br><span class="hljs-comment">--我这里找前继,前继结点是左节点或者左节点的最右节点</span><br><span class="hljs-keyword">local</span> pp_node = <span class="hljs-literal">nil</span><br><span class="hljs-keyword">local</span> pre_node = node.left<br><span class="hljs-keyword">while</span> pre_node.right <span class="hljs-keyword">do</span><br>pp_node = pre_node<br>pre_node = pre_node.right<br><span class="hljs-keyword">end</span><br>del(parent,node,pre_node)<br>pre_node.right = node.right<br>node.right = <span class="hljs-literal">nil</span><br><span class="hljs-keyword">if</span> pp_node <span class="hljs-keyword">then</span><br>pp_node.right = pre_node.left<br>pre_node.left = node.left<br><span class="hljs-keyword">end</span><br><br>node.left = <span class="hljs-literal">nil</span><br><br><span class="hljs-keyword">local</span> uplist = &#123;pre_node&#125;<br><span class="hljs-keyword">local</span> unode = pre_node.left<br><span class="hljs-keyword">while</span> unode <span class="hljs-keyword">do</span><br><span class="hljs-built_in">table</span>.<span class="hljs-built_in">insert</span>(uplist,unode)<br>unode = unode.right<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">for</span> i = #uplist,<span class="hljs-number">1</span>,<span class="hljs-number">-1</span> <span class="hljs-keyword">do</span><br>update_depth(uplist[i])<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">if</span> node.k &gt; k <span class="hljs-keyword">then</span><br><span class="hljs-keyword">if</span> node.left <span class="hljs-keyword">then</span><br>res = del_node(node,node.left,k,v)<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">if</span> node.right <span class="hljs-keyword">then</span><br>res = del_node(node,node.right,k,v)<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">if</span> res <span class="hljs-keyword">then</span><br>update_depth(node)<br>avl_node(parent,node)<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">return</span> res<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h2 id="范围查询"><a href="#范围查询" class="headerlink" title="范围查询"></a>范围查询</h2><p>范围查询需要注意的是要用中序遍历，保证结果的有序性就行了。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">find_by_range</span><span class="hljs-params">(node,b_key,e_key,res_list)</span></span><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node <span class="hljs-keyword">then</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">if</span> node.left <span class="hljs-keyword">and</span> b_key &lt; node.k <span class="hljs-keyword">then</span><br>find_by_range(node.left,b_key,e_key,res_list)<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">if</span> node.k &gt;= b_key <span class="hljs-keyword">and</span> node.k &lt;= e_key <span class="hljs-keyword">then</span><br><span class="hljs-built_in">table</span>.<span class="hljs-built_in">insert</span>(res_list,node.k)<br><span class="hljs-built_in">table</span>.<span class="hljs-built_in">insert</span>(res_list,node.v)<br><span class="hljs-keyword">end</span> <br><br><span class="hljs-keyword">if</span> node.right <span class="hljs-keyword">and</span> e_key &gt; node.k <span class="hljs-keyword">then</span><br>find_by_range(node.right,b_key,e_key,res_list)<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a><a href="https://github.com/huahua132/lua_test">完整代码</a></h1><p>觉得写得不错，给个星星，非常感谢O(∩_∩)O哈哈~</p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>链接记录</title>
    <link href="/2023/05/21/think/link/"/>
    <url>/2023/05/21/think/link/</url>
    
    <content type="html"><![CDATA[<p>链接记录</p><p>床长人工智能教程<br><a href="https://captainbed.vip/login/">https://captainbed.vip/login/</a></p><p><a href="https://datuchat.com/">https://datuchat.com/</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络七层模型</title>
    <link href="/2023/05/14/socket/c/"/>
    <url>/2023/05/14/socket/c/</url>
    
    <content type="html"><![CDATA[<ul><li><strong>7层</strong> 物理层，数据链路层，网络层，传输层，会话层，表示层，应用层</li><li><strong>5层</strong> 物理层，数据链路层，网络层，传输层，应用层</li><li><strong>4层</strong> 网络接口层，网络层，传输层，应用层</li></ul><p><strong>物理层</strong><br>    传输介质，网线，光纤<br><strong>数据链路层</strong><br>    保持数据的可靠传输<br><strong>网络层</strong><br>    数据路由，ip地址<br><strong>传输层</strong><br>    tcp，udp协议，数据打包<br><strong>会话层</strong><br>    建立与管理应用程序之间的通信<br><strong>表示层</strong><br>    解决不同系统的兼容问题<br><strong>应用层</strong><br>    http，ftp</p>]]></content>
    
    
    <categories>
      
      <category>socket</category>
      
    </categories>
    
    
    <tags>
      
      <tag>socket</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>select,poll,epoll 对比</title>
    <link href="/2023/05/14/socket/epoll/"/>
    <url>/2023/05/14/socket/epoll/</url>
    
    <content type="html"><![CDATA[<h1 id="最大链接数"><a href="#最大链接数" class="headerlink" title="最大链接数"></a>最大链接数</h1><ul><li><strong>select</strong> 有上限FD_SETSIZE设置</li><li><strong>poll</strong> 链表实现，没有上限</li><li><strong>epoll</strong> 没有上限</li></ul><h1 id="fd剧增带来的io效率问题"><a href="#fd剧增带来的io效率问题" class="headerlink" title="fd剧增带来的io效率问题"></a>fd剧增带来的io效率问题</h1><ul><li><strong>select</strong> 轮询机制， o(n)复杂度</li><li><strong>poll</strong> 轮询机制，o(n)复杂度</li><li><strong>epoll</strong> 事件通知机制，o(1)复杂度</li></ul><h1 id="消息传递方式"><a href="#消息传递方式" class="headerlink" title="消息传递方式"></a>消息传递方式</h1><ul><li><strong>select</strong> 完整拷贝</li><li><strong>poll</strong> 完整拷贝</li><li><strong>epoll</strong> 通过内核与用户空间共享内存来实现</li></ul><h1 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h1><ul><li><strong>select</strong> LT</li><li><strong>poll</strong> LT</li><li><strong>epoll</strong> LT水平触发，ET边缘触发</li></ul><h1 id="LT"><a href="#LT" class="headerlink" title="LT"></a>LT</h1><ul><li>读缓存区不为空，就会一直触发可读事件</li><li>写缓冲区不满，触发可写事件</li></ul><h1 id="ET"><a href="#ET" class="headerlink" title="ET"></a>ET</h1><ul><li>读缓存区由空转为非空，触发可读事件</li><li>写缓存区由满转为不满，触发可写事件</li></ul>]]></content>
    
    
    <categories>
      
      <category>socket</category>
      
    </categories>
    
    
    <tags>
      
      <tag>socket</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>tcp知识整理</title>
    <link href="/2023/05/14/socket/tcp/"/>
    <url>/2023/05/14/socket/tcp/</url>
    
    <content type="html"><![CDATA[<h1 id="三次握手过程"><a href="#三次握手过程" class="headerlink" title="三次握手过程"></a>三次握手过程</h1><ul><li><strong>第一次握手</strong> 客户端发送建立链接请求报文SYN携带(SYN &#x3D; 1,seq &#x3D; x)后，进入SYN_SENT状态。</li><li><strong>第二次握手</strong> 服务端接收到SYN报文后回复SYN+ACK报文携带(ACK&#x3D;x+1,SYN&#x3D;1,seq&#x3D;y)，进入SYN_RECV状态。</li><li><strong>第三次握手</strong> 客户端收到SYN+ACK报文后回复ACK报文携带(ACK&#x3D;y+1,SYN&#x3D;1)。</li></ul><h1 id="为什么需要三次握手"><a href="#为什么需要三次握手" class="headerlink" title="为什么需要三次握手"></a>为什么需要三次握手</h1><ol><li><p><strong>确保双方读写都正常</strong>。<br> 第一次确定客户端发送正常，第二次确定服务端发送和接送正常，第三次确定客户端接收正常。</p></li><li><p><strong>同步双方初始序列号</strong>。<br> 序列号可以保证消息的发送是有序的。</p></li></ol><h1 id="四次挥手过程"><a href="#四次挥手过程" class="headerlink" title="四次挥手过程"></a>四次挥手过程</h1><ul><li><strong>第一次挥手</strong> 主动断开方发送FIN报文，进入FIN_WAIT_1状态。</li><li><strong>第二次挥手</strong> 被动断开方接收FIN报文后，回复ACK报文，进入CLOSE_WAIT状态。主动断开方接送ACK报文后进入FIN_WAIT_2状态。</li><li><strong>第三次挥手</strong> 被动断开方发送FIN报文后，进入LASTACK状态。</li><li><strong>第四次挥手</strong> 主动断开方发送ACK报文后进入TIME_WAIT状态，等待2MLS后进入closed阶段，被动端口方接收后进入closed阶段。</li></ul><p>MLS表示报文在网络中最大存活时间，1MLS等于2分钟</p><h1 id="为什么需要四次挥手"><a href="#为什么需要四次挥手" class="headerlink" title="为什么需要四次挥手"></a>为什么需要四次挥手</h1><p>因为tcp是全双工的，双方能同时发送，接收消息。<br>所以客户端第一次挥手发送FIN只能确定客户端没有数据发送了，服务端可能还有数据发送给客户端。所以需要服务器接收到FIN之后回复ACK，等服务端没有数据要发送时，再发送FIN给客户端来表示可以关闭。</p><h1 id="为什么要进入time-wait状态"><a href="#为什么要进入time-wait状态" class="headerlink" title="为什么要进入time_wait状态"></a>为什么要进入time_wait状态</h1><p>为了响应服务端重发FIN报文，回复的ACK报文可能丢失，避免服务端重发FIN报文影响新连接。</p>]]></content>
    
    
    <categories>
      
      <category>socket</category>
      
    </categories>
    
    
    <tags>
      
      <tag>socket</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redis 知识杂谈</title>
    <link href="/2023/05/13/redis/redis/"/>
    <url>/2023/05/13/redis/redis/</url>
    
    <content type="html"><![CDATA[<h1 id="redis有哪些好处？"><a href="#redis有哪些好处？" class="headerlink" title="redis有哪些好处？"></a>redis有哪些好处？</h1><ol><li><p>数据类型丰富，提供了string,list,hash,set,zset五种基础类型，还提供了stream，geo，bitmap扩展类型<br>string<br>数据结构：简单动态字符串<br>list<br>数据结构：双向链表，压缩列表<br>hash<br>压缩列表，哈希表<br>zset<br>压缩列表，跳表<br>set<br>哈希表，整数数组</p></li><li><p>数据可以设置过期时间</p></li><li><p>支持事务</p></li><li><p>支持脚本化运行</p></li><li><p>哈希冲突解决<br> 少量的冲突redis使用链式哈希解决，当链表过长时redis会触发rehash机制，rehash机制会增加现有hash桶的数量，分散entry元素</p></li></ol><ul><li><p><strong>rehash机制</strong><br>  redis有两张全局hash表，hash1,hash2，起初hash2没有分配空间<br>  当触发rehash时：<br>  会给hash2分配更大的空间，重设hash函数，增加hash桶总量，把hash1重新映射到hash2，释放hash1</p></li><li><p><strong>渐进式rehash机制</strong><br>  由于rehash机制非常耗时，会阻塞redis<br>  所以将集中迁移改为分散迁移，当处理一个请求时，就从hash1中的第一个索引位置开始，把位置1的所以entries重新映射到hash2中。</p></li></ul><h1 id="单线程的redis为什么这么快？"><a href="#单线程的redis为什么这么快？" class="headerlink" title=" 单线程的redis为什么这么快？"></a> 单线程的redis为什么这么快？</h1><ol><li>首先redis并不是真正意义上的单线程，比如持久化，异步删除，集群同步，都是用额外的线程完成的</li><li>为什么不用多线程，多线程访问共享资源，需要增加额度的机制，就会带来额外的开销</li><li>redis大部分操作都是在内存中完成，加上采用的高效的数据结构，例如hash表，跳表</li><li>redis采用多路复用机制，使其能够并发处理大量客户端请求</li></ol><h1 id="数据同步：主从库如何实现数据同步？"><a href="#数据同步：主从库如何实现数据同步？" class="headerlink" title="数据同步：主从库如何实现数据同步？"></a>数据同步：主从库如何实现数据同步？</h1><h2 id="redis具有高可用，是什么意思？"><a href="#redis具有高可用，是什么意思？" class="headerlink" title="redis具有高可用，是什么意思？"></a>redis具有高可用，是什么意思？</h2><p>二层意思，一是数据尽量少丢失，二是服务尽量少中断，AOF和RDB保证了一，对于二redis通过增加冗余副本量。</p><h2 id="redis提供了主从库模式，以保证数据副本的一致，主从库采用了"><a href="#redis提供了主从库模式，以保证数据副本的一致，主从库采用了" class="headerlink" title="redis提供了主从库模式，以保证数据副本的一致，主从库采用了"></a>redis提供了主从库模式，以保证数据副本的一致，主从库采用了</h2><p>读写分离的方式。</p><ul><li><strong>读操作：</strong> 主库，从库都可以接送。</li><li><strong>写操作：</strong> 只有主库能接收执行，然后主库同步给从库执行。</li></ul><h2 id="第一次如何同步？"><a href="#第一次如何同步？" class="headerlink" title="第一次如何同步？"></a>第一次如何同步？</h2><p>从库和主库建立连接后，会与主库协商第一次全量同步，主库会进行RDB内存快照和传输RDB内存快照。</p><h2 id="多个副本怎么分担主库全量复制压力？"><a href="#多个副本怎么分担主库全量复制压力？" class="headerlink" title="多个副本怎么分担主库全量复制压力？"></a>多个副本怎么分担主库全量复制压力？</h2><p>采用主-从-从模式</p><h2 id="全量复制完了之后如何同步？"><a href="#全量复制完了之后如何同步？" class="headerlink" title="全量复制完了之后如何同步？"></a>全量复制完了之后如何同步？</h2><p>基于长链接的命令传播</p><h2 id="主从库网络断开怎么办？"><a href="#主从库网络断开怎么办？" class="headerlink" title="主从库网络断开怎么办？"></a>主从库网络断开怎么办？</h2><p>主库会维护一个repl_backlog_buffer环状缓冲区，主库会记录自己写到的位置，从库会记录自己读到的位置，<br>当网络重连后主库会把master_rpl_offset 到 slave_repl_offset之间的命令同步到从库，</p><p>由于是环状的缓存区，当从库的同步速度小于主库的写入，当主库赶上从库就会需要重新进行全量复制。<br>常规的避免办法是增加repl_backlog_buffer缓存区容量。设置repl_backlog_size。</p><h1 id="哨兵机制，主库挂了，如何不间断服务？"><a href="#哨兵机制，主库挂了，如何不间断服务？" class="headerlink" title="哨兵机制，主库挂了，如何不间断服务？"></a>哨兵机制，主库挂了，如何不间断服务？</h1><h2 id="哨兵三大功能-监控，选主，通知"><a href="#哨兵三大功能-监控，选主，通知" class="headerlink" title="哨兵三大功能   监控，选主，通知"></a>哨兵三大功能   监控，选主，通知</h2><ol><li><strong>监控</strong>主库运行状态，并判断主库是否客观下线。</li><li>主库客观下线，<strong>选择新主库</strong>。</li><li>选出新主库，<strong>通知</strong>从库和客户端。</li></ol><h2 id="细节要点"><a href="#细节要点" class="headerlink" title="细节要点"></a>细节要点</h2><ol><li>哨兵的本质是一个redis实例。</li><li>哨兵通过心跳检测，监控主库状态，主库下线分为客观下线和主观下线。</li><li>哨兵监控是可能误判的，所以一般要集群部署，减少误判率。</li><li>选定主库先筛选打分，得分高的会被选为新主库。</li><li><strong>筛选规则：</strong> 从库的网络状况，之前与主库的连接状况，筛选中断标准可以配置。</li><li><strong>打分规则：</strong> 从库的优先级，数据同步状况，id号大小。</li></ol><h2 id="哨兵集群，哨兵挂了，主库还能切换吗？"><a href="#哨兵集群，哨兵挂了，主库还能切换吗？" class="headerlink" title="哨兵集群，哨兵挂了，主库还能切换吗？"></a>哨兵集群，哨兵挂了，主库还能切换吗？</h2><p>哨兵挂的数量少于<strong>quorum</strong>就可以，至少有<strong>2</strong>个哨兵才能执行主从切换。</p><ol><li>基于pub&#x2F;sub机制的哨兵集群组成过程。</li><li>基于INFO命令的从库列表，帮助哨兵与从库建立连接。</li><li>基于哨兵自身的pub&#x2F;sub功能，实现客户端和哨兵之间的事件通知。</li><li>判断主库客观下线需要投票，需要同意票数大于querum数量。</li><li>通过选举投票方式选出哨兵leader，执行主库切换通知。</li><li>要保证所以哨兵实例的配置是一致的，尤其是主观下线的判断值<strong>down-after-millseconds</strong>。</li></ol><h2 id="频道事件："><a href="#频道事件：" class="headerlink" title="频道事件："></a>频道事件：</h2><ul><li><strong>+sdown：</strong> 主观下线</li><li><strong>-sdown：</strong> 退出主观下线</li><li><strong>+odown：</strong> 客观下线</li><li><strong>-odown：</strong> 退出客观下线</li><li><strong>+slave-reconf-sent：</strong> 哨兵发送slaveof命令重新配置从库</li><li><strong>+slave-reconf-inprog：</strong> 从库配置成新主库 同步中</li><li><strong>+slave-reconf-done：</strong> 从库配置成新主库 完成同步</li><li><strong>+switch-mater：</strong> 主库地址发生变化</li></ul><h1 id="数据量增多了，是该加内存还是该加实例？"><a href="#数据量增多了，是该加内存还是该加实例？" class="headerlink" title="数据量增多了，是该加内存还是该加实例？"></a>数据量增多了，是该加内存还是该加实例？</h1><h2 id="当数据量增大时，通常会有两种选择"><a href="#当数据量增大时，通常会有两种选择" class="headerlink" title="当数据量增大时，通常会有两种选择"></a>当数据量增大时，通常会有两种选择</h2><ul><li><strong>纵向扩展：</strong>加内存</li><li><strong>横向扩展：</strong>加实例</li></ul><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><ul><li><strong>纵向扩展：</strong><br>  <strong>优点：</strong> 实施简单，直接<br>  <strong>缺点：</strong> RDB时间长，硬件以及成本有上限</li><li><strong>横向扩展：</strong><br>  <strong>优点：</strong> 没有硬件和成本限制<br>  <strong>缺点：</strong> 增加系统了复杂度</li></ul><h2 id="切片集群数据该存哪儿？"><a href="#切片集群数据该存哪儿？" class="headerlink" title="切片集群数据该存哪儿？"></a>切片集群数据该存哪儿？</h2><p>redis cluster官方解决方案采用哈希槽，hash-slot，一个切片集群共有16384个哈希槽。<br>通过CRC16算法计算出一个16bit的值，然后取模16384得到对应哈希槽。<br>redis cluster根据实例数量平均分配哈希槽，也可以通过cluster meet,cluster addslots手动配置搭建。<br>手动配置需要把16384个槽分配完，否则无法工作。</p><h2 id="客户端如何定位数据？"><a href="#客户端如何定位数据？" class="headerlink" title="客户端如何定位数据？"></a>客户端如何定位数据？</h2><p>切片集群会共享各自的哈希槽信息，客户端与实例建立连接时，会把哈希槽的信息发送给客户端。<br>但是在集群新增或者减少实例的时候，redis需要重新分配哈希槽。 还有为了负载均衡，redis需要把哈希槽所有实例重新分配一遍，这就可能带来客户端哈希槽信息与服务器不一致的问题。<br>    这时redis cluster 方案提供了一种重定向机制，客户端给一个实例发送读写操作时，数据槽不在这个实例，需要重定向发送到另一个实例。<br>    重定向地址如何知晓，请求的第一个redis实例会返回错误，加上重定向的实例连接信息。（error） MOVED slotID  ip:port</p><h2 id="ask重定向？"><a href="#ask重定向？" class="headerlink" title="ask重定向？"></a>ask重定向？</h2><p>当哈希槽正在迁移，命令落中正在迁移的槽时，会回复 ASK slotID ip:port</p><h1 id="aof日志，宕机了，如何避免数据丢失？"><a href="#aof日志，宕机了，如何避免数据丢失？" class="headerlink" title="aof日志，宕机了，如何避免数据丢失？"></a>aof日志，宕机了，如何避免数据丢失？</h1><ol><li>aof通过逐一记录命令，恢复时逐一执行命令来保证数据的可靠性。</li><li>aof提供了三种写回策略，<strong>always,everysec,no</strong>。</li><li>aof重写机制，避免日志文件过大，这个过程是fork子进程拷贝父进程内存数据，直接根据数据库里数据的最新状态，生成这些数据的插入命令。</li><li>aof在恢复时，需要重放aof日志命令，这个过程会比较慢，RDB快照恢复会比aof快。</li></ol><h1 id="RDB内存快照，宕机了，redis如何快速恢复？"><a href="#RDB内存快照，宕机了，redis如何快速恢复？" class="headerlink" title="RDB内存快照，宕机了，redis如何快速恢复？"></a>RDB内存快照，宕机了，redis如何快速恢复？</h1><p>redis提供save,和bgsave两个命令来生成RDB快照<br>save在主线程中执行，会导致阻塞<br>bgsave创建一个子进程，避免了主线程的阻塞</p><h2 id="快照时数据还能修改吗？"><a href="#快照时数据还能修改吗？" class="headerlink" title="快照时数据还能修改吗？"></a>快照时数据还能修改吗？</h2><p>快照时，子进程和主进程访问的同一块内存，正常情况下，快照完成前，只能读不能写，但是redis借助了操作系统的写时复制技术，在快照期间，可以执行写命令。</p><h2 id="快照可以每秒执行一次吗"><a href="#快照可以每秒执行一次吗" class="headerlink" title="快照可以每秒执行一次吗?"></a>快照可以每秒执行一次吗?</h2><p>虽然执行快照不会影响主线程，但是会给磁盘带来很大压力，而且快照可能一秒内完成不了。redis上一个bgsave在运行，不能启动第二个bgsave。</p><h2 id="有什么办法既可以利用RDB的快速恢复又可以做到尽量少丢数据呢？"><a href="#有什么办法既可以利用RDB的快速恢复又可以做到尽量少丢数据呢？" class="headerlink" title="有什么办法既可以利用RDB的快速恢复又可以做到尽量少丢数据呢？"></a>有什么办法既可以利用RDB的快速恢复又可以做到尽量少丢数据呢？</h2><p>混合使用AOF日志和RDB快照，这样AOF日志只有记录两次快照之间的命令了</p><h1 id="string类型为什么不好用了？"><a href="#string类型为什么不好用了？" class="headerlink" title="string类型为什么不好用了？"></a>string类型为什么不好用了？</h1><p>string类型在保存本身占用的内存空间不大时，string类型的元数据开销就会占主导地位，这里面包括redis_object，SDS结构，dict_entry结构的内存开销。</p><h2 id="那内存占用是怎么多出来的呢？"><a href="#那内存占用是怎么多出来的呢？" class="headerlink" title="那内存占用是怎么多出来的呢？"></a>那内存占用是怎么多出来的呢？</h2><p>redis使用一个全局哈希表保存所以键值对，每一项都是dict_entry结构体，用来指向一个键值对，分别指向key,value,next，三个指针一共24字节，由于jemalloc的内存分配机制，会实际分配最接近2的幂次数，所以24字节，实际分配32字节。<br>然后还有分配一个key和value的redis_object对象，一个redis_object对象至少占用16字节，2个就是32，所以使用一个string类型保存数据至少要64字节。</p><p><img src="/img/redis/redis_object.jpg"><br><img src="/img/redis/keys.webp"></p><h2 id="动态字符串的编码方式有3种："><a href="#动态字符串的编码方式有3种：" class="headerlink" title="动态字符串的编码方式有3种："></a>动态字符串的编码方式有3种：</h2><ul><li><strong>int编码：</strong> ptr指针位直接用于保存整型</li><li><strong>embstr编码：</strong> 当string内容小于等于44字节时候，redis_object和sds数据使用一块连续的内存，也就是整个数据块小于等于64字节。</li><li><strong>row编码：</strong> redis_object和SDS内存地址可能不连续。</li></ul><p><img src="/img/redis/code.webp"></p><h2 id="那用什么数据可以节省内存？"><a href="#那用什么数据可以节省内存？" class="headerlink" title="那用什么数据可以节省内存？"></a>那用什么数据可以节省内存？</h2><p>redis的hash，list，zset，set在元素小于配置限制内时会使用intset整数数组，ziplist压缩列表来存储数据。</p><ul><li><strong>hash：</strong> zliblist，hash</li><li><strong>list：</strong> zliblist，双向链表</li><li><strong>zset：</strong> zliblist，跳表</li><li><strong>set：</strong> intset，hash</li></ul><h2 id="压缩列表的构成"><a href="#压缩列表的构成" class="headerlink" title="压缩列表的构成"></a>压缩列表的构成</h2><p>表头有zlibytes，zltail，zllen，分别表示列表长度，列表尾的偏移量，以及列表的entry个数，压缩列表之所以可以节省内存，是因为它是用一系列连续的entry保存数据。</p><h2 id="entry结构"><a href="#entry结构" class="headerlink" title="entry结构"></a>entry结构</h2><ul><li><strong>prev_len：</strong> 表示前一个entry的长度，1或5字节</li><li><strong>len：</strong> 表示自身长度，4字节</li><li><strong>encoding：</strong> 1字节</li><li><strong>content：</strong> 保存实际数据</li></ul><p>如果实际数据是int类型8字节，总共是1+4+1+8&#x3D;14字节往上适配是16字节。<br>这样新增一个数据只需要16字节，少了dict_entry和2个redis_object的创建，比使用string类型少了48字节。</p><h2 id="inset结构"><a href="#inset结构" class="headerlink" title="inset结构"></a>inset结构</h2><pre><code class="hljs">uint32_t encoding;uint_32_t length;int8_t contents[];</code></pre><ol><li>inset在元素是整型结果的时候使用。</li><li>inset会根据encoding编码调整contents类型，当插入的元素字节长度大于之前所以元素的长度时会进行升级，调整contents的元素内存占用宽度，inset不会进行降级。</li><li>inset插入删除时间复杂度为o(n)，查找使用2分查找时间复杂度为o(log n)，查询长度为o(1)。</li></ol><p>相关配置：<br><strong>list:</strong> list-max-ziplist-size   -2表示8kb，最多8kb<br><strong>set:</strong> set-max-intset-entries   表示512个元素，最多512元素<br><strong>zset:</strong> zset-max-ziplist-size,zset-max-ziplist-value<br><strong>hash:</strong> hash-max-ziplist-size,hash-max-ziplist-value<br><strong>zset和hash，</strong> size和value 分别表示最多size个元素，值字节长度最大多少。</p><p>所以结构升级后不可降级。</p><h1 id="GEO是什么？"><a href="#GEO是什么？" class="headerlink" title="GEO是什么？"></a>GEO是什么？</h1><p>扩展类型之一，广泛用于LBS服务中，可以记录经纬度的地理位置信息，GEO是基于zset实现的。</p><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>geohash编码，基本原理是二分区间，区间编码</p><p>假如有一组经纬度为，经度100，纬度30。<br>经度范围是[180,-180]，纬度范围是[90,-90]。<br>geohash会分别把经度纬度编码成N位的二进制。<br>假如我们只编码两位经度为100。<br>设范围[0,-180]为0，范围[0,180]为1<br>此时编码为：1<br>然后再设[0,90]为0，[90,180]为1<br>此时编码为：11<br>根据此编码规则我们得知纬度30的编码为：10<br>然后geohash会以经度为奇纬度为偶的方式逐位交叉编码，得到1110，<br>然后把1110当做score存入zset。<br><img src="/img/redis/geo.webp"></p><p>不过，有点编码值相近实际距离却很远，为了避免查询不准确的问题，我们可以同时查询给定经纬度的4个或8个方格。</p><h2 id="操作命令"><a href="#操作命令" class="headerlink" title="操作命令"></a>操作命令</h2><ul><li><strong>geoadd</strong> key 经度，纬度，members</li><li><strong>georadius</strong> key 经度，纬度，范围 其他参数</li></ul><h1 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h1><p>三大需求：<br>    消息保序<br>    重复消息处理<br>    消息可靠性保证</p><p>list：<br>    优点：简单易懂<br>    缺点：消息保序和消息可靠性需要自己实现策略保证</p><p>stream:<br>    优点：自动生成id，提供消费组形势读取数据，满足消息队列三大需求</p><h1 id="如何在redis中保存时间序列数据？"><a href="#如何在redis中保存时间序列数据？" class="headerlink" title="如何在redis中保存时间序列数据？"></a>如何在redis中保存时间序列数据？</h1><h2 id="使用场景，比如服务器每一秒的在线人数，各个游戏的在玩人数。查询需求"><a href="#使用场景，比如服务器每一秒的在线人数，各个游戏的在玩人数。查询需求" class="headerlink" title="使用场景，比如服务器每一秒的在线人数，各个游戏的在玩人数。查询需求"></a>使用场景，比如服务器每一秒的在线人数，各个游戏的在玩人数。<br>查询需求</h2><ol><li>1点钟的在线人数。 get单点查询。</li><li>1点到2点的最大在线人数，范围查询加sort排序。</li><li>1点到2点平均在线人数，聚合计算。<br>4 .1点到2点玩A游戏的人数比玩b游戏的人数的时间段多的百分比。</li></ol><h2 id="二种方案"><a href="#二种方案" class="headerlink" title="二种方案"></a>二种方案</h2><ol><li>使用hash+zset，可以满足1，2，3，4，但是3，4需要客户端请求拿到所以数据再聚合计算，数据传输开销大。</li><li>使用扩展类型RedisTimeSeries，专门为存取时间序列数据而设计的，可以满足2，3，避免了大量数据传输，不过底层用链表实现，范围查询的复杂度为o(n)。</li></ol><h2 id="方案优缺点"><a href="#方案优缺点" class="headerlink" title="方案优缺点"></a>方案优缺点</h2><ol><li>使用hash+zset<br> <strong>优点：</strong> 支持单点查询，范围查询的高效支持。<br> <strong>缺点：</strong> 聚合计算需要拿出来处理，网络数据传输量大。</li><li>使用扩展类型RedisTimeSeries<br> <strong>优点：</strong> 内部聚合计算，占用内存较低。<br> <strong>缺点：</strong> 仅仅支持最新数据的单点查询，范围查询时间复杂度为o(n)。</li></ol><h2 id="个人思考"><a href="#个人思考" class="headerlink" title="个人思考"></a>个人思考</h2><p>如果有全量的聚合计算且数据量较大优先使用redisTimeseries，因为全量的化，用hash，zset的时间复杂度也是o(n)</p><h1 id="有一亿个keys要统计，应该用哪种集合？"><a href="#有一亿个keys要统计，应该用哪种集合？" class="headerlink" title="有一亿个keys要统计，应该用哪种集合？"></a>有一亿个keys要统计，应该用哪种集合？</h1><ol><li>bitmap适合于二值状态统计，比如签到，登录统计，对比set,hash,zset,做聚合统计的效率会快，bitmap是o(1)是时间复杂度，其他类型至少都要o(N)。</li><li>hyperloglog适用于那种不需要非常精确的统计，比如网站的访问量，优势是占用内存低，一个key固定只需要12k，精准率81%，统计成员总数2的64次方。<br><img src="/img/redis/set.webp"></li></ol><h1 id="redis单线程处理io瓶颈主要包括2个方面？"><a href="#redis单线程处理io瓶颈主要包括2个方面？" class="headerlink" title="redis单线程处理io瓶颈主要包括2个方面？"></a>redis单线程处理io瓶颈主要包括2个方面？</h1><ol><li><p>任意一个请求在server一旦发送耗时，都会影响整个server的性能，也就是说后面的请求都要等这个耗时请求处理完成，自己才能处理到<br> a、操作bigkey<br> b、使用复杂度过高的命令，当N基数很大时，非常耗时<br> c、大量key过期<br> d、淘汰策略，当内存达到设置上限后<br> e、AOF写盘开始always策略，写盘速度比写内存速度低太多<br> f、主从全量同步，fork生成快照完成之前，redis一直不可写</p></li><li><p>并发量非常大时，单线程读写客户端io数据存在性能瓶颈，虽然有多路复用，但是读写客户端数据依旧是同步io，只能单线程依次读取写入，无法利用多核。</p></li></ol><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><ul><li><p><strong>针对问题1</strong> 人为规避，redis4.0推出了lazy-free异步释放内存</p></li><li><p><strong>针对问题2</strong> redis6.0推出多线程，并发场景下可以利用多核处理客户端io读写</p></li></ul><h1 id="异步机制：如何避免单线程模型的阻塞？"><a href="#异步机制：如何避免单线程模型的阻塞？" class="headerlink" title="异步机制：如何避免单线程模型的阻塞？"></a>异步机制：如何避免单线程模型的阻塞？</h1><h2 id="redis实例运行时的四大类交互对象客户端，磁盘，主从库实例，切片集群实例基于四大类交互对象，梳理了会导致redis性能受损的五大阻塞点："><a href="#redis实例运行时的四大类交互对象客户端，磁盘，主从库实例，切片集群实例基于四大类交互对象，梳理了会导致redis性能受损的五大阻塞点：" class="headerlink" title="redis实例运行时的四大类交互对象客户端，磁盘，主从库实例，切片集群实例基于四大类交互对象，梳理了会导致redis性能受损的五大阻塞点："></a>redis实例运行时的四大类交互对象客户端，磁盘，主从库实例，切片集群实例<br>基于四大类交互对象，梳理了会导致redis性能受损的五大阻塞点：</h2><ul><li>集合全量查询</li><li>聚合操作</li><li>bigkey删除</li><li>清空数据库</li><li>AOF日志同步写</li><li>从库加载RDB文件</li></ul><h2 id="阻塞性能受损原因："><a href="#阻塞性能受损原因：" class="headerlink" title="阻塞性能受损原因："></a>阻塞性能受损原因：</h2><ul><li>集合全量查询：操作时间复杂度为o(n)</li><li>聚合操作：操作时间复杂度&gt;&#x3D;o(n)</li><li>bigkey删除：虽然删除key看起来的只是简单的释放内存，不过操作还需要把内存插入到空闲列表进行管理和再分配</li><li>清空数据库：跟bigkey删除性质一样</li><li>AOF日志同步写：磁盘读写速度有目共睹</li><li>从库加载RDB文件：涉及到读文件，而且数据量大</li></ul><h2 id="可以异步优化的："><a href="#可以异步优化的：" class="headerlink" title="可以异步优化的："></a>可以异步优化的：</h2><ul><li>bigkey删除，清空数据库：开启lazyfree-lazy相关配置</li><li>AOF日志同步写：apendfsync配置项由always改为everysec或者no</li></ul><h2 id="不能异步优化的："><a href="#不能异步优化的：" class="headerlink" title="不能异步优化的："></a>不能异步优化的：</h2><ul><li>集合全量查询，聚合操作，从库加载RDB文件</li></ul><p>可以异步的是不在关键路径上的操作，比如内存释放啊，写盘等等</p><h2 id="不能异步的怎么优化："><a href="#不能异步的怎么优化：" class="headerlink" title="不能异步的怎么优化："></a>不能异步的怎么优化：</h2><ul><li>集合全量查询，聚合操作：客户端分批读取数据，再聚合计算</li><li>从库加载RDB文件：控制主库的数据总量</li></ul><h2 id="相关配置："><a href="#相关配置：" class="headerlink" title="相关配置："></a>相关配置：</h2><pre><code class="hljs">lazyfree-lazy    lazy-free-lazy-expire：key在过期时异步释放内存    lazy-free-lazy-eviction：内存达到maxmemory并设置了淘汰策略是尝试异步释放内存    lazy-free-lazy-server-del：执行rename/move等命令或需要覆盖一个key时，删除旧key尝试异步释放内存    replica-lazy-flush：主从全量同步时，从库清空数据库时异步释放内存</code></pre><h2 id="相关命令："><a href="#相关命令：" class="headerlink" title="相关命令："></a>相关命令：</h2><p>unlink 删除key 异步释放内存<br>flushall aysnc   异步清除</p><h1 id="如何应对redis变慢"><a href="#如何应对redis变慢" class="headerlink" title="如何应对redis变慢?"></a>如何应对redis变慢?</h1><h2 id="怎么判断redis变慢？"><a href="#怎么判断redis变慢？" class="headerlink" title="怎么判断redis变慢？"></a>怎么判断redis变慢？</h2><ol><li><p>查看redis运行时响应延迟： redis-cli –latency -h host -p port<br>如果延迟达到一秒或一秒以上，基本可以认定redis变慢了。</p></li><li><p>当前环境的基线性能：redis-cli –intrinsic-latency  120<br>如果运行时响应延迟是基线性能的2倍以上，就可以认定redis变慢了。</p></li></ol><h2 id="如何解决redis变慢"><a href="#如何解决redis变慢" class="headerlink" title="如何解决redis变慢?"></a>如何解决redis变慢?</h2><p><img src="/img/redis/frame.webp"></p><p>redis自身的操作特性，操作系统，文件系统，它们是影响redis性能的三大要素。</p><p><strong>一：自身的操作特性</strong></p><ol><li><p>慢查询命令<br> <strong>原因：</strong> sunion,sort,smembers操作复杂度分别是O(N + M*log(M))和O(N)，时间复杂度过高。<br> <strong>定位方式：</strong> redis日志或者latency monitor工具。<br> <strong>解决办法：</strong> 用其他命令代替，比如sscan，排序，交集，并集可以放在客户端做。</p></li><li><p>KEYS命令<br> <strong>原因：</strong> 遍历所以keys，比如redis有1百万个keys，就会遍历1百万次，时间复杂度为O(N。<br> <strong>解决办法：</strong> 不用，或者直接禁用。</p></li><li><p>过期key操作<br> <strong>删除机制：</strong> </p><ol><li>ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP &#x3D; 20默认配置，100毫秒删除20个过期key，1秒删除200个，</li><li>如果超过25%的key过期了，则重复删除的过程，直到过期key的比例降至25%以下。<br> <strong>原因：</strong> 过期key的删除是主线程在执行，触发机制2可能存在影响。<br> <strong>解决办法：</strong> 避免大量key同时设置相同的过期时间，比如在固定过期时间后面加一个小范围的随机时间。</li></ol></li></ol><p><strong>二：文件系统：AOF</strong></p><p>always同步写盘，每次都会等待写完磁盘。<br>everysec，每秒fork一个子线程来完成写磁盘，不过上一次fork的写盘任务没有完成，那么就会阻塞，特别是aof重写的时候，磁盘io压力较大，可能会造成阻塞。</p><p><strong>相关配置：</strong><br>    appendfsync<br>    no-appendfsync-on-rewrite</p><p><strong>三：操作系统：swap</strong><br>    当系统内存不够的时候，系统会用磁盘模拟内存，window叫虚拟内存，可以想象磁盘当内存用，当然性能会下降。<br>    查看方式：cd &#x2F;proc&#x2F;进程号<br>                    cat smaps | egrep ‘^(Swap|Size)’</p><p><strong>四：内存大页</strong><br>    内存大页机制（Transparent Huge Page THP）<br>    linux内核从2.6.38开始支持大页机制，该机制支持2M大小的内存页分配，常规的只有4kb的粒度来执行的。<br>    RDB内存快照写时复制机制，当内存块数据需要修改时，会将这些数据拷贝一份，然后进行修改，这时候大页机制可能会影响到性能了。<br>    如何关闭：<br>         cat &#x2F;sys&#x2F;kernel&#x2F;mm&#x2F;transparent_hugepage&#x2F;enabled<br>        如果结果是always表示是开启的，如果是never表示禁止了。<br>生产中不建议对Redis的实例运行的机器开启大页<br>        关闭命令：<br>        echo never &#x2F;sys&#x2F;kernel&#x2F;mm&#x2F;transparent_hugepage&#x2F;enabled</p><h1 id="删除数据后，为什么内存占用率还是很高？"><a href="#删除数据后，为什么内存占用率还是很高？" class="headerlink" title="删除数据后，为什么内存占用率还是很高？"></a>删除数据后，为什么内存占用率还是很高？</h1><h2 id="明明删除了数据，但是redis占用内存没有降下来？"><a href="#明明删除了数据，但是redis占用内存没有降下来？" class="headerlink" title="明明删除了数据，但是redis占用内存没有降下来？"></a>明明删除了数据，但是redis占用内存没有降下来？</h2><p>这是应该redis释放的内存空间被内存分配管理器管理，并不会立即返回给操作系统。<br>风险点：删除数据，如果删除的是连续空间，那么这个连续空间可以继续用来存储数据;如果不是连续空间，仍然是属于操作系统分配给redis的物理内存，但无法用来存储数据。</p><h2 id="内存碎片是什么？"><a href="#内存碎片是什么？" class="headerlink" title="内存碎片是什么？"></a>内存碎片是什么？</h2><p>应用申请的内存是连续的一块N大小的内存空间，不满足N大小的内存块就是内存碎片，无法利用。</p><h2 id="内存碎片的形成原因"><a href="#内存碎片的形成原因" class="headerlink" title="内存碎片的形成原因"></a>内存碎片的形成原因</h2><ol><li><strong>内因：</strong> 内存分配器分配机制。</li><li><strong>外因：</strong> 键值对大小不一样和删除操作。</li></ol><h2 id="如何判断是否有内存碎片？"><a href="#如何判断是否有内存碎片？" class="headerlink" title="如何判断是否有内存碎片？"></a>如何判断是否有内存碎片？</h2><pre><code class="hljs">命令： INFO memorymem_fragmentation_ratio 表示内存碎片率，rss/use_memoryuse_memory_rss                实际分配内存               use_memory                      实际使用内存</code></pre><h2 id="合理范围"><a href="#合理范围" class="headerlink" title="合理范围"></a>合理范围</h2><pre><code class="hljs">ratio在1到1.5之间</code></pre><h2 id="如何清理内存碎片？"><a href="#如何清理内存碎片？" class="headerlink" title="如何清理内存碎片？"></a>如何清理内存碎片？</h2><pre><code class="hljs">重启redisredis自动清理机制：搬家让位，合并空间不过碎片清理是有代价的</code></pre><h2 id="相关配置：-1"><a href="#相关配置：-1" class="headerlink" title="相关配置："></a>相关配置：</h2><pre><code class="hljs">activedefrag    开关activedefrag-ignore-bytes 100mb    表示内存碎片达到100mb，开始清理activedefrag-threshold-lower 10   表示内存碎片空间占redis总分配空间的10%，开始清理activedefrag-cycle-min 25    表示自动清理过程所用cpu时间比例不低于25%activedefrag-cycle-max 75   表示自动清理过程所用cpu时间比例不高于75%</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后，我再给你提供一个小贴士：内存碎片自动清理涉及内存拷贝，这对 Redis 而言，是个潜在的风险。如果你在实践过程中遇到 Redis 性能变慢，记得通过日志看下是否正在进行碎片清理。如果 Redis 的确正在清理碎片，那么，我建议你调小 active-defrag-cycle-max 的值，以减轻对正常请求处理的影响。</p><h1 id="缓冲区，一个可以引发惨案的地方"><a href="#缓冲区，一个可以引发惨案的地方" class="headerlink" title="缓冲区，一个可以引发惨案的地方"></a>缓冲区，一个可以引发惨案的地方</h1><h2 id="缓冲区主要有两个应用场景："><a href="#缓冲区主要有两个应用场景：" class="headerlink" title="缓冲区主要有两个应用场景："></a>缓冲区主要有两个应用场景：</h2><ol><li>在客户端与服务端进行通信时，用来存在客户端和命令，和服务端返回给客户端的数据。</li><li>在主从同步进行时，用来存放主节点接收的写命令和数据。</li></ol><h2 id="风险："><a href="#风险：" class="headerlink" title="风险："></a>风险：</h2><p>由于缓冲区写入速度大于读出速度，引发缓冲区溢出，造成数据丢失。<br>缓冲区过大，耗尽机器内存，导致redis实例崩溃。</p><p>客户端输入，输出缓冲区<br><img src="/img/redis/cache.webp"></p><h2 id="如何应对输入缓存区溢出："><a href="#如何应对输入缓存区溢出：" class="headerlink" title="如何应对输入缓存区溢出："></a>如何应对输入缓存区溢出：</h2><ul><li><strong>如何检测：</strong> client list命令查看，qbuf(已使用大小)，qbuf-free(未使用大小)，通常qbuf很大，qbuf-free很小，就要注意了。</li><li><strong>应对方法：</strong></li></ul><pre><code class="hljs">1. 调大缓存区，没有配置，代码写死1G。2. 从数据命令的发送和处理入手，避免写入bigkey，避免redis主线程阻塞。</code></pre><h2 id="如何应对输出缓存区溢出："><a href="#如何应对输出缓存区溢出：" class="headerlink" title="如何应对输出缓存区溢出："></a>如何应对输出缓存区溢出：</h2><p><strong>常见溢出场景：</strong><br>        返回bigkey的执行结果。<br>        monitor命令。<br>        缓冲区大小设置不合理。</p><h2 id="如何设置输出缓存区大小："><a href="#如何设置输出缓存区大小：" class="headerlink" title="如何设置输出缓存区大小："></a>如何设置输出缓存区大小：</h2><p>output-buffer-limit配置<br>普通客户端：output-buffer-limit normal 0 0 0   –0表示不做限制<br>订阅客户端：output-buffer-limit pubsub 8mb 2mb 60  –8mb表示总量限制，2mb和60表示，60秒内不超过2mb的缓冲器占用，超过就是与该客户端断开连接。</p><h1 id="redis为什么适合做缓存"><a href="#redis为什么适合做缓存" class="headerlink" title="redis为什么适合做缓存"></a>redis为什么适合做缓存</h1><p>在分层系统中，数据暂存与快速子系统有助于加速访问，缓存容量有限，缓存写满时需要淘汰机制，而redis天然满足这两个特性，所以非常适合做缓存。</p><p>redis做缓存时通常有两种模式：</p><ol><li>只读缓存：<br> 数据有修改会直接改数据库，改完删除缓存，下次有读取请求会先从数据库读出数据，然后写入redis缓存，之后的读取命令都会命中缓存。<br> 好处，可以保证数据库的数据是最新的，适用与读多写少或者对数据安全性要求较高的业务。</li><li>读写缓存：<br> 数据有修改先改缓存，再改数据库，有两种策略，同步只写，和异步写回。<br> 同步直写：<br>     优点：可以保证数据安全性。<br>     缺点：降低性能。<br> 异步写回：<br>     优点：提高业务响应速度。<br>     缺点：有数据丢失风险。</li></ol><h1 id="缓存满了，怎么办"><a href="#缓存满了，怎么办" class="headerlink" title="缓存满了，怎么办"></a>缓存满了，怎么办</h1><p>缓存应该设置多大，8，2定律，也就是将缓存区的容量设置为总数据量的20%，能拦截80%的访问量。</p><p>redis的缓存淘汰策略：<br>redis总共有8种缓存淘汰策略：<br>按机制可以分为5大类：<br>*<strong>不淘汰机制：</strong> noeviction<br>    <strong>随机淘汰机制：</strong> allkeys-random，volatile-random<br>    <strong>最快过期机制：</strong> volatile-ttl<br>    <strong>最冷淘汰机制：</strong> allkeys-lru,volatile-lru<br>    <strong>最少访问淘汰机制：</strong> allkeys-lfu，volatile-lfu</p><h1 id="常见缓存异常场景"><a href="#常见缓存异常场景" class="headerlink" title="常见缓存异常场景"></a>常见缓存异常场景</h1><p>常见4个异常场景：<strong>数据不一致，缓存雪崩，缓存穿透，缓存击穿</strong></p><p>数据缓存：读写缓存，只读缓存</p><ul><li><p><strong>读写缓存：</strong><br>  <strong>同步策略：</strong> 异步写库，同步直写<br>  <strong>优点：</strong> 异步写库，可以提升系统的吞吐量，同步直写，可以保证数据一致性。<br>  <strong>缺点：</strong> 异步写库，可能出现数据丢失，同步直写，会降低系统吞吐量。</p></li><li><p><strong>只读缓存：</strong><br>  <strong>策略顺序：</strong> 先删库，再删缓存。 先删缓存后删库。<br>  <strong>问题：</strong> 脏数据。<br><img src="/img/redis/cache1.webp"></p></li></ul><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p><strong>原因：</strong> 大量热点key同时过期，导致大量请求落到数据库。<br><strong>解决办法：</strong></p><ol><li>在设置过期时间时增加随机过期时间。</li><li>服务降级。</li></ol><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p><strong>原因：</strong> 某个热点数据，无法在缓存中处理，导致压力全部落到数据库。<br><strong>解决办法：</strong> 热点数据不设置过期时间。</p><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p><strong>原因：</strong> 数据不存在。<br><strong>解决办法：</strong></p><ol><li>布隆过滤器。</li><li>设置代表空值的缓存信息。</li></ol><p><img src="/img/redis/cache2.webp"></p><h1 id="事务功能，ADIC能保证吗？"><a href="#事务功能，ADIC能保证吗？" class="headerlink" title="事务功能，ADIC能保证吗？"></a>事务功能，ADIC能保证吗？</h1><ul><li><p><strong>原子性(Atomicity)</strong><br>概念：一系列操作要不都成功，要么都失败。<br>redis并没有提供回滚操作，不能保证原子性。</p></li><li><p><strong>一致性(Consistency)</strong><br>概念：数据库中的数据在执行前后是一致的。<br>可以保证，错误的命令不会执行。</p></li><li><p><strong>隔离性(lsolation)</strong><br>概念：事务执行期间，其他操作无法取到执行事务访问的数据。<br>可以保证，入队有watch命令监控保证，执行由单线程天然保证。</p></li><li><p><strong>持久性(Durability)</strong><br>持久化数据。<br>不能保证，不管是开启aof还是RDB，都存在数据丢失的可能。</p></li></ul><p><img src="/img/redis/ADIC.webp"></p>]]></content>
    
    
    <categories>
      
      <category>redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>skynet c层的整体架构</title>
    <link href="/2023/05/13/skynet_frame/frame/"/>
    <url>/2023/05/13/skynet_frame/frame/</url>
    
    <content type="html"><![CDATA[<h1 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h1><p><img src="/img/skynet_frame/frame.png"><br>上图是skynet框架的核心的架构图，看完整体我们再去细看内部实现细节，架构图就像一张完整的地图，我们需要由面到点深入到图中，才能真正的了解吃透skynet，使用中才知道要注意哪些细节。<br>现实中了解地图中的一个地方自然是实地去走一走。了解代码框架的话当然是结合源码和文档(skynet github 上的wiki文档就写的非常不错)。<br>源码不止看了一遍，所以基本上都是n探，探多了就清楚自己哪些地方很熟哪些还不熟，哪些是重点，哪些使用中需要注意。</p><h1 id="n探main"><a href="#n探main" class="headerlink" title="n探main"></a>n探main</h1><p>启动skynet必须携带一个config配置文件，配置项的详细介绍可以看<a href="https://github.com/cloudwu/skynet/wiki/Config#%E5%90%8E%E5%8F%B0%E6%A8%A1%E5%BC%8Fdaemon-mode">skynet wiki</a>，那里非常详细。<br>我简单介绍一下比较常用的配置项：</p><ul><li><strong>thread</strong> 启动多少个工作线程。通常不要将它配置超过你实际拥有的 CPU 核心数。<strong>实际开发中可以根据业务流量把控</strong></li><li><strong>bootstrap</strong> 启动的第一个服务以及其启动参数。默认配置为 snlua bootstrap ，即启动一个名为 bootstrap 的 lua 服务。通常指的是 service&#x2F;bootstrap.lua 这段代码。<strong>基本上用默认的就行</strong></li><li><strong>harbor</strong> 节点id，<a href="https://github.com/cloudwu/skynet/wiki/Cluster#cluster-%E5%92%8C-snax-service">skynet cluster(master&#x2F;slave)</a>模式使用,云风大佬不推荐使用。所以一般直接配置为0单节点模式。如果需要RPC调用，可以考虑 cluster mode模式。可以读一读<a href="http://blog.codingnow.com/2017/03/skynet_cluster.html">云风设计心路历程。</a></li><li><strong>daemon</strong> 配置 daemon &#x3D; “.&#x2F;skynet.pid” 可以以后台模式启动 skynet 。注意，同时请配置 logger 项输出 log 。<strong>后台运行</strong></li><li><strong>logger</strong> 日志文件目录。</li><li><strong>logservice</strong> 日志服务,通常直接用skynet自带的logger服务，不提供日志切割，可以自己配置linux上的<strong>logrotate</strong>实现日志切割。</li><li><strong>profile</strong> 是否统计每个服务使用cpu时间。在<a href="https://github.com/cloudwu/skynet/wiki/DebugConsole">debugconsole</a>中可以查看。</li><li><strong>preload</strong> 前置加载lua文件。<strong>通常用来加载自定义的全局工具函数</strong></li><li><strong>lualoader</strong> 用哪一段 lua 代码加载 lua 服务。通常配置为 lualib&#x2F;loader.lua。</li><li><strong>start</strong> 这是 bootstrap 最后一个环节将启动的 lua 服务，也就是你定制的 skynet 节点的主程序。默认为 main ，即启动 main.lua 这个脚本。这个 lua 服务的路径由下面的 luaservice 指定。</li><li><strong>cpath</strong> c服务模块查找加载路径。</li><li><strong>luaservice</strong> lua服务查找加载路径。</li><li><strong>lua_cpath</strong> 将添加到 package.cpath 中的路径，供 require 调用。</li><li><strong>lua_path</strong>  将添加到 package.path 中的路径，供 require 调用。</li></ul><p>读完配置之后main函数就根据配置项做一些初始化的工作。</p><ul><li>注册系统信号HUP（接收后会发送system消息给logger服务，logger接送后会重新打开日志文件，可用于日志切割。）触发信号(kill -HUP 进程号)<strong>单发</strong>，或者（pkill -HUP -f skynet.(配置文件)<strong>单发</strong>） 或者<strong>群发</strong>(pkill -HUP skynet)</li><li>daemon守护进程。(检测skynet.pid进程号是否系统正在运行，在运行启动不了)</li><li>初始化harbor handle mq module timer socket</li><li>启动logger日志服务。</li><li>启动lua bootstrap服务。</li><li>启动 monitor timer socket worker线程。</li></ul><p>重点讲一下worker线程初始化的配置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> weight[] = &#123;<br><span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,<br><span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>,<br><span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>,<br><span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, &#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">worker_parm</span> <span class="hljs-title">wp</span>[<span class="hljs-title">thread</span>];</span><br><span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>;i&lt;thread;i++) &#123;<br>wp[i].m = m;<br>wp[i].id = i;<br><span class="hljs-keyword">if</span> (i &lt; <span class="hljs-keyword">sizeof</span>(weight)/<span class="hljs-keyword">sizeof</span>(weight[<span class="hljs-number">0</span>])) &#123;<br>wp[i].weight= weight[i];<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>wp[i].weight = <span class="hljs-number">0</span>;<br>&#125;<br>create_thread(&amp;pid[i+<span class="hljs-number">3</span>], thread_worker, &amp;wp[i]);<br>&#125;<br><br><span class="hljs-comment">//skynet_context_message_dispatch 部分代码</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i==<span class="hljs-number">0</span> &amp;&amp; weight &gt;= <span class="hljs-number">0</span>) &#123;<br>n = skynet_mq_length(q);<br>n &gt;&gt;= weight;<br>&#125;<br></code></pre></td></tr></table></figure><p>每个启动的worker线程都会绑定一个weight值。<br>云风写死了32个weight的配置。<br>在<code>skynet_context_message_dispatch</code>函数中，也就是worker线程从全局队列中弹出ctx mq时，会用weight值决定它本次处理的消息数量。<br>如上代码，n为待处理消息数量,weight&gt;&#x3D;0时，n等于n&gt;&gt;weight，也就是说，根据weight适配的处理规则如下：</p><ol><li>-1 1</li><li>0 n</li><li>1 n的2分之1</li><li>2 n的4分之1</li><li>3 n的8分之1</li></ol><p>云风大佬这样设计是为了防止出现服务饿死的情况，在机器cpu很多的情况下也能充分利用多核优势，快速处理消息，减少cpu切换调度。</p><h1 id="n探skynet-module"><a href="#n探skynet-module" class="headerlink" title="n探skynet_module"></a>n探skynet_module</h1><p>module的源码总共210行，非常简单易懂，module的的任务就是<strong>查找、加载、缓存、调用</strong>模块。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">skynet_module</span> &#123;</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> * name;         <span class="hljs-comment">//名称</span><br><span class="hljs-type">void</span> * module;   <span class="hljs-comment">//动态库</span><br>skynet_dl_create create;   <span class="hljs-comment">//create接口函数</span><br>skynet_dl_init init;   <span class="hljs-comment">//init接口函数</span><br>skynet_dl_release release; <span class="hljs-comment">//release接口函数</span><br>skynet_dl_signal signal;   <span class="hljs-comment">//signal接口函数</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>在创建skynet_context的时候通过<code>skynet_module_query(const char* name)</code>函数绑定一个模块，该函数会在<code>skynet_module_init(const char *path)</code>传入的path路径中<strong>查找</strong> <strong>(name).so</strong>动态库文件并且<strong>加载</strong>再绑定<strong>create,init,release,signal</strong>接口函数。然后<strong>缓存</strong>到modules结构中,以便下次使用不需要再加载动态库，提高速度。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_MODULE_TYPE 32</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">modules</span> &#123;</span><br><span class="hljs-type">int</span> count;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">lock</span>;</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> * path;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">skynet_module</span> <span class="hljs-title">m</span>[<span class="hljs-title">MAX_MODULE_TYPE</span>];</span><br>&#125;;<br><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">modules</span> * <span class="hljs-title">M</span> =</span> <span class="hljs-literal">NULL</span>;<br></code></pre></td></tr></table></figure><p>可以发现，云风写死了只能加载32个模块服务动态库。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> * <span class="hljs-title function_">skynet_module_instance_create</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> skynet_module *)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">skynet_module_instance_init</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> skynet_module *, <span class="hljs-type">void</span> * inst, <span class="hljs-keyword">struct</span> skynet_context *ctx, <span class="hljs-type">const</span> <span class="hljs-type">char</span> * parm)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">skynet_module_instance_release</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> skynet_module *, <span class="hljs-type">void</span> *inst)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">skynet_module_instance_signal</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> skynet_module *, <span class="hljs-type">void</span> *inst, <span class="hljs-type">int</span> signal)</span>;<br></code></pre></td></tr></table></figure><p>模块提供接口<strong>调用</strong>函数,其中<strong>create,init</strong>在skynet_context_new中调用，<strong>release</strong>服务退出时调用,<strong>signal</strong>是API直接调用的。<br>写一个模块服务需要注意的是模块<strong>名字</strong>的文件名必须是（service_<strong>名字</strong>),接口名必须是(<strong>名字</strong>_接口名），可以参考<strong>service-src&#x2F;service_logger.c</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">logger_create()<br>logger_release()<br>logger_init()<br></code></pre></td></tr></table></figure><h1 id="n探skynet-message-message-queue-global-queue"><a href="#n探skynet-message-message-queue-global-queue" class="headerlink" title="n探skynet_message,message_queue,global_queue"></a>n探skynet_message,message_queue,global_queue</h1><ul><li><p><strong>skynet_message</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">skynet_message</span> &#123;</span><br><span class="hljs-type">uint32_t</span> source;  <span class="hljs-comment">//消息来源地址就是来源handle id</span><br><span class="hljs-type">int</span> session;  <span class="hljs-comment">//唯一会话id 一般用session来确定回复消息</span><br><span class="hljs-type">void</span> * data;  <span class="hljs-comment">//数据</span><br><span class="hljs-type">size_t</span> sz;  <span class="hljs-comment">//数据大小</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>以上是sknyet_message的组成，其中sz中最左边的一个字节用来存放type。比如<code>smsg.sz = len | ((size_t)PTYPE_TEXT &lt;&lt; MESSAGE_TYPE_SHIFT);</code></p></li><li><p><strong>message_queue</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">message_queue</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">lock</span>;</span> <span class="hljs-comment">//多线程自旋锁</span><br><span class="hljs-type">uint32_t</span> handle;      <span class="hljs-comment">//绑定的ctx</span><br><span class="hljs-type">int</span> cap;  <span class="hljs-comment">//容量</span><br><span class="hljs-type">int</span> head;  <span class="hljs-comment">//队列头(pop)</span><br><span class="hljs-type">int</span> tail;  <span class="hljs-comment">//队列尾(push)</span><br><span class="hljs-type">int</span> release;          <span class="hljs-comment">//标记是否释放队列</span><br><span class="hljs-type">int</span> in_global;        <span class="hljs-comment">//是否在全局队列里</span><br><span class="hljs-type">int</span> overload;  <span class="hljs-comment">//待处理消息数量是否超过overload_threshold</span><br><span class="hljs-type">int</span> overload_threshold;<span class="hljs-comment">//默认1024</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">skynet_message</span> *<span class="hljs-title">queue</span>;</span> <span class="hljs-comment">//消息队列</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">message_queue</span> *<span class="hljs-title">next</span>;</span>   <span class="hljs-comment">//下一个message_queue</span><br>&#125;;<br></code></pre></td></tr></table></figure><p><img src="/img/skynet_frame/mq.png"><br>message_queue初始容量为64，当待处理消息超过容量时会进行扩容，扩容现有容量的一倍，消息队列扩容后<strong>不支持缩容量</strong>。<br>当有worker_thread在pop消息时会检查消息队列长度是否大于overload_threshold，大于时会标记overload待处理消息数量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> overload = skynet_mq_overload(q);<br><span class="hljs-keyword">if</span> (overload) &#123;<br>skynet_error(ctx, <span class="hljs-string">&quot;May overload, message queue length = %d&quot;</span>, overload);<br>&#125;<br></code></pre></td></tr></table></figure><p>如果overload不等于0，会在处理消息之前打印一个日志，启到报警作用。<br>出现这个日志就说明这个服务的消息<strong>处理速度</strong>远远<strong>低于</strong>消息<strong>创建速度</strong>，要<strong>警惕</strong>了。</p></li></ul><p>当服务退出后，worker线程就不在处理该服务的消息，会将所以消息进行丢弃处理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <br><span class="hljs-title function_">skynet_mq_release</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> message_queue *q, message_drop drop_func, <span class="hljs-type">void</span> *ud)</span> &#123;<br>SPIN_LOCK(q)<br><br><span class="hljs-keyword">if</span> (q-&gt;release) &#123;<br>SPIN_UNLOCK(q)<br>_drop_queue(q, drop_func, ud);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>skynet_globalmq_push(q);<br>SPIN_UNLOCK(q)<br>&#125;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br>_drop_queue(<span class="hljs-keyword">struct</span> message_queue *q, message_drop drop_func, <span class="hljs-type">void</span> *ud) &#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">skynet_message</span> <span class="hljs-title">msg</span>;</span><br><span class="hljs-keyword">while</span>(!skynet_mq_pop(q, &amp;msg)) &#123;<br>drop_func(&amp;msg, ud);<br>&#125;<br>_release(q);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">drop_message</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> skynet_message *msg, <span class="hljs-type">void</span> *ud)</span> &#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">drop_t</span> *<span class="hljs-title">d</span> =</span> ud;<br>skynet_free(msg-&gt;data);<br><span class="hljs-type">uint32_t</span> source = d-&gt;handle;<br>assert(source);<br><span class="hljs-comment">// report error to the message source</span><br>skynet_send(<span class="hljs-literal">NULL</span>, source, msg-&gt;source, PTYPE_ERROR, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>丢弃处理是给消息来源方发送<code>PTYPE_ERROR</code>消息。</p><ul><li>global_queue<br>全局消息队列主要负责把次级消息队列(message_queue)串起来，供worker_thread消费执行。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">global_queue</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">message_queue</span> *<span class="hljs-title">head</span>;</span> <span class="hljs-comment">//头部pop</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">message_queue</span> *<span class="hljs-title">tail</span>;</span> <span class="hljs-comment">//尾部push</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">lock</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure>此时可以再回头是看看架构图，应该就清晰许多了😊</li></ul><h1 id="n探skynet-context"><a href="#n探skynet-context" class="headerlink" title="n探skynet_context"></a>n探skynet_context</h1><p>skynet框架核心结构，源代码中遍地都是handle，其实就是服务的唯一id。<br>skynet_context是什么，它是sknyet中的主角，skynet中的所有服务都是skynet_context抽象的，可以说它是母体。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">skynet_context</span> &#123;</span><br><span class="hljs-type">void</span> * instance;<span class="hljs-comment">//实例数据</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">skynet_module</span> * <span class="hljs-title">mod</span>;</span> <span class="hljs-comment">//绑定的服务模块</span><br><span class="hljs-type">void</span> * cb_ud;<span class="hljs-comment">//回调实例数据</span><br>skynet_cb cb;<span class="hljs-comment">//绑定的回调函数</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">message_queue</span> *<span class="hljs-title">queue</span>;</span><span class="hljs-comment">//消息队列</span><br>FILE * logfile;<span class="hljs-comment">//服务消息处理日志</span><br><span class="hljs-type">uint64_t</span> cpu_cost;<span class="hljs-comment">// in microsec //cpu时间片总占用</span><br><span class="hljs-type">uint64_t</span> cpu_start;<span class="hljs-comment">// in microsec //辅助记录cpu_cost</span><br><span class="hljs-type">char</span> result[<span class="hljs-number">32</span>];<span class="hljs-comment">//lua-c api结果存储</span><br><span class="hljs-type">uint32_t</span> handle;    <span class="hljs-comment">//服务唯一id</span><br><span class="hljs-type">int</span> session_id;<span class="hljs-comment">//服务维护的会话id</span><br><span class="hljs-type">int</span> ref;<span class="hljs-comment">//引用计数</span><br><span class="hljs-type">int</span> message_count;<span class="hljs-comment">//处理消息总数</span><br><span class="hljs-type">bool</span> init;<span class="hljs-comment">//是否已经初始化</span><br><span class="hljs-type">bool</span> endless;<span class="hljs-comment">//是否可能存在死循环</span><br><span class="hljs-type">bool</span> profile;<span class="hljs-comment">//是否记录cpu_cost</span><br><br>CHECKCALLING_DECL<br>&#125;;<br></code></pre></td></tr></table></figure><p>可以看到skynet_context依赖了skynet_module,和message_queue。</p><ul><li><p><strong>服务创建</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> skynet_context *<br><span class="hljs-title function_">skynet_context_new</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> * name, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *param)</span> &#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">skynet_module</span> * <span class="hljs-title">mod</span> =</span> skynet_module_query(name);<br><br><span class="hljs-keyword">if</span> (mod == <span class="hljs-literal">NULL</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-type">void</span> *inst = skynet_module_instance_create(mod);<br><span class="hljs-keyword">if</span> (inst == <span class="hljs-literal">NULL</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">skynet_context</span> * <span class="hljs-title">ctx</span> =</span> skynet_malloc(<span class="hljs-keyword">sizeof</span>(*ctx));<br>CHECKCALLING_INIT(ctx)<br><br>ctx-&gt;mod = mod;<br>ctx-&gt;instance = inst;<br>ctx-&gt;ref = <span class="hljs-number">2</span>;<br>ctx-&gt;cb = <span class="hljs-literal">NULL</span>;<br>ctx-&gt;cb_ud = <span class="hljs-literal">NULL</span>;<br>ctx-&gt;session_id = <span class="hljs-number">0</span>;<br>ctx-&gt;logfile = <span class="hljs-literal">NULL</span>;<br><br>ctx-&gt;init = <span class="hljs-literal">false</span>;<br>ctx-&gt;endless = <span class="hljs-literal">false</span>;<br><br>ctx-&gt;cpu_cost = <span class="hljs-number">0</span>;<br>ctx-&gt;cpu_start = <span class="hljs-number">0</span>;<br>ctx-&gt;message_count = <span class="hljs-number">0</span>;<br>ctx-&gt;profile = G_NODE.profile;<br><span class="hljs-comment">// Should set to 0 first to avoid skynet_handle_retireall get an uninitialized handle</span><br>ctx-&gt;handle = <span class="hljs-number">0</span>;<br>ctx-&gt;handle = skynet_handle_register(ctx);<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">message_queue</span> * <span class="hljs-title">queue</span> =</span> ctx-&gt;<span class="hljs-built_in">queue</span> = skynet_mq_create(ctx-&gt;handle);<br><span class="hljs-comment">// init function maybe use ctx-&gt;handle, so it must init at last</span><br>context_inc();<br><br>CHECKCALLING_BEGIN(ctx)<br><span class="hljs-type">int</span> r = skynet_module_instance_init(mod, inst, ctx, param);<br>CHECKCALLING_END(ctx)<br><span class="hljs-keyword">if</span> (r == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">skynet_context</span> * <span class="hljs-title">ret</span> =</span> skynet_context_release(ctx);<br><span class="hljs-keyword">if</span> (ret) &#123;<br>ctx-&gt;init = <span class="hljs-literal">true</span>;<br>&#125;<br>skynet_globalmq_push(<span class="hljs-built_in">queue</span>);<br><span class="hljs-keyword">if</span> (ret) &#123;<br>skynet_error(ret, <span class="hljs-string">&quot;LAUNCH %s %s&quot;</span>, name, param ? param : <span class="hljs-string">&quot;&quot;</span>);<br>&#125;<br><span class="hljs-keyword">return</span> ret;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>skynet_error(ctx, <span class="hljs-string">&quot;FAILED launch %s&quot;</span>, name);<br><span class="hljs-type">uint32_t</span> handle = ctx-&gt;handle;<br>skynet_context_release(ctx);<br>skynet_handle_retire(handle);<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">drop_t</span> <span class="hljs-title">d</span> =</span> &#123; handle &#125;;<br>skynet_mq_release(<span class="hljs-built_in">queue</span>, drop_message, &amp;d);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>创建服务会查询绑定<code>模块名称</code>对应的模块库，然后调用<code>create</code>接口，注册handle_id，调用<code>init</code>接口函数。<br>init接口返回0表示创建成功，返回其他表示创建失败，最终创建函数返回新ctx的指针。</p></li><li><p><strong>服务销毁</strong><br>skynet 销毁服务是通过<code>skynet_handle_retire(uint32_t handle)</code>函数执行的，不过它只是把长驻的ref给释放了，不一定在这个函数中销毁。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> skynet_context *<br><span class="hljs-title function_">skynet_context_release</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> skynet_context *ctx)</span> &#123;<br><span class="hljs-keyword">if</span> (ATOM_DEC(&amp;ctx-&gt;ref) == <span class="hljs-number">0</span>) &#123;<br>delete_context(ctx);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><span class="hljs-keyword">return</span> ctx;<br>&#125;<br></code></pre></td></tr></table></figure><p>需要当ctx.ref也就是引用计数为0时才真正销毁实例，保证多线程安全性。</p></li></ul><h1 id="n探skynet-handle"><a href="#n探skynet-handle" class="headerlink" title="n探skynet_handle"></a>n探skynet_handle</h1><p>如果说skynet_context是主角，这TM就是主角们的大别墅，看见上面skynet_context创建过程有什么,<code>skynet_handle_register</code>这TM就相当于去别墅里去拿个房卡，这个房卡就是skynet_context.handle。</p><ul><li><p><strong>房子多大</strong> 一开始有4个房间，当来了5个人，房子就扩建了，增加原来容量的一倍，人走了，别墅不缩，别墅最大容量为<strong>16,777,215</strong>。<br>如果用handle查询房间会很快<code>O1</code>的时间复杂度，因为云风采用的是hash结构存储。</p></li><li><p><strong>房间名</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">const</span> <span class="hljs-type">char</span> * <br><span class="hljs-title function_">skynet_handle_namehandle</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> handle, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span> &#123;<br>rwlock_wlock(&amp;H-&gt;lock);<br><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> * ret = _insert_name(H, name, handle);<br><br>rwlock_wunlock(&amp;H-&gt;lock);<br><br><span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以为服务创建一个别名，然后通过别名去找对应的handle实例,通过别名采用的是二分查找，时间复杂度是<code>log n</code>，名称对比还有一个<code>o n</code>的时间复杂度，所以我觉得能不用别名就不用，除非那个服务很特殊，比如logger日志服务。</p></li></ul><h1 id="n探timer-timer-event-time-node-time-list"><a href="#n探timer-timer-event-time-node-time-list" class="headerlink" title="n探timer,timer_event,time_node,time_list"></a>n探timer,timer_event,time_node,time_list</h1><p>skynet定时器非常的高效，因为timer_thread只需要关心即将到期的定时事件。</p><ul><li><p><strong>timer_event</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timer_event</span> &#123;</span><br><span class="hljs-type">uint32_t</span> handle;  <span class="hljs-comment">//注册的handle_id</span><br><span class="hljs-type">int</span> session;  <span class="hljs-comment">//绑定会话id</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>session id用于定时事件触发时，会通过消息的方式返回给handle实例，handle实例可以通过session确定定时任务触发。</p></li><li><p><strong>time_node</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timer_node</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timer_node</span> *<span class="hljs-title">next</span>;</span> <span class="hljs-comment">//下一个节点</span><br><span class="hljs-type">uint32_t</span> expire;         <span class="hljs-comment">//过期时间</span><br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p><strong>link_list</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">link_list</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timer_node</span> <span class="hljs-title">head</span>;</span>  <span class="hljs-comment">//链表头</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timer_node</span> *<span class="hljs-title">tail</span>;</span> <span class="hljs-comment">//链表尾</span><br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p><strong>timer</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timer</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">link_list</span> <span class="hljs-title">near</span>[<span class="hljs-title">TIME_NEAR</span>];</span>  <span class="hljs-comment">//近期链表 </span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">link_list</span> <span class="hljs-title">t</span>[4][<span class="hljs-title">TIME_LEVEL</span>];</span> <span class="hljs-comment">//散列链表</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">lock</span>;</span><br><span class="hljs-type">uint32_t</span> time;                     <span class="hljs-comment">//服务启动时间累加滴答数</span><br><span class="hljs-type">uint32_t</span> starttime;   <span class="hljs-comment">//服务启动时间</span><br><span class="hljs-type">uint64_t</span> current;   <span class="hljs-comment">//当前服务启动时间累加的时间</span><br><span class="hljs-type">uint64_t</span> current_point;   <span class="hljs-comment">//当前的系统时间</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>近期链表：0-255个滴答数的定时任务会加入。特征：链表里都是触发时间相同的<br>散列链表：256 &lt;&#x3D; interval &lt;&#x3D; 0xffffffff 加入。   特征：链表里触发时间不一定相同<br>滴答数： skynet的定时器精度为0.01秒，按照它算法的定义就是0.01为1个滴答数。<br>到期时间：每一个加入的定时任务都会给它标记一个到期时间（加入时定时器当前滴答数+定时滴答数）。<br>skynet每次update都会取当前时间减去上次update时间获取流逝的滴答数。<br>然后把流逝的滴答数一滴答一滴答的执行。<br>执行过程中只关心到期间隔时间为 0 到 255 滴答数的处理。暂时不关注256 &lt;&#x3D; interval &lt;&#x3D; 0xffffffff。<br>滴答滴答流逝过程中，每走完一次0到255就会有一个对应的散列链表被移动（其实就是重新加入定时器，会重新给它们定位。<br><img src="/img/skynet_frame/time.png"><br>上图是我对定时器程序的简化模拟，我画的hash槽是7+3+3+3+3,skynet_time是255+64+64+64+64个哈希槽。<br>可以把near,t[0],t[1],t[2],t[3]想象成秒，分，时，天，周</p></li><li><p><strong>插入事件</strong> 可以说是给它找位置，秒内触发就插入秒，分内触发就插入分。</p></li><li><p><strong>调整过程</strong> 用机械表来举例子吧，比如这一分钟的秒针走完了到了12点的位置，此时分钟指针指向下一秒钟，就要把下一分钟的事件重新分配到秒指针上。<br>小时，周也是这样一个逻辑，比如秒针分针都到12点，触发时针指向跳动，就要把下一个小时的事件重新分配了。</p></li></ul><p>定时器只提供的注册没有提供注销，不过有sesion,在上层实现一个注销功能还是很简单的。</p><h1 id="n探socker-server-socker-message"><a href="#n探socker-server-socker-message" class="headerlink" title="n探socker_server,socker_message"></a>n探socker_server,socker_message</h1><p>socket是skynet比较复杂的模块，总代码量有2千1百行。<br>对TCP,UDP进行了封装。</p><ul><li><p><strong>TCP</strong> FreeBSD系统下用kqueue,linux系统下用epoll,skynet epoll采用的是水平触发模式。</p></li><li><p><strong>UDP</strong> skynet封装了链接，发送，读取回调等等。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">socket</span> &#123;</span><br><span class="hljs-type">uintptr_t</span> opaque;                   <span class="hljs-comment">//handle</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">wb_list</span> <span class="hljs-title">high</span>;</span><span class="hljs-comment">//高优先级写数据列表</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">wb_list</span> <span class="hljs-title">low</span>;</span><span class="hljs-comment">//低优先级写数据列表</span><br><span class="hljs-type">int64_t</span> wb_size;<span class="hljs-comment">//写数据长度</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">socket_stat</span> <span class="hljs-title">stat</span>;</span><span class="hljs-comment">//链接统计信息 总读 总写 上次写的时间 上次读的时间</span><br><span class="hljs-keyword">volatile</span> <span class="hljs-type">uint32_t</span> sending;<br><span class="hljs-type">int</span> fd;<br><span class="hljs-type">int</span> id;<br><span class="hljs-type">uint8_t</span> protocol;<br><span class="hljs-type">uint8_t</span> type;<br><span class="hljs-type">uint16_t</span> udpconnecting;<br><span class="hljs-type">int64_t</span> warn_size;<br><span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br><span class="hljs-type">int</span> size;<br><span class="hljs-type">uint8_t</span> udp_address[UDP_ADDRESS_SIZE];<br>&#125; p;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">dw_lock</span>;</span><br><span class="hljs-type">int</span> dw_offset;<span class="hljs-comment">//偏移量n</span><br><span class="hljs-type">const</span> <span class="hljs-type">void</span> * dw_buffer;<span class="hljs-comment">//同步直写失败时，会把buffer clone到这，注册epoll写事件，异步再试</span><br><span class="hljs-type">size_t</span> dw_size;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">socket_server</span> &#123;</span><br><span class="hljs-keyword">volatile</span> <span class="hljs-type">uint64_t</span> time;<br><span class="hljs-type">int</span> recvctrl_fd;                    <span class="hljs-comment">//socket thread读取管道</span><br><span class="hljs-type">int</span> sendctrl_fd;<span class="hljs-comment">//发送管道</span><br><span class="hljs-type">int</span> checkctrl;                      <span class="hljs-comment">//标记 在处理管道消息和读取网络消息来回切换</span><br>poll_fd event_fd;<span class="hljs-comment">//create epoll的 poll_fd</span><br><span class="hljs-type">int</span> alloc_id;<span class="hljs-comment">//用于分配id</span><br><span class="hljs-type">int</span> event_n;<span class="hljs-comment">//网络事件数量</span><br><span class="hljs-type">int</span> event_index;<span class="hljs-comment">//网络事件处理下标</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">socket_object_interface</span> <span class="hljs-title">soi</span>;</span> <span class="hljs-comment">//socket对象接口</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">event</span> <span class="hljs-title">ev</span>[<span class="hljs-title">MAX_EVENT</span>];</span><span class="hljs-comment">//待处理网络事件</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">socket</span> <span class="hljs-title">slot</span>[<span class="hljs-title">MAX_SOCKET</span>];</span><span class="hljs-comment">//socket 管理池</span><br><span class="hljs-type">char</span> buffer[MAX_INFO];<span class="hljs-comment">//tcp临时数据</span><br><span class="hljs-type">uint8_t</span> udpbuffer[MAX_UDP_PACKAGE]; <span class="hljs-comment">//udp数据</span><br>fd_set rfds;<br>&#125;;<br></code></pre></td></tr></table></figure><p>socket层主要围绕读写管道、socket事件通知、处理结果下发这三个流程做一些处理。</p></li><li><p><strong>读写管道</strong> 像listen,connenct,bind,start,close,shutdown,close,nodelay接口全部是先写到发送管道，之后socket thread再读取管道，解析请求，处理请求，再转发消息到handle实例中。</p></li><li><p><strong>socket</strong> epoll的accept,connect,read,write事件通知处理，然后再把结果转发到handle实例中.</p></li><li><p><strong>处理结果</strong> 转发给handle的消息定义了一系列类型，供上层去接送处理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> SKYNET_SOCKET_TYPE_DATA 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SKYNET_SOCKET_TYPE_CONNECT 2</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SKYNET_SOCKET_TYPE_CLOSE 3</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SKYNET_SOCKET_TYPE_ACCEPT 4</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SKYNET_SOCKET_TYPE_ERROR 5</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SKYNET_SOCKET_TYPE_UDP 6</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SKYNET_SOCKET_TYPE_WARNING 7</span><br></code></pre></td></tr></table></figure><p>非常典型的上层处理方案就是云风大佬自己封装的lua层的socket.lua。</p></li></ul><h1 id="n探worker-thread"><a href="#n探worker-thread" class="headerlink" title="n探worker_thread"></a>n探worker_thread</h1><p>负责从全局队列中拿出次级队列，再从次级队列拿出消息进行处理。<br>worker线程是多个的，数量是启动配置thread设置的，每个worker_thread会根据weight适配一次处理skynet_message的数量。</p><h1 id="n探timer-thread"><a href="#n探timer-thread" class="headerlink" title="n探timer_thread"></a>n探timer_thread</h1><p>timer线程是唯一的。<br>负责时间滴答数的向前推进、定时器事件的管理、到期事件的消息投递。</p><h1 id="n探socket-thread"><a href="#n探socket-thread" class="headerlink" title="n探socket_thread"></a>n探socket_thread</h1><p>socket线程也是唯一的。<br>负责读取处理管道请求、读取处理socket事件，然后转发消息到相关的handle实例中。</p><h1 id="n探monitor-thread"><a href="#n探monitor-thread" class="headerlink" title="n探monitor_thread"></a>n探monitor_thread</h1><p>monitor线程也是唯一的.<br>负责监控worker_thread在处理消息中，是否存在阻塞的情况，就是卡，或者死循环了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>整体又捋了一遍后，我发现我对skynet c层的架构更清晰也更系统全面，零零散散的知识好像一下子整合起来的😊。</p>]]></content>
    
    
    <categories>
      
      <category>skynet</category>
      
    </categories>
    
    
    <tags>
      
      <tag>skynet_frame</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>为什么写blog</title>
    <link href="/2023/05/07/think/whywrite/"/>
    <url>/2023/05/07/think/whywrite/</url>
    
    <content type="html"><![CDATA[<h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><p>为了总结，强化学习，以及分享和记录。 </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>日常工作学习中零零散散学习到的知识不成体系，有时候学了又感觉没学，我觉得原因就是没有深度思考，一味求快，写总结会让我们对知识进行深度思考，需要总结出学习到的知识能解决什么样的问题，先提出<strong>问题场景</strong>,提供 <strong>解决方案</strong> 总结出  <strong>知识特点</strong> 再扩展 <strong>类同知识</strong> 进行 <strong>优缺点</strong> 对比 从而 在脑中构建出 <strong>知识体系网络</strong>。</p><h2 id="强化学习"><a href="#强化学习" class="headerlink" title="强化学习"></a>强化学习</h2><p>知识学到了，自己会用，但是可能只是用到了需要的部分，比较片面，我想以写blog的方式，来发现自己对哪一块还不是很清楚。需要再加深学习。</p><h2 id="分享"><a href="#分享" class="headerlink" title="分享"></a>分享</h2><p>利用<strong>费曼学习法</strong>，来验证自己的学习的成果，验证自己学的好不好最好的办法就是教会别人。过程中还能补充遗漏的知识点。</p><h2 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h2><p><strong>好记性不如烂笔头</strong>。忘记了查自己的笔记会比查网络上别人的笔记要<strong>快</strong>。</p>]]></content>
    
    
    <categories>
      
      <category>一些想法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>一些想法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>actor模型在sknyet中的应用</title>
    <link href="/2023/05/07/skynet_frame/actor/"/>
    <url>/2023/05/07/skynet_frame/actor/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Actor模型由状态（State）、行为（Behavior）和邮箱（MailBox，可以认为是一个消息队列）三部分组成：</p><h2 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h2><p>Actor模型中的状态指Actor对象的变量信息，状态由Actor模型自己管理，避免了并发环境下的锁和内存原子性等问题。</p><h2 id="行为"><a href="#行为" class="headerlink" title="行为"></a>行为</h2><p>Actor模型中的计算逻辑，通过Actor模型接收到的消息来改变Actor模型的状态。</p><h2 id="邮箱"><a href="#邮箱" class="headerlink" title="邮箱"></a>邮箱</h2><p>邮箱是Actor和Actor之间的通信桥梁，邮箱内部通过FIFO（先入先出）消息队列来存储发送方Actor的消息，接收方Actor再从邮箱队列中获取消息。</p><p><img src="/img/skynet_frame/actor.png"></p><h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><h2 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h2><p>每个actor实例的状态只能通过自己的行为修改。</p><h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>单个actor实例同时只会有一个线程在执行，类似redis只用单线程去读写内存数据，避免了多线程下的并发问题，actor修改内部状态不需要加锁。</p><h2 id="异步消息处理"><a href="#异步消息处理" class="headerlink" title="异步消息处理"></a>异步消息处理</h2><p>actor发消息并不是直接调用接口，而是类似邮件在对方邮箱放一个邮件，之后actor实例会按照先入先出的规则去处理邮件。</p><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>actor实例可以在运行中动态创建和释放。</p><h2 id="容错"><a href="#容错" class="headerlink" title="容错"></a>容错</h2><p>actor实例的断言不会导致整个程序崩溃。</p><h2 id="模型抽象"><a href="#模型抽象" class="headerlink" title="模型抽象"></a>模型抽象</h2><p>每个actor模型可以对自己的状态，行为进入定义。</p><h1 id="skynet对actor的应用"><a href="#skynet对actor的应用" class="headerlink" title="skynet对actor的应用"></a>skynet对actor的应用</h1><p>skynet通过抽象skynet_context结构体实现对actor模型的应用。</p><h2 id="skynet-context"><a href="#skynet-context" class="headerlink" title="skynet_context"></a>skynet_context</h2><p>贴一段skynet_context结构部分定义。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">skynet_context</span> &#123;</span> <br><span class="hljs-type">void</span> * instance;            <span class="hljs-comment">//实例数据</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">skynet_module</span> * <span class="hljs-title">mod</span>;</span> <span class="hljs-comment">//模型</span><br><span class="hljs-type">void</span> * cb_ud;               <span class="hljs-comment">//回调函数实例数据</span><br>skynet_cb cb;               <span class="hljs-comment">//消息回调函数</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">message_queue</span> *<span class="hljs-title">queue</span>;</span><span class="hljs-comment">//消息队列</span><br><span class="hljs-type">uint32_t</span> handle;            <span class="hljs-comment">//实例id</span><br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="状态-1"><a href="#状态-1" class="headerlink" title="状态"></a>状态</h2><p>skynet_context中的<strong>instance</strong>和<strong>cb_ud</strong>指向的是实例数据，通常<strong>cb_ud</strong>指向的就是<strong>instance</strong>指向的数据，或者是<strong>instance</strong>中的成员数据，可以认为<strong>instance</strong>和<strong>cb_ud</strong>就是对actor模型的<strong>状态</strong>定义。</p><h2 id="行为-1"><a href="#行为-1" class="headerlink" title="行为"></a>行为</h2><p>woker线程把消息传入<strong>cb</strong>回调函数处理,跟着传入的还有<strong>cb_ud</strong>。</p><h2 id="邮箱-1"><a href="#邮箱-1" class="headerlink" title="邮箱"></a>邮箱</h2><p><strong>message_queue</strong>消息队列，存放待处理消息。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>skynet通过actor模型抽象skynet服务，赋予了服务之间强隔离性和原子性，避免了频繁加锁，使得在开发中能够高效简单实现业务，同时还能高效利用多核。</p><h1 id="延伸问题"><a href="#延伸问题" class="headerlink" title="延伸问题"></a>延伸问题</h1><h2 id="actor模块是如何定义的？"><a href="#actor模块是如何定义的？" class="headerlink" title="actor模块是如何定义的？"></a>actor模块是如何定义的？</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">static void<span class="hljs-operator"> *</span><br><span class="hljs-operator"></span>get<span class="hljs-constructor">_api(<span class="hljs-params">struct</span> <span class="hljs-params">skynet_module</span> <span class="hljs-operator">*</span><span class="hljs-params">mod</span>, <span class="hljs-params">const</span> <span class="hljs-params">char</span> <span class="hljs-operator">*</span><span class="hljs-params">api_name</span>)</span> &#123;<br>size_t name_size = strlen(<span class="hljs-keyword">mod</span>-&gt;name);<br>size_t api_size = strlen(api_name);<br><span class="hljs-built_in">char</span> tmp<span class="hljs-literal">[<span class="hljs-identifier">name_size</span> + <span class="hljs-identifier">api_size</span> + <span class="hljs-number">1</span>]</span>;<br>memcpy(tmp, <span class="hljs-keyword">mod</span>-&gt;name, name_size);<br>memcpy(tmp+name_size, api_name, api_size+<span class="hljs-number">1</span>);<br><span class="hljs-built_in">char</span> *ptr = strrchr(tmp, <span class="hljs-character">&#x27;.&#x27;</span>);<br><span class="hljs-keyword">if</span> (ptr<span class="hljs-operator"> == </span>NULL) &#123;<br>ptr = tmp;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>ptr = ptr + <span class="hljs-number">1</span>;<br>&#125;<br>return dlsym(<span class="hljs-keyword">mod</span>-&gt;<span class="hljs-keyword">module</span>, ptr);<br>&#125;<br><br>static <span class="hljs-built_in">int</span><br><span class="hljs-keyword">open</span><span class="hljs-constructor">_sym(<span class="hljs-params">struct</span> <span class="hljs-params">skynet_module</span> <span class="hljs-operator">*</span><span class="hljs-params">mod</span>)</span> &#123;<br><span class="hljs-keyword">mod</span>-&gt;create = get<span class="hljs-constructor">_api(<span class="hljs-params">mod</span>, <span class="hljs-string">&quot;_create&quot;</span>)</span>;<br><span class="hljs-keyword">mod</span>-&gt;init = get<span class="hljs-constructor">_api(<span class="hljs-params">mod</span>, <span class="hljs-string">&quot;_init&quot;</span>)</span>;<br><span class="hljs-keyword">mod</span>-&gt;release = get<span class="hljs-constructor">_api(<span class="hljs-params">mod</span>, <span class="hljs-string">&quot;_release&quot;</span>)</span>;<br><span class="hljs-keyword">mod</span>-&gt;signal = get<span class="hljs-constructor">_api(<span class="hljs-params">mod</span>, <span class="hljs-string">&quot;_signal&quot;</span>)</span>;<br><br>return <span class="hljs-keyword">mod</span>-&gt;init<span class="hljs-operator"> == </span>NULL;<br>&#125;<br></code></pre></td></tr></table></figure><p>skynet c服务模块约定需要实现<code>create</code> <code>init</code> <code>release</code>  <code>signal</code>四个API接口。<br><code>create</code>负责创建实例。<br><code>init</code>负责初始化，一般是绑定<code>cb</code> <code>cb_ud</code>,返回0表示初始成功，其他表示失败。<br><code>release</code>释放实例时调用。<br><code>signal</code>通过API直接调用，接口实现需要保证线程安全。</p><h2 id="actor实例（状态）的生命周期？"><a href="#actor实例（状态）的生命周期？" class="headerlink" title="actor实例（状态）的生命周期？"></a>actor实例（状态）的生命周期？</h2><p>skynet_context实例的由<code>skynet_context_new</code>函数创建，该函数先后调用了<code>create</code>,<code>init</code>。<br>由<code>skynet_context_release</code>释放，调用skynet_context_release并不是立马释放ctx，而是原子操作<code>ctx.ref</code>减一以后为0才释放，每个操作ctx的api都需要先给ctx引用计数+1,操作完以后调用skynet_context_release释放引用计数-1。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//从通过handle_id 拿ctx实例</span><br><span class="hljs-keyword">struct</span> skynet_context * <br><span class="hljs-title function_">skynet_handle_grab</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> handle)</span> &#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">handle_storage</span> *<span class="hljs-title">s</span> =</span> H;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">skynet_context</span> * <span class="hljs-title">result</span> =</span> <span class="hljs-literal">NULL</span>;<br><br>rwlock_rlock(&amp;s-&gt;lock);<br><br><span class="hljs-type">uint32_t</span> hash = handle &amp; (s-&gt;slot_size<span class="hljs-number">-1</span>);<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">skynet_context</span> * <span class="hljs-title">ctx</span> =</span> s-&gt;slot[hash];<br><span class="hljs-keyword">if</span> (ctx &amp;&amp; skynet_context_handle(ctx) == handle) &#123;<br>result = ctx;<br>skynet_context_grab(result);<br>&#125;<br><br>rwlock_runlock(&amp;s-&gt;lock);<br><br><span class="hljs-keyword">return</span> result;<br>&#125;<br><span class="hljs-comment">//加引用计算</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">skynet_context_grab</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> skynet_context *ctx)</span> &#123;<br>ATOM_INC(&amp;ctx-&gt;ref);<span class="hljs-comment">//原子操作+1</span><br>&#125;<br><span class="hljs-comment">//减引用计数</span><br><span class="hljs-keyword">struct</span> skynet_context *<br><span class="hljs-title function_">skynet_context_release</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> skynet_context *ctx)</span> &#123;<br><span class="hljs-keyword">if</span> (ATOM_DEC(&amp;ctx-&gt;ref) == <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//原子操作-1</span><br>delete_context(ctx);<span class="hljs-comment">//释放ctx</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><span class="hljs-keyword">return</span> ctx;<br>&#125;<br><span class="hljs-comment">//在ctx实例中插入一条消息</span><br><span class="hljs-type">int</span><br><span class="hljs-title function_">skynet_context_push</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> handle, <span class="hljs-keyword">struct</span> skynet_message *message)</span> &#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">skynet_context</span> * <span class="hljs-title">ctx</span> =</span> skynet_handle_grab(handle);<span class="hljs-comment">//加引用</span><br><span class="hljs-keyword">if</span> (ctx == <span class="hljs-literal">NULL</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br>skynet_mq_push(ctx-&gt;<span class="hljs-built_in">queue</span>, message);<br>skynet_context_release(ctx);<span class="hljs-comment">//操作完减引用</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="为什么要用引用计数的方式管理ctx实例的生命周期？"><a href="#为什么要用引用计数的方式管理ctx实例的生命周期？" class="headerlink" title="为什么要用引用计数的方式管理ctx实例的生命周期？"></a>为什么要用引用计数的方式管理ctx实例的生命周期？</h2><p>skynet是多线程的框架，试想一下如下场景：2个线程同时操作ctx实例。A线程释放，B线程想给ctx插入一条消息。就会出现非常严重的问题访问<strong>野指针</strong>，也就是指针指向的内存已经释放了。</p><p><img src="/img/skynet_frame/ctx_life.png"></p><h2 id="actor队列（邮箱）消息的投递与消费？"><a href="#actor队列（邮箱）消息的投递与消费？" class="headerlink" title="actor队列（邮箱）消息的投递与消费？"></a>actor队列（邮箱）消息的投递与消费？</h2><p>消息通过<code>skynet_context_push</code>API投递。<br>由ctx在init中绑定的cb函数处理。<br>这里以skynet自带的logger服务为例子。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//skyent_error.c 部分代码，传递消息</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">skynet_message</span> <span class="hljs-title">smsg</span>;</span><br><span class="hljs-keyword">if</span> (context == <span class="hljs-literal">NULL</span>) &#123;<br>smsg.source = <span class="hljs-number">0</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>smsg.source = skynet_context_handle(context);<br>&#125;<br>smsg.session = <span class="hljs-number">0</span>;<br>smsg.data = data;<br>smsg.sz = len | ((<span class="hljs-type">size_t</span>)PTYPE_TEXT &lt;&lt; MESSAGE_TYPE_SHIFT);<br>skynet_context_push(logger, &amp;smsg);<br><br><span class="hljs-comment">//service_logger.c 部分代码</span><br><br><span class="hljs-comment">//消息回调处理函数</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span><br><span class="hljs-title function_">logger_cb</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> skynet_context * context, <span class="hljs-type">void</span> *ud, <span class="hljs-type">int</span> type, <span class="hljs-type">int</span> session, <span class="hljs-type">uint32_t</span> source, <span class="hljs-type">const</span> <span class="hljs-type">void</span> * msg, <span class="hljs-type">size_t</span> sz)</span> &#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">logger</span> * <span class="hljs-title">inst</span> =</span> ud;<br><span class="hljs-keyword">switch</span> (type) &#123;<br><span class="hljs-keyword">case</span> PTYPE_SYSTEM:<br><span class="hljs-keyword">if</span> (inst-&gt;filename) &#123;<br>inst-&gt;handle = freopen(inst-&gt;filename, <span class="hljs-string">&quot;a&quot;</span>, inst-&gt;handle);<br>&#125;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> PTYPE_TEXT:<br><span class="hljs-keyword">if</span> (inst-&gt;filename) &#123;<br><span class="hljs-type">char</span> tmp[SIZETIMEFMT];<br><span class="hljs-type">int</span> csec = timestring(ud, tmp);<br><span class="hljs-built_in">fprintf</span>(inst-&gt;handle, <span class="hljs-string">&quot;%s.%02d &quot;</span>, tmp, csec);<br>&#125;<br><span class="hljs-built_in">fprintf</span>(inst-&gt;handle, <span class="hljs-string">&quot;[:%08x] &quot;</span>, source);<br>fwrite(msg, sz , <span class="hljs-number">1</span>, inst-&gt;handle);<br><span class="hljs-built_in">fprintf</span>(inst-&gt;handle, <span class="hljs-string">&quot;\n&quot;</span>);<br>fflush(inst-&gt;handle);<br><span class="hljs-keyword">break</span>;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">int</span><br><span class="hljs-title function_">logger_init</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> logger * inst, <span class="hljs-keyword">struct</span> skynet_context *ctx, <span class="hljs-type">const</span> <span class="hljs-type">char</span> * parm)</span> &#123;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span> * r = skynet_command(ctx, <span class="hljs-string">&quot;STARTTIME&quot;</span>, <span class="hljs-literal">NULL</span>);<br>inst-&gt;starttime = strtoul(r, <span class="hljs-literal">NULL</span>, <span class="hljs-number">10</span>);<br><span class="hljs-keyword">if</span> (parm) &#123;<br>inst-&gt;handle = fopen(parm,<span class="hljs-string">&quot;a&quot;</span>);<br><span class="hljs-keyword">if</span> (inst-&gt;handle == <span class="hljs-literal">NULL</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br>inst-&gt;filename = skynet_malloc(<span class="hljs-built_in">strlen</span>(parm)+<span class="hljs-number">1</span>);<br><span class="hljs-built_in">strcpy</span>(inst-&gt;filename, parm);<br>inst-&gt;close = <span class="hljs-number">1</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>inst-&gt;handle = <span class="hljs-built_in">stdout</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (inst-&gt;handle) &#123;<br>skynet_callback(ctx, inst, logger_cb); <span class="hljs-comment">//注册消息回调函数</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>init</code>绑定<code>logger_cb</code>函数，之后如果有通过<code>skynet_context_push</code>投递消息给ctx实例，将异步调用<code>logger_cb</code>函数。</p><h2 id="如何新建一个actor模块并且处理消息（行为）？"><a href="#如何新建一个actor模块并且处理消息（行为）？" class="headerlink" title="如何新建一个actor模块并且处理消息（行为）？"></a>如何新建一个actor模块并且处理消息（行为）？</h2><p>我以新建一个<strong>dber</strong>模块为例子。<br>这个服务非常简单，用于存储最新的字符串数据(<strong>状态</strong>)，提供<code>set</code> <code>get</code>方法(<strong>行为</strong>)。<br>我们需要先定义<strong>状态</strong>数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dber</span> &#123;</span><br><span class="hljs-type">char</span> * value;<br>&#125;;<br></code></pre></td></tr></table></figure><p>然后实现 <code>_create</code> <code>_release</code> <code>_init</code> <code>_signal</code> 接口。<br>其中 <code>_signal</code>接口暂时用不到，可以不实现。<br>编写模块对<strong>模块</strong>的<strong>文件名</strong>和<strong>接口前缀名</strong>有强约束性。<br>比如我们<strong>dber</strong>模块的文件名只能写成：<code>service_dber.c</code>,文件名格式是<code>service_</code>拼接<strong>模块名称</strong><code>dber</code>。<br>接口函数名就是<strong>模块</strong>名称拼接接口名称，比如<code>_create</code>就要写成<code>dber_create</code>。<br>这样做的目的是为了方便编译、加载模块动态库、接口函数查找绑定、actor模块启动。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-keyword">define</span> CSERVICE_TEMP<br>  $<span class="hljs-variable">$(CSERVICE_PATH)</span>/$(1).so : service-src/service_$(1).c | $<span class="hljs-variable">$(CSERVICE_PATH)</span><br>$<span class="hljs-variable">$(CC)</span> $<span class="hljs-variable">$(CFLAGS)</span> $<span class="hljs-variable">$(SHARED)</span> $<span class="hljs-variable">$&lt;</span> -o $<span class="hljs-variable">$@</span> -Iskynet/skynet-src<br><span class="hljs-keyword">endef</span><br><span class="hljs-variable">$(<span class="hljs-built_in">foreach</span> v, <span class="hljs-variable">$(CSERVICE)</span>, $(<span class="hljs-built_in">eval</span> $(<span class="hljs-built_in">call</span> CSERVICE_TEMP,<span class="hljs-variable">$(v)</span>)</span>))<br></code></pre></td></tr></table></figure><p>编译service,通过文件名的约束，可以做到统一编译，只需要增加CSERVICE<strong>模块名称</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> *<br><span class="hljs-title function_">get_api</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> skynet_module *mod, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *api_name)</span> &#123;<br><span class="hljs-type">size_t</span> name_size = <span class="hljs-built_in">strlen</span>(mod-&gt;name);<br><span class="hljs-type">size_t</span> api_size = <span class="hljs-built_in">strlen</span>(api_name);<br><span class="hljs-type">char</span> tmp[name_size + api_size + <span class="hljs-number">1</span>];<br><span class="hljs-built_in">memcpy</span>(tmp, mod-&gt;name, name_size);<br><span class="hljs-built_in">memcpy</span>(tmp+name_size, api_name, api_size+<span class="hljs-number">1</span>);<br><span class="hljs-type">char</span> *ptr = <span class="hljs-built_in">strrchr</span>(tmp, <span class="hljs-string">&#x27;.&#x27;</span>);<br><span class="hljs-keyword">if</span> (ptr == <span class="hljs-literal">NULL</span>) &#123;<br>ptr = tmp;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>ptr = ptr + <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">return</span> dlsym(mod-&gt;module, ptr);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span><br><span class="hljs-title function_">open_sym</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> skynet_module *mod)</span> &#123;<br>mod-&gt;create = get_api(mod, <span class="hljs-string">&quot;_create&quot;</span>);<br>mod-&gt;init = get_api(mod, <span class="hljs-string">&quot;_init&quot;</span>);<br>mod-&gt;release = get_api(mod, <span class="hljs-string">&quot;_release&quot;</span>);<br>mod-&gt;signal = get_api(mod, <span class="hljs-string">&quot;_signal&quot;</span>);<br><br><span class="hljs-keyword">return</span> mod-&gt;init == <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>加载接口动态库，通过<strong>模块名称</strong>拼接<strong>接口名称</strong>查找API并绑定到<code>skynet_module</code>结构实例。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">skynet_module</span> * </span><br><span class="hljs-class">_<span class="hljs-title">query</span>(<span class="hljs-title">const</span> <span class="hljs-title">char</span> * <span class="hljs-title">name</span>) &#123;</span><br><span class="hljs-type">int</span> i;<br><span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>;i&lt;M-&gt;count;i++) &#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(M-&gt;m[i].name,name)==<span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">return</span> &amp;M-&gt;m[i];<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-keyword">struct</span> skynet_module * <br><span class="hljs-title function_">skynet_module_query</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> * name)</span> &#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">skynet_module</span> * <span class="hljs-title">result</span> =</span> _query(name);<br><span class="hljs-keyword">if</span> (result)<br><span class="hljs-keyword">return</span> result;<br><br>SPIN_LOCK(M)<br><br>result = _query(name); <span class="hljs-comment">// double check</span><br><br><span class="hljs-keyword">if</span> (result == <span class="hljs-literal">NULL</span> &amp;&amp; M-&gt;count &lt; MAX_MODULE_TYPE) &#123;<br><span class="hljs-type">int</span> index = M-&gt;count;<br><span class="hljs-type">void</span> * dl = _try_open(M,name);<br><span class="hljs-keyword">if</span> (dl) &#123;<br>M-&gt;m[index].name = name;<br>M-&gt;m[index].module = dl;<br><br><span class="hljs-keyword">if</span> (open_sym(&amp;M-&gt;m[index]) == <span class="hljs-number">0</span>) &#123;<br>M-&gt;m[index].name = skynet_strdup(name);<br>M-&gt;count ++;<br>result = &amp;M-&gt;m[index];<br>&#125;<br>&#125;<br>&#125;<br><br>SPIN_UNLOCK(M)<br><br><span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们在启动一个该模块actor需要通过模块名称查找对应模块的API接口。<br>明白了为何要做这种名称约束之后，我们再来实现相关接口。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;skynet.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;skynet_mq.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;skynet_server.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;time.h&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dber</span> &#123;</span><br><span class="hljs-type">char</span> * value;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> dber *<br><span class="hljs-title function_">dber_create</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dber</span> * <span class="hljs-title">inst</span> =</span> skynet_malloc(<span class="hljs-keyword">sizeof</span>(*inst));<br>inst-&gt;value = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-keyword">return</span> inst;<br>&#125;<br><br><span class="hljs-type">void</span><br><span class="hljs-title function_">dber_release</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> dber * inst)</span> &#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> != inst-&gt;value) &#123;<br>skynet_free(inst-&gt;value);<br>&#125;<br>skynet_free(inst);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span><br><span class="hljs-title function_">dber_cb</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> skynet_context * context, <span class="hljs-type">void</span> *ud, <span class="hljs-type">int</span> type, <span class="hljs-type">int</span> session, <span class="hljs-type">uint32_t</span> source, <span class="hljs-type">const</span> <span class="hljs-type">void</span> * msg, <span class="hljs-type">size_t</span> sz)</span> &#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dber</span> * <span class="hljs-title">inst</span> =</span> ud;<br><span class="hljs-keyword">switch</span> (type) &#123;<br><span class="hljs-keyword">case</span> PTYPE_SYSTEM:<br><span class="hljs-comment">//set</span><br><span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> != inst-&gt;value) &#123;<br>skynet_free(inst-&gt;value);<br>&#125;<br>inst-&gt;value = skynet_malloc(<span class="hljs-built_in">strlen</span>(msg) + <span class="hljs-number">1</span>);<br><span class="hljs-built_in">strcpy</span>(inst-&gt;value,msg);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> PTYPE_TEXT:<br><span class="hljs-comment">//get</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">skynet_message</span> <span class="hljs-title">smsg</span>;</span><br>smsg.source = skynet_context_handle(context);<br>smsg.session = <span class="hljs-number">0</span>;<br><span class="hljs-type">size_t</span> len = <span class="hljs-built_in">strlen</span>(inst-&gt;value) + <span class="hljs-number">1</span>;<br>smsg.data = skynet_malloc(len);<br><span class="hljs-built_in">strcpy</span>(smsg.data,inst-&gt;value);<br>smsg.sz = len;<br>skynet_context_push(source,&amp;smsg);<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">int</span><br><span class="hljs-title function_">dber_init</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> dber * inst, <span class="hljs-keyword">struct</span> skynet_context *ctx, <span class="hljs-type">const</span> <span class="hljs-type">char</span> * parm)</span> &#123;<br>skynet_callback(ctx, inst, dber_cb);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们在<code>create</code>中创建数据(<strong>状态</strong>)<br><code>init</code>中注册回调函数<code>dber_cb</code>;<br><code>release</code>中去释放内存占用。<br>dber_cb中我简单的约束<code>PTYPE_SYSTEM</code>消息类型为<code>set</code>方法(<strong>行为</strong>)<br><code>PTYPE_TEXT</code>消息类型为<code>get</code>方法(<strong>行为</strong>)</p><p>到此我们把这个服务模块写好了。<br>我们把它放在<code>skynet/service-src</code>目录下。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">CSERVICE</span> <span class="hljs-operator">=</span> snlua logger gate harbor dber<br></code></pre></td></tr></table></figure><p>在makefile中CSERVICE下添加dber<br>之后编译一下skynet,如果编译成功,就会在<code>skynet/cservice</code>目录下看见dber.so动态库文件。</p><p>之后我们编写一个非常简单的skynet lua服务。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> skynet = <span class="hljs-built_in">require</span> <span class="hljs-string">&quot;skynet&quot;</span><br><span class="hljs-built_in">require</span> <span class="hljs-string">&quot;skynet.manager&quot;</span><br><br>skynet.register_protocol(&#123;<br>name = <span class="hljs-string">&quot;system&quot;</span>,<br>id = skynet.PTYPE_SYSTEM,<br>pack = skynet.packstring,<br><span class="hljs-built_in">unpack</span> = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(...)</span></span> <span class="hljs-keyword">return</span> ... <span class="hljs-keyword">end</span>,<br>dispatch = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(...)</span></span><br>skynet.<span class="hljs-built_in">error</span>(<span class="hljs-string">&quot;recv system msg:&quot;</span>,...)<br><span class="hljs-keyword">end</span>,<br>&#125;)<br><br>skynet.register_protocol(&#123;<br>name = <span class="hljs-string">&quot;text&quot;</span>,<br>id = skynet.PTYPE_TEXT,<br>pack = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(...)</span></span> <span class="hljs-keyword">return</span> ... <span class="hljs-keyword">end</span>,<br><span class="hljs-built_in">unpack</span> = skynet.<span class="hljs-built_in">tostring</span>,<br>dispatch = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(...)</span></span><br>skynet.<span class="hljs-built_in">error</span>(<span class="hljs-string">&quot;recv text msg:&quot;</span>,...)<br><span class="hljs-keyword">end</span>,<br>&#125;)<br><br>skynet.start(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span><br>skynet.<span class="hljs-built_in">error</span>(<span class="hljs-string">&quot;dber_test main run&quot;</span>)<br><span class="hljs-keyword">local</span> dber = skynet.launch(<span class="hljs-string">&quot;dber&quot;</span>)<br>skynet.<span class="hljs-built_in">error</span>(<span class="hljs-string">&quot;handle:&quot;</span>,dber)<br>skynet.<span class="hljs-built_in">error</span>(skynet.send(dber,skynet.PTYPE_SYSTEM,<span class="hljs-string">&quot;hello dber&quot;</span>))<br>skynet.<span class="hljs-built_in">error</span>(skynet.send(dber,skynet.PTYPE_TEXT,<span class="hljs-string">&quot;&quot;</span>))<br><span class="hljs-keyword">end</span>)<br></code></pre></td></tr></table></figure><p>先注册<code>system</code>,<code>text</code>消息处理函数。<br>在start中我们launch <code>dber</code>模块服务。<br>然后给dber服务发送<code>PTYPE_SYSTEM</code>消息传递设置 <code>hello dber</code>字符串。<br>再发送<code>PTYPE_TEXT</code>消息获取字符串。<br><code>dber</code>服务接收到以后，会给<code>PTYPE_TEXT</code>消息发送者发送<code>PTYPE_TEXT</code>消息。<br><img src="/img/skynet_frame/dber.bmp"><br>至此我们完成对skynet actor c模块服务的创建使用😊</p>]]></content>
    
    
    <categories>
      
      <category>skynet</category>
      
    </categories>
    
    
    <tags>
      
      <tag>skynet_frame</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前言</title>
    <link href="/2023/05/03/skynet_fly_word/word_4/A_home/"/>
    <url>/2023/05/03/skynet_fly_word/word_4/A_home/</url>
    
    <content type="html"><![CDATA[<p>这个篇章主要介绍skynet_fly_demo的设计，如何基于skynet_fly_demo做开发。我将会以讲解一个个问题的方式带你走进了解skynet_fly_demo。</p><h1 id="skynet-fly-demo简介"><a href="#skynet-fly-demo简介" class="headerlink" title="skynet_fly_demo简介"></a><a href="https://github.com/huahua132/skynet_fly_demo">skynet_fly_demo</a>简介</h1><p>skynet_fly_demo是基于skynet_fly的试验性项目，目的是全面的使用<code>skynet_fly</code>的功能并验证其可行性。<br>skynet_fly_demo深度的使用了<code>skynet_fly</code>如下功能:<br><strong>orm</strong><br><strong>cluster rpc</strong><br><strong>日志切割</strong><br><strong>time_point整点报时定时器</strong><br><strong>room_game游戏房间类架构</strong><br><strong>http server</strong><br><strong>ws gate</strong><br><strong>jwt</strong></p><h1 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h1><p><img src="/img/think/skynet_fly_demo.png"></p><p>skynet_fly_demo整体的架构是为大厅房间类游戏设计的，整个后端的服务都是用<code>skynet_fly</code>实现，包括后台。实现上采用了分布式架构，保证了系统的横向扩展性。目前在<strong>8核8G虚拟机</strong>压测5000机器人，服务器机器人同机器运行，没有出现性能瓶颈。</p><h2 id="center-server（唯一服务）"><a href="#center-server（唯一服务）" class="headerlink" title="center server（唯一服务）"></a>center server（唯一服务）</h2><p>记录处理需要全服唯一的数据。比如所有玩家的账号信息。全服邮件。全服唯一ID等等。</p><h2 id="log-server-唯一服务"><a href="#log-server-唯一服务" class="headerlink" title="log server (唯一服务)"></a>log server (唯一服务)</h2><p>记录全局的日志信息。比如其他服务严重错误日志，错误堆栈（收集），这样可以通过后台方便的查看服务器有没有出现严重错误。这样服务多的时候就不必一个服一个服去翻看日志文件(这很痛苦，效率也很低)</p><h2 id="login-server-可多开"><a href="#login-server-可多开" class="headerlink" title="login server (可多开)"></a>login server (可多开)</h2><p>玩家登录注册的门户，通常流量较大。需要支持多开，必要时需要做登录排队，限流等功能。此服务保证了已登录的玩家不受未登录的玩家的流量影响。</p><h2 id="hall-server-可多开"><a href="#hall-server-可多开" class="headerlink" title="hall server (可多开)"></a>hall server (可多开)</h2><p>每个玩家注册后，都会绑定一个大厅服，玩家通过大厅服操作一下邮件、活动、任务、商店、匹配游戏等等功能。</p><h2 id="match-server-（唯一服务）"><a href="#match-server-（唯一服务）" class="headerlink" title="match server （唯一服务）"></a>match server （唯一服务）</h2><p>提供各个游戏的匹配功能，协调游戏服创建房间。</p><h2 id="game-server-可多开"><a href="#game-server-可多开" class="headerlink" title="game server (可多开)"></a>game server (可多开)</h2><p>各个游戏具体实现的游戏逻辑，玩家被分配到房间后，直连游戏服。</p><h2 id="robot-server-可多开"><a href="#robot-server-可多开" class="headerlink" title="robot server (可多开)"></a>robot server (可多开)</h2><p>各个游戏的机器人实现。</p><h2 id="admin-server-唯一服务"><a href="#admin-server-唯一服务" class="headerlink" title="admin server (唯一服务)"></a>admin server (唯一服务)</h2><p>后台服务</p>]]></content>
    
    
    <categories>
      
      <category>skynet_fly 文档</category>
      
      <category>实战篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>skynet_fly_word</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>用户是如何注册的？</title>
    <link href="/2023/05/03/skynet_fly_word/word_4/B_q/"/>
    <url>/2023/05/03/skynet_fly_word/word_4/B_q/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>skynet_fly_demo在账号上采用了传统的账号密码方式。</p><h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1><ol><li>c2s 用户调用loginserver的注册接口</li><li>s2s loginserver 调用 centerserver 注册</li><li>s2s centerserver 调用 hallserver 注册</li><li>s2c loginserver 返回注册结果</li></ol><h2 id="流程1"><a href="#流程1" class="headerlink" title="流程1"></a>流程1</h2><h3 id="涉及skynet-fly技术"><a href="#涉及skynet-fly技术" class="headerlink" title="涉及skynet_fly技术"></a>涉及skynet_fly技术</h3><pre><code class="hljs">* http server * cluster rpc</code></pre><h3 id="涉及服务"><a href="#涉及服务" class="headerlink" title="涉及服务"></a>涉及服务</h3><pre><code class="hljs">* loginserver* centerserver</code></pre><p>客户端通过http方式调用<code>user/signup</code>接口进行注册,客户端传递账号，密码，渠道号,之后loginserver rpc 调用centerserver 进行注册，为啥不让客户端直接去centerserver直接注册，因为center server只有1个，能提供的负载能力有限，我们需要通过loginserver 做一些限流或者排队措施，防止centerserver 超负载。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">--注册</span><br><span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">signup</span><span class="hljs-params">(c)</span></span><br>    <span class="hljs-keyword">local</span> req = c.req<br>    <span class="hljs-keyword">local</span> body = req.body<br>    <span class="hljs-keyword">local</span> account = body.account<br>    <span class="hljs-keyword">local</span> password = body.password<br>    <span class="hljs-keyword">local</span> channel = body.channel<br><br>    <span class="hljs-built_in">assert</span>(account, <span class="hljs-string">&quot;not account&quot;</span>)<br>    <span class="hljs-built_in">assert</span>(password, <span class="hljs-string">&quot;not passwword&quot;</span>)<br>    <span class="hljs-built_in">assert</span>(channel, <span class="hljs-string">&quot;not channel&quot;</span>)<br>    <span class="hljs-built_in">assert</span>(CHANNEL[channel], <span class="hljs-string">&quot;not exists channel&quot;</span>, channel)<br><br>    <span class="hljs-keyword">local</span> isok, errcode, errmsg = rpc_center_account.register(&#123;<br>        account = account,<br>        password = password,<br>    &#125;, channel)<br>    <span class="hljs-keyword">if</span> isok <span class="hljs-keyword">then</span><br>        rsp_body.set_rsp(c, <span class="hljs-string">&quot;success&quot;</span>)<br>    <span class="hljs-keyword">else</span><br>        rsp_body.set_rsp(c, <span class="hljs-literal">nil</span>, errcode, errmsg)<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h2 id="流程2"><a href="#流程2" class="headerlink" title="流程2"></a>流程2</h2><h3 id="涉及skynet-fly技术-1"><a href="#涉及skynet-fly技术-1" class="headerlink" title="涉及skynet_fly技术"></a>涉及skynet_fly技术</h3><pre><code class="hljs">* cluster rpc* orm</code></pre><h3 id="涉及服务-1"><a href="#涉及服务-1" class="headerlink" title="涉及服务"></a>涉及服务</h3><pre><code class="hljs">* centerserver* hallserver</code></pre><p>由于centerserver只有一个，它记录了所以玩家的账号信息，所以有必要对玩家的账号信息进行分表处理,我用orm为账号分了10个表。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs lua">   <span class="hljs-comment">-- orm</span><br>orm_table_m = &#123;<br>launch_seq = <span class="hljs-number">5000</span>,<br>launch_num = <span class="hljs-number">11</span>,<br>mod_args = &#123;<br>&#123;instance_name = <span class="hljs-string">&quot;account_1&quot;</span>,orm_plug  = <span class="hljs-string">&quot;orm_entity.account_entity&quot;</span>&#125;,<br>           &#123;instance_name = <span class="hljs-string">&quot;account_2&quot;</span>,orm_plug  = <span class="hljs-string">&quot;orm_entity.account_entity&quot;</span>&#125;,<br>           &#123;instance_name = <span class="hljs-string">&quot;account_3&quot;</span>,orm_plug  = <span class="hljs-string">&quot;orm_entity.account_entity&quot;</span>&#125;,<br>           &#123;instance_name = <span class="hljs-string">&quot;account_4&quot;</span>,orm_plug  = <span class="hljs-string">&quot;orm_entity.account_entity&quot;</span>&#125;,<br>           &#123;instance_name = <span class="hljs-string">&quot;account_5&quot;</span>,orm_plug  = <span class="hljs-string">&quot;orm_entity.account_entity&quot;</span>&#125;,<br>           &#123;instance_name = <span class="hljs-string">&quot;account_6&quot;</span>,orm_plug  = <span class="hljs-string">&quot;orm_entity.account_entity&quot;</span>&#125;,<br>           &#123;instance_name = <span class="hljs-string">&quot;account_7&quot;</span>,orm_plug  = <span class="hljs-string">&quot;orm_entity.account_entity&quot;</span>&#125;,<br>           &#123;instance_name = <span class="hljs-string">&quot;account_8&quot;</span>,orm_plug  = <span class="hljs-string">&quot;orm_entity.account_entity&quot;</span>&#125;,<br>           &#123;instance_name = <span class="hljs-string">&quot;account_9&quot;</span>,orm_plug  = <span class="hljs-string">&quot;orm_entity.account_entity&quot;</span>&#125;,<br>           &#123;instance_name = <span class="hljs-string">&quot;account_10&quot;</span>,orm_plug = <span class="hljs-string">&quot;orm_entity.account_entity&quot;</span>&#125;,<br><br>           <span class="hljs-comment">--自增id分配</span><br>           &#123;instance_name = <span class="hljs-string">&quot;allocid&quot;</span>,   orm_plug = <span class="hljs-string">&quot;orm_entity.allocid_entity&quot;</span>&#125;,<br>&#125;<br>&#125;,<br></code></pre></td></tr></table></figure><p>如何映射到表，通常账号是不支持更改的，我们直接使用账号尾部字符编码 mod 分表数量得到一个索引进行映射。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">--注册</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">M.register</span><span class="hljs-params">(account_info, channel)</span></span> <br>    <span class="hljs-keyword">local</span> cli = cluster_client:instance(<span class="hljs-string">&quot;centerserver&quot;</span>, <span class="hljs-string">&quot;account_m&quot;</span>)<br>    cli:set_mod_num(sbyte(account_info.account, account_info.account:<span class="hljs-built_in">len</span>()))<br>    <span class="hljs-keyword">local</span> ret = cli:one_mod_call(<span class="hljs-string">&quot;register&quot;</span>, account_info, channel)<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> ret <span class="hljs-keyword">then</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">end</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">table</span>.<span class="hljs-built_in">unpack</span>(ret.result)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>注册到大厅服，我们需要做两件事情</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> MAX_INCRID = <span class="hljs-number">9999999</span><br><span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">register</span><span class="hljs-params">(account_info, channel)</span></span><br>    <span class="hljs-built_in">assert</span>(channel &lt;= <span class="hljs-number">9999</span>, <span class="hljs-string">&quot;overflow  channel = &quot;</span>,channel)<br>    <span class="hljs-keyword">local</span> account = account_info.account <span class="hljs-comment">--账号</span><br>    <span class="hljs-built_in">assert</span>(account:<span class="hljs-built_in">len</span>() &gt;= <span class="hljs-number">6</span>, <span class="hljs-string">&quot;account not long enough&quot;</span>)<br>    <span class="hljs-keyword">local</span> orm_clinet = get_orm_by_account(account)<br>    <span class="hljs-keyword">if</span> orm_clinet:get_one_entry(account) <span class="hljs-keyword">then</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, CODE.EXISTS_USER, <span class="hljs-string">&quot;EXISTS_USER&quot;</span><br>    <span class="hljs-keyword">end</span><br><br>    <span class="hljs-keyword">local</span> module_id, svr_id = rpc_hallserver_player_m.get_module_id()<br>    <span class="hljs-built_in">assert</span>(module_id, <span class="hljs-string">&quot;register err &quot;</span>)<br><br>    <span class="hljs-keyword">local</span> incrid = g_alloc_client:incr(module_id)<br>    <span class="hljs-built_in">assert</span>(incrid &lt;= MAX_INCRID, <span class="hljs-string">&quot;incr overflow&quot;</span>)<br>    <span class="hljs-keyword">local</span> player_id = player_util.builder_player_id(channel, svr_id, incrid)<br>    <span class="hljs-keyword">local</span> ret = rpc_hallserver_player_m.register(player_id, account)<br>    <span class="hljs-built_in">assert</span>(ret, <span class="hljs-string">&quot;register err&quot;</span>)<br><br>    account_info.key = crypt.randomkey()<br>    account_info.password = crypt_util.HMAC.SHA256(account_info.password, account_info.key)<br>    account_info.key = crypt.base64encode(account_info.key)<br>    account_info.player_id = player_id<br>    account_info.hall_server_id = svr_id<br>    account_info.channel = channel<br>    account_info.create_time = time_util.<span class="hljs-built_in">time</span>()<br>    <span class="hljs-keyword">if</span> orm_clinet:create_one_entry(account_info) <span class="hljs-keyword">then</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><ol><li><p>选择大厅服</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- 获取自增ID所属的模块ID</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">M.get_module_id</span><span class="hljs-params">()</span></span><br>    <span class="hljs-keyword">local</span> cli = cluster_client:instance(<span class="hljs-string">&quot;hallserver&quot;</span>, <span class="hljs-string">&quot;player_m&quot;</span>)<br>    <span class="hljs-keyword">local</span> ret = cli:one_balance_call(<span class="hljs-string">&quot;get_module_id&quot;</span>)<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> ret <span class="hljs-keyword">then</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">end</span><br><br>    <span class="hljs-keyword">local</span> cluster_name = ret.cluster_name<br>    <span class="hljs-keyword">local</span> result = ret.result<br>    <span class="hljs-keyword">local</span> module_id = result[<span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">local</span> svr_id = <span class="hljs-built_in">tonumber</span>(string_util.split(cluster_name, <span class="hljs-string">&#x27;:&#x27;</span>)[<span class="hljs-number">2</span>])<br>    <span class="hljs-keyword">return</span> module_id, svr_id<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p> 目前我才用的简单轮询负载均衡，这里也可以定制做其他负载均衡的策略。<br> <code>rpc_hallserver_player_m.get_module_id</code> 调用实现采用了banlance简单负载均衡的方式，假如开启了hallserver1,hallserver2,调用此接口4次返回的svr_id将会是1，2，1，2。<br> module_id是对应hallserver绑定的自增模块ID,分配玩家ID，为了避免ID重复我们需要一个自增ID分配器，使用orm来做就是一个非常不错的选择。自增ID的orm可以配置为永久缓存，自增的时候不需要访问到数据库，非常便捷，快速。</p></li><li><p>分配玩家ID</p><p> 由于架构的设计玩家ID会跟指定的大厅服绑定，我们可以让玩家ID携带一些额外信息，比如大厅服的ID，这样其他服想拿取玩家的数据时，通过玩家ID就能知道访问哪个服务器。</p></li></ol><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">--构建玩家ID</span><br><span class="hljs-comment">--由于js没有long类型，最大能表示 2^53-1的整数，所以调整一下ID结构,为了尽可能的兼容所有客户端</span><br><span class="hljs-comment">-- 9      0071      9925   4740991      (1个能注册1千万-1个账号)</span><br><span class="hljs-comment">-- 预留位 渠道id    服务id   自增id</span><br><br><span class="hljs-keyword">local</span> MAX_INCRID = <span class="hljs-number">9999999</span><br><span class="hljs-keyword">local</span> INCRID_LIMIT = MAX_INCRID + <span class="hljs-number">1</span><br><span class="hljs-keyword">local</span> MAX_CHANELLID = <span class="hljs-number">9999</span><br><span class="hljs-keyword">local</span> CHANELLID_LIMIT = MAX_CHANELLID + <span class="hljs-number">1</span><br><span class="hljs-keyword">local</span> MAX_SVRID = <span class="hljs-number">9999</span><br><span class="hljs-keyword">local</span> SVRID_LIMIT = MAX_SVRID + <span class="hljs-number">1</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">M.builder_player_id</span><span class="hljs-params">(channel_id, svr_id, incrid)</span></span><br>    <span class="hljs-built_in">assert</span>(channel_id &lt;= MAX_CHANELLID, <span class="hljs-string">&quot;channel_id overflow&quot;</span>)<br>    <span class="hljs-built_in">assert</span>(svr_id &lt;= MAX_SVRID, <span class="hljs-string">&quot;svr_id overflow&quot;</span>)<br>    <span class="hljs-built_in">assert</span>(incrid &lt;= MAX_INCRID, <span class="hljs-string">&quot;incr overflow&quot;</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">tonumber</span>(<span class="hljs-built_in">string</span>.<span class="hljs-built_in">format</span>(<span class="hljs-string">&quot;1%04d%04d%07d&quot;</span>, channel_id, svr_id, incrid))<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h2 id="流程3"><a href="#流程3" class="headerlink" title="流程3"></a>流程3</h2><h3 id="涉及skynet-fly技术-2"><a href="#涉及skynet-fly技术-2" class="headerlink" title="涉及skynet_fly技术"></a>涉及skynet_fly技术</h3><pre><code class="hljs">* cluster rpc</code></pre><h3 id="涉及服务-2"><a href="#涉及服务-2" class="headerlink" title="涉及服务"></a>涉及服务</h3><pre><code class="hljs">* centerserver* hallserver</code></pre><p>分配创建好对应的玩家ID后，就会去对应的hallserver创建好玩家数据。<code>rpc_hallserver_player_m.register(player_id, account)</code>。<br>到这RPC请求的过程已经走完了，轮到了回复。<br>hallserver 回复 centerserver 注册结果。<br>centerserver 回复 loginserver 注册结果。</p><h2 id="流程4"><a href="#流程4" class="headerlink" title="流程4"></a>流程4</h2><h3 id="涉及skynet-fly技术-3"><a href="#涉及skynet-fly技术-3" class="headerlink" title="涉及skynet_fly技术"></a>涉及skynet_fly技术</h3><pre><code class="hljs">* cluster rpc</code></pre><p>loginserver 回复 客户端 注册结果。至此注册流程结束。</p>]]></content>
    
    
    <categories>
      
      <category>skynet_fly 文档</category>
      
      <category>实战篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>skynet_fly_word</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>用户是如何登录的？</title>
    <link href="/2023/05/03/skynet_fly_word/word_4/C_q/"/>
    <url>/2023/05/03/skynet_fly_word/word_4/C_q/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>skynet_fly_demo在账号上采用了传统的账号密码方式。</p><h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1><ol><li>c2s 用户调用loginserver的登录接口</li><li>s2s loginserver 调用 centerserver 验证账号，密码</li><li>s2s loginserver 调用 hallserver 生成token</li><li>s2c loginserver 返回登录结果和token</li><li>c2s 连接大厅服，发送登录请求，hallserver验证token</li><li>s2c hallserver 回复登录结果</li></ol><h2 id="流程1"><a href="#流程1" class="headerlink" title="流程1"></a>流程1</h2><h3 id="涉及skynet-fly技术"><a href="#涉及skynet-fly技术" class="headerlink" title="涉及skynet_fly技术"></a>涉及skynet_fly技术</h3><pre><code class="hljs">* http server * cluster rpc</code></pre><h3 id="涉及服务"><a href="#涉及服务" class="headerlink" title="涉及服务"></a>涉及服务</h3><pre><code class="hljs">* loginserver* centerserver</code></pre><p>客户端通过http方式调用<code>user/login</code>接口进行注册,客户端传递账号，密码,之后loginserver rpc 调用centerserver 进行登录验证。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">--登录</span><br><span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">login</span><span class="hljs-params">(c)</span></span><br>    <span class="hljs-keyword">local</span> req = c.req<br>    <span class="hljs-keyword">local</span> body = req.body<br>    <span class="hljs-keyword">local</span> account = body.account<br>    <span class="hljs-keyword">local</span> password = body.password<br>    <span class="hljs-built_in">assert</span>(account, <span class="hljs-string">&quot;not account&quot;</span>)<br>    <span class="hljs-built_in">assert</span>(password, <span class="hljs-string">&quot;not passwword&quot;</span>)<br><br>    <span class="hljs-keyword">local</span> isok, errcode, errmsg = rpc_center_account.auth(account, password)<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> isok <span class="hljs-keyword">then</span><br>        rsp_body.set_rsp(c, <span class="hljs-literal">nil</span>, errcode, errmsg)<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">local</span> player_id, hall_server_id = errcode, errmsg<br>        <span class="hljs-keyword">local</span> host = rpc_hall_player.get_host(player_id)<br>        <span class="hljs-built_in">assert</span>(host, <span class="hljs-string">&quot;can`t get host&quot;</span>)<br>        <span class="hljs-keyword">local</span> token = rpc_hall_player.create_token(player_id, ENUM.LOGIN_TOKEN_TIME_OUT)<br>        <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">type</span>(token) == <span class="hljs-string">&quot;string&quot;</span>, <span class="hljs-string">&quot;create token err &quot;</span>)<br>        rsp_body.set_rsp(c, &#123;<br>            token = token,<br>            host = host,<br>            player_id = player_id,<br>        &#125;)<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h2 id="流程2"><a href="#流程2" class="headerlink" title="流程2"></a>流程2</h2><h3 id="涉及skynet-fly技术-1"><a href="#涉及skynet-fly技术-1" class="headerlink" title="涉及skynet_fly技术"></a>涉及skynet_fly技术</h3><pre><code class="hljs">* cluster rpc* orm</code></pre><h3 id="涉及服务-1"><a href="#涉及服务-1" class="headerlink" title="涉及服务"></a>涉及服务</h3><pre><code class="hljs">* loginserver* centerserver</code></pre><p>调用<code>rpc_center_account.auth(account, password)</code> 到centerserver 验证账号密码。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">--验证登录</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CMD.auth</span><span class="hljs-params">(account, password)</span></span><br>    <span class="hljs-keyword">local</span> orm_clinet = get_orm_by_account(account)<br>    <span class="hljs-keyword">local</span> account_info = orm_clinet:get_one_entry(account)<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> account_info <span class="hljs-keyword">then</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, CODE.NOT_USER, <span class="hljs-string">&quot;NOT_USER&quot;</span><br>    <span class="hljs-keyword">end</span><br><br>    password = crypt_util.HMAC.SHA256(password, crypt.base64decode(account_info.key))<br>    <span class="hljs-keyword">if</span> account_info.password ~= password <span class="hljs-keyword">then</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, CODE.ERR_PASSWORD, <span class="hljs-string">&quot;ERR_PASSWORD&quot;</span><br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-comment">--log.info(&quot;auth &gt;&gt;&gt;&gt;&gt; :&quot;, account_info)</span><br>    account_info.last_login_time = time_util.<span class="hljs-built_in">time</span>()<br>    orm_clinet:change_save_one_entry(account_info)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>, account_info.player_id, account_info.hall_server_id<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">--注册</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">M.register</span><span class="hljs-params">(account_info, channel)</span></span> <br>    <span class="hljs-keyword">local</span> cli = cluster_client:instance(<span class="hljs-string">&quot;centerserver&quot;</span>, <span class="hljs-string">&quot;account_m&quot;</span>)<br>    cli:set_mod_num(sbyte(account_info.account, account_info.account:<span class="hljs-built_in">len</span>()))<br>    <span class="hljs-keyword">local</span> ret = cli:one_mod_call(<span class="hljs-string">&quot;register&quot;</span>, account_info, channel)<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> ret <span class="hljs-keyword">then</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">end</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">table</span>.<span class="hljs-built_in">unpack</span>(ret.result)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>成功后，进入到流程3通知大厅服为该玩家创建登录的token。</p><h2 id="流程3"><a href="#流程3" class="headerlink" title="流程3"></a>流程3</h2><h3 id="涉及skynet-fly技术-2"><a href="#涉及skynet-fly技术-2" class="headerlink" title="涉及skynet_fly技术"></a>涉及skynet_fly技术</h3><pre><code class="hljs">* cluster rpc</code></pre><h3 id="涉及服务-2"><a href="#涉及服务-2" class="headerlink" title="涉及服务"></a>涉及服务</h3><pre><code class="hljs">* loginserver* hallserver</code></pre><p>通过<code>rpc_hall_player.create_token(player_id, ENUM.LOGIN_TOKEN_TIME_OUT)</code>调用得到token</p><h2 id="流程4"><a href="#流程4" class="headerlink" title="流程4"></a>流程4</h2><h3 id="涉及skynet-fly技术-3"><a href="#涉及skynet-fly技术-3" class="headerlink" title="涉及skynet_fly技术"></a>涉及skynet_fly技术</h3><pre><code class="hljs">* cluster rpc</code></pre><p>把得到的token返回给客户端。</p><h2 id="流程5"><a href="#流程5" class="headerlink" title="流程5"></a>流程5</h2><h3 id="涉及skynet-fly技术-4"><a href="#涉及skynet-fly技术-4" class="headerlink" title="涉及skynet_fly技术"></a>涉及skynet_fly技术</h3><pre><code class="hljs">* ws gate</code></pre><p>客户端拿到hallserver的连接host和token通过ws 建立连接，进行登录，hallserver收到登录消息，进去token验证</p><h2 id="流程6"><a href="#流程6" class="headerlink" title="流程6"></a>流程6</h2><p>验证通过返回登录成功</p>]]></content>
    
    
    <categories>
      
      <category>skynet_fly 文档</category>
      
      <category>实战篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>skynet_fly_word</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>用户是如何匹配进入到游戏的？</title>
    <link href="/2023/05/03/skynet_fly_word/word_4/E_q/"/>
    <url>/2023/05/03/skynet_fly_word/word_4/E_q/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>目前domo中实现了一个完整的游戏，中国象棋，实现了对应用cocos creator实现的客户端。之后做了匹配逻辑，匹配逻辑的表现是仿照LOL英雄联盟做的。</p><h1 id="匹配进入游戏流程"><a href="#匹配进入游戏流程" class="headerlink" title="匹配进入游戏流程"></a>匹配进入游戏流程</h1><ol><li>c2s 玩家请求hallserver匹配</li><li>s2s hallserver请求matchserver匹配</li><li>matchserver 定时执行撮合逻辑</li><li>s2s matchserver找到撮合对象后，请求对应gameserver游戏服分配房间，生成token并记录到redis</li><li>s2s matchserver 通知 到对应玩家的hallserver匹配成功</li><li>s2c hallserver 通知 客户端匹配成功</li><li>cs2 客户端请求hallserver接受对局</li><li>s2s hallserver 通知 matchserver接受对局</li><li>s2s matchserver 统计到所有玩家接受对局后，请求对应游戏服记录游戏房间信息，通知玩家对应hallserver对局开始</li><li>s2c hallserver 通知玩家对局开始</li></ol><h2 id="流程1-c2s-玩家请求hallserver匹配"><a href="#流程1-c2s-玩家请求hallserver匹配" class="headerlink" title="流程1 c2s 玩家请求hallserver匹配"></a>流程1 c2s 玩家请求hallserver匹配</h2><h3 id="涉及skynet-fly技术"><a href="#涉及skynet-fly技术" class="headerlink" title="涉及skynet_fly技术"></a>涉及skynet_fly技术</h3><pre><code class="hljs">* cluster rpc</code></pre><h3 id="涉及服务"><a href="#涉及服务" class="headerlink" title="涉及服务"></a>涉及服务</h3><pre><code class="hljs">* hallserver* matchserver</code></pre><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">--请求匹配</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">M.do_match_game</span><span class="hljs-params">(player_id, pack_body)</span></span><br>    <span class="hljs-comment">--log.info(&quot;do_match_game &gt;&gt;&gt; &quot;,player_id, pack_body)</span><br>    <span class="hljs-keyword">local</span> game_id = pack_body.game_id<br>    <span class="hljs-keyword">local</span> game_server = GAME_ID_ENUM[game_id]<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> game_server <span class="hljs-keyword">then</span><br>        <span class="hljs-built_in">log</span>.<span class="hljs-built_in">error</span>(<span class="hljs-string">&quot;do_match_game not exists gameid &quot;</span>, game_id)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, errorcode.GAME_NOT_EXISTS, <span class="hljs-string">&quot;GAME_NOT_EXISTS&quot;</span><br>    <span class="hljs-keyword">end</span><br><br>    <span class="hljs-keyword">local</span> game_room_info = game_redis.get_game_room_info(player_id)<br>    <span class="hljs-keyword">if</span> game_room_info <span class="hljs-keyword">and</span> <span class="hljs-built_in">next</span>(game_room_info) <span class="hljs-keyword">then</span><br>        <span class="hljs-built_in">log</span>.<span class="hljs-built_in">error</span>(<span class="hljs-string">&quot;exists game_room_info &quot;</span>,player_id, game_room_info)<br>        <span class="hljs-keyword">return</span> <br>    <span class="hljs-keyword">end</span><br><br>    <span class="hljs-comment">--log.info(&quot;do_match_game2 &gt;&gt;&gt; &quot;,player_id, pack_body)</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> rpc_matchserver_match.<span class="hljs-built_in">match</span>(game_server, player_id) <span class="hljs-keyword">then</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-comment">--log.info(&quot;do_match_game3 &gt;&gt;&gt; &quot;,player_id, pack_body)</span><br>    <span class="hljs-comment">--回复匹配</span><br>    match_msg:match_game_res(player_id, &#123;game_id = game_id&#125;)<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>玩家请求匹配游戏，指定游戏ID,通过游戏ID索引找到对应游戏服名称，然后通过<code>rpc_matchserver_match.match(game_server, player_id)</code>rpc传递到匹配服。</p><h2 id="流程2-s2s-hallserver请求matchserver匹配"><a href="#流程2-s2s-hallserver请求matchserver匹配" class="headerlink" title="流程2 s2s hallserver请求matchserver匹配"></a>流程2 s2s hallserver请求matchserver匹配</h2><h3 id="涉及skynet-fly技术-1"><a href="#涉及skynet-fly技术-1" class="headerlink" title="涉及skynet_fly技术"></a>涉及skynet_fly技术</h3><pre><code class="hljs">* cluster rpc</code></pre><h3 id="涉及服务-1"><a href="#涉及服务-1" class="headerlink" title="涉及服务"></a>涉及服务</h3><pre><code class="hljs">* hallserver* matchserver</code></pre><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">--匹配</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">M.match</span><span class="hljs-params">(game_server, player_id)</span></span><br>    <span class="hljs-keyword">local</span> ret = cluster_client:instance(<span class="hljs-string">&quot;matchserver&quot;</span>, <span class="hljs-string">&quot;match_m&quot;</span>, game_server):one_balance_call_by_name(<span class="hljs-string">&quot;match&quot;</span>, player_id)<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> ret <span class="hljs-keyword">then</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">end</span><br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">table</span>.<span class="hljs-built_in">unpack</span>(ret.result)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p><code>cluster_client:instance(&quot;matchserver&quot;, &quot;match_m&quot;, game_server):one_balance_call_by_name(&quot;match&quot;, player_id)</code>这个语句的意思是发给<strong>matchserver</strong>中的<strong>match_m</strong>服务one_balance_call_by_name意思是在所有<strong>match_m</strong>中<strong>instance_name</strong>为<strong>game_server</strong>的服务中进行简单轮询负载均衡。</p><p>match_m的启动配置</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">--匹配逻辑</span><br>   match_m = &#123;<br>       launch_seq = <span class="hljs-number">5</span>,<br>       launch_num = <span class="hljs-number">2</span>,<br>       mod_args = &#123;<br>           &#123;instance_name = <span class="hljs-string">&quot;chinese_chess&quot;</span>&#125;,<br>           &#123;instance_name = <span class="hljs-string">&quot;digitalbomb&quot;</span>&#125;,<br>       &#125;<br>   &#125;,<br></code></pre></td></tr></table></figure><p>可以看到，match_m启动了2个，一个instance_name &#x3D; chinese_chess, 一个为 digitalbomb<br>在我们想为chinese_chess匹配时就是这样调用 <code>cluster_client:instance(&quot;matchserver&quot;, &quot;match_m&quot;, &#39;chinese_chess&#39;):one_balance_call_by_name(&quot;match&quot;, player_id)</code></p><h2 id="流程3-s2s-matchserver-定时执行撮合逻辑"><a href="#流程3-s2s-matchserver-定时执行撮合逻辑" class="headerlink" title="流程3 s2s matchserver 定时执行撮合逻辑"></a>流程3 s2s matchserver 定时执行撮合逻辑</h2><p>match_m启动了2个间隔5秒的定时器，一个用于同步指定instance_name游戏服的游戏房间信息用于负载均衡。一个用于撮合匹配。</p><h2 id="流程4-s2s-matchserver找到撮合对象后，请求对应gameserver游戏服分配房间，生成token并记录到redis"><a href="#流程4-s2s-matchserver找到撮合对象后，请求对应gameserver游戏服分配房间，生成token并记录到redis" class="headerlink" title="流程4 s2s matchserver找到撮合对象后，请求对应gameserver游戏服分配房间，生成token并记录到redis"></a>流程4 s2s matchserver找到撮合对象后，请求对应gameserver游戏服分配房间，生成token并记录到redis</h2><h3 id="涉及skynet-fly技术-2"><a href="#涉及skynet-fly技术-2" class="headerlink" title="涉及skynet_fly技术"></a>涉及skynet_fly技术</h3><pre><code class="hljs">* cluster rpc* redis script</code></pre><h3 id="涉及服务-2"><a href="#涉及服务-2" class="headerlink" title="涉及服务"></a>涉及服务</h3><pre><code class="hljs">* hallserver* matchserver</code></pre><p>匹配成功后，会先把玩家剔除出集合,这里需要用到redis的脚本调用，由于这个过程有异步，可能玩家在这个过程中已经取消匹配了，所以需要用脚本检查所有玩家是否存在，然后再剔除出去。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">--清除出redis匹配集合</span><br>           <span class="hljs-keyword">local</span> script_str = <span class="hljs-string">[[</span><br><span class="hljs-string">               local key = KEYS[1]</span><br><span class="hljs-string">               for i = 1,#ARGV do</span><br><span class="hljs-string">                   local player_id = ARGV[i]</span><br><span class="hljs-string">                   local rank = redis.call(&#x27;zrank&#x27;, key, player_id)</span><br><span class="hljs-string">                   if not rank then</span><br><span class="hljs-string">                       return 0</span><br><span class="hljs-string">                   end</span><br><span class="hljs-string">               end</span><br><span class="hljs-string"></span><br><span class="hljs-string">               for i = 1,#ARGV do</span><br><span class="hljs-string">                   redis.call(&#x27;zrem&#x27;, key, ARGV[i])</span><br><span class="hljs-string">               end</span><br><span class="hljs-string">               </span><br><span class="hljs-string">               return 1</span><br><span class="hljs-string">           ]]</span><br></code></pre></td></tr></table></figure><h2 id="流程5-s2s-matchserver-通知-到对应玩家的hallserver匹配成功"><a href="#流程5-s2s-matchserver-通知-到对应玩家的hallserver匹配成功" class="headerlink" title="流程5  s2s matchserver 通知 到对应玩家的hallserver匹配成功"></a>流程5  s2s matchserver 通知 到对应玩家的hallserver匹配成功</h2><p>剔除之后记录关键的房间信息，然后通过player_id找到玩家对应的大厅服的服务ID，通过<strong>byid_mod_send</strong>通知到对应的游戏服。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">--通知大厅服，匹配成功了</span><br><span class="hljs-keyword">for</span> j,player_id <span class="hljs-keyword">in</span> <span class="hljs-built_in">ipairs</span>(match_list) <span class="hljs-keyword">do</span><br>    <span class="hljs-keyword">local</span> svr_id = player_util.get_svr_id_by_player_id(player_id)<br>    <span class="hljs-comment">--log.info(&quot;get_svr_id_by_player_id &gt;&gt;&gt; &quot;,player_id, svr_id)</span><br>    <span class="hljs-keyword">local</span> hallcli = cluster_client:instance(<span class="hljs-string">&quot;hallserver&quot;</span>, <span class="hljs-string">&quot;room_game_hall_m&quot;</span>)<br>    hallcli:set_svr_id(svr_id)              <span class="hljs-comment">--指定服</span><br>    hallcli:set_mod_num(player_id)          <span class="hljs-comment">--指定mod_num </span><br>    hallcli:byid_mod_send(<span class="hljs-string">&quot;match_succ&quot;</span>, player_id, session_id, GAME_ID_ENUM[module_info.get_cfg().instance_name], ENUM.MATCH_ACCEPT_TIME_OUT)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h2 id="流程6-s2c-hallserver-通知-客户端匹配成功"><a href="#流程6-s2c-hallserver-通知-客户端匹配成功" class="headerlink" title="流程6 s2c hallserver 通知 客户端匹配成功"></a>流程6 s2c hallserver 通知 客户端匹配成功</h2><p>hallserver 再通知玩家匹配成功了</p><h2 id="流程7-cs2-客户端请求hallserver接受对局"><a href="#流程7-cs2-客户端请求hallserver接受对局" class="headerlink" title="流程7 cs2 客户端请求hallserver接受对局"></a>流程7 cs2 客户端请求hallserver接受对局</h2><p>玩家需要在指定时间内接受对局，超时或者拒绝后，客户端等待定时器结束，进行重试匹配。</p><h2 id="流程8-s2s-hallserver-通知-matchserver接受对局"><a href="#流程8-s2s-hallserver-通知-matchserver接受对局" class="headerlink" title="流程8 s2s hallserver 通知 matchserver接受对局"></a>流程8 s2s hallserver 通知 matchserver接受对局</h2><p>match server 收到接受对局，记录接受数量</p><h2 id="流程9-s2s-matchserver-统计到所有玩家接受对局后，请求对应游戏服记录游戏房间信息，通知玩家对应hallserver对局开始"><a href="#流程9-s2s-matchserver-统计到所有玩家接受对局后，请求对应游戏服记录游戏房间信息，通知玩家对应hallserver对局开始" class="headerlink" title="流程9 s2s matchserver 统计到所有玩家接受对局后，请求对应游戏服记录游戏房间信息，通知玩家对应hallserver对局开始"></a>流程9 s2s matchserver 统计到所有玩家接受对局后，请求对应游戏服记录游戏房间信息，通知玩家对应hallserver对局开始</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">--通知游戏服记录游戏房间信息</span><br>g_game_cli:set_svr_id(svr_id)<br><span class="hljs-keyword">local</span> ret = g_game_cli:byid_mod_call(<span class="hljs-string">&quot;set_game_room_info&quot;</span>, game_info_map) <span class="hljs-comment">--记录游戏房间信息</span><br><span class="hljs-comment">--log.info(&quot;set_game_room_info ret &gt;&gt;&gt;&quot;, ret)</span><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> ret <span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">log</span>.warn(<span class="hljs-string">&quot;set_game_room_info err &quot;</span>, svr_name, svr_id, table_id)<br>    <span class="hljs-keyword">return</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">for</span> l_player_id,info <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(game_info_map) <span class="hljs-keyword">do</span><br>    <span class="hljs-comment">--通知加入对局</span><br>    <span class="hljs-keyword">local</span> svr_id = player_util.get_svr_id_by_player_id(l_player_id)<br>    <span class="hljs-comment">--log.info(&quot;get_svr_id_by_player_id &gt;&gt;&gt; &quot;,l_player_id, svr_id)</span><br>    <span class="hljs-keyword">local</span> hallcli = cluster_client:instance(<span class="hljs-string">&quot;hallserver&quot;</span>, <span class="hljs-string">&quot;room_game_hall_m&quot;</span>)<br>    hallcli:set_svr_id(svr_id)                <span class="hljs-comment">--指定服</span><br>    hallcli:set_mod_num(l_player_id)          <span class="hljs-comment">--指定mod_num </span><br>    hallcli:byid_mod_send(<span class="hljs-string">&quot;match_join_game&quot;</span>, l_player_id, info.token, host, table_id)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>set_game_room_info 会把房间信息记录到redis,在退出房间的时候清除，这样方便做重连。</p><h2 id="流程10-s2c-hallserver-通知玩家对局开始"><a href="#流程10-s2c-hallserver-通知玩家对局开始" class="headerlink" title="流程10 s2c hallserver 通知玩家对局开始"></a>流程10 s2c hallserver 通知玩家对局开始</h2><p>hallserver 在通知玩家进入游戏，此时客户端可以拿着游戏服的host和token去进入游戏了。</p><h2 id="重连处理"><a href="#重连处理" class="headerlink" title="重连处理"></a>重连处理</h2><p>当玩家重新登录时，hallserver大厅服，会去尝试拿玩家的游戏服房间信息，如果房间还存在会发给玩家进去重连，如果房间已经不存在，删除信息避免玩家不能再进去匹配。</p>]]></content>
    
    
    <categories>
      
      <category>skynet_fly 文档</category>
      
      <category>实战篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>skynet_fly_word</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>大厅服如何对模块功能进行拆分隔离？</title>
    <link href="/2023/05/03/skynet_fly_word/word_4/D_q/"/>
    <url>/2023/05/03/skynet_fly_word/word_4/D_q/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>通常一个游戏大厅会有很多功能模块，比如用户信息管理，活动大厅，任务，邮件，充值，商店，这些功能通过不会一个人开发，会很多人一起开发，如果都写在一个文件中，耦合度太高，合作编码太容易修改冲突。所以在编码逻辑上要做到尽量隔离。</p><h1 id="skynet-fly-demo是如何做的？"><a href="#skynet-fly-demo是如何做的？" class="headerlink" title="skynet_fly_demo是如何做的？"></a>skynet_fly_demo是如何做的？</h1><p>一个独立的功能模块无法是需要处理<strong>5种事件</strong></p><ol><li>客户端消息</li><li>服务器之间的消息</li><li>模块之间的接口调用</li><li>用户的登录，登出事情</li><li>自己注册的定时器任务</li></ol><p>关于第五条，非常简单，只是使用定时器即可</p><p>1，2，4 通过抽象出通用的hall_plug就可以做到。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><code class="hljs lua"><br><span class="hljs-keyword">local</span> <span class="hljs-built_in">log</span> = <span class="hljs-built_in">require</span> <span class="hljs-string">&quot;skynet-fly.log&quot;</span><br><span class="hljs-keyword">local</span> ws_pbnet_util = <span class="hljs-built_in">require</span> <span class="hljs-string">&quot;skynet-fly.utils.net.ws_pbnet_util&quot;</span><br><span class="hljs-keyword">local</span> pb_netpack = <span class="hljs-built_in">require</span> <span class="hljs-string">&quot;skynet-fly.netpack.pb_netpack&quot;</span><br><span class="hljs-keyword">local</span> timer = <span class="hljs-built_in">require</span> <span class="hljs-string">&quot;skynet-fly.timer&quot;</span><br><span class="hljs-keyword">local</span> errors_msg = <span class="hljs-built_in">require</span> <span class="hljs-string">&quot;gamecommon.msg.errors_msg&quot;</span><br><span class="hljs-keyword">local</span> skynet = <span class="hljs-built_in">require</span> <span class="hljs-string">&quot;skynet&quot;</span><br><span class="hljs-keyword">local</span> g_modules_list = <span class="hljs-built_in">require</span> <span class="hljs-string">&quot;hall.hall&quot;</span><br><br><span class="hljs-keyword">local</span> <span class="hljs-built_in">assert</span> = <span class="hljs-built_in">assert</span><br><span class="hljs-keyword">local</span> <span class="hljs-built_in">ipairs</span> = <span class="hljs-built_in">ipairs</span><br><span class="hljs-keyword">local</span> <span class="hljs-built_in">pairs</span> = <span class="hljs-built_in">pairs</span><br><br><span class="hljs-keyword">local</span> g_interface_mgr = <span class="hljs-literal">nil</span><br><br><span class="hljs-keyword">local</span> M = &#123;&#125;<br><br><span class="hljs-comment">--指定解包函数</span><br>M.<span class="hljs-built_in">unpack</span> = ws_pbnet_util.<span class="hljs-built_in">unpack</span><br>M.send = ws_pbnet_util.send<br>M.broadcast = ws_pbnet_util.broadcast<br>M.disconn_time_out = timer.minute                   <span class="hljs-comment">--掉线一分钟就清理</span><br><br><span class="hljs-comment">--初始化</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">M.init</span><span class="hljs-params">(interface_mgr)</span></span><br><span class="hljs-comment">--加载协议</span><br>pb_netpack.<span class="hljs-built_in">load</span>(<span class="hljs-string">&#x27;../../commonlualib/gamecommon/proto&#x27;</span>)<br>pb_netpack.<span class="hljs-built_in">load</span>(<span class="hljs-string">&#x27;./proto&#x27;</span>)<br>g_interface_mgr = interface_mgr<br>errors_msg = errors_msg:new(interface_mgr)<br><br><span class="hljs-comment">--注册handle</span><br><span class="hljs-keyword">for</span> _, m <span class="hljs-keyword">in</span> <span class="hljs-built_in">ipairs</span>(g_modules_list) <span class="hljs-keyword">do</span><br><span class="hljs-keyword">local</span> handle = m.handle<br><span class="hljs-keyword">for</span> packname,func <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(handle) <span class="hljs-keyword">do</span><br>g_interface_mgr:handle(packname, func)<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">--初始化</span><br><span class="hljs-keyword">for</span> _, m <span class="hljs-keyword">in</span> <span class="hljs-built_in">ipairs</span>(g_modules_list) <span class="hljs-keyword">do</span><br>m.init(interface_mgr)<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">on_login</span><span class="hljs-params">(player_id)</span></span><br><span class="hljs-keyword">for</span> _, m <span class="hljs-keyword">in</span> <span class="hljs-built_in">ipairs</span>(g_modules_list) <span class="hljs-keyword">do</span><br><span class="hljs-keyword">if</span> m.on_login <span class="hljs-keyword">then</span><br>m.on_login(player_id)<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">--连接成功</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">M.connect</span><span class="hljs-params">(player_id)</span></span><br>skynet.fork(on_login, player_id)<br><span class="hljs-keyword">return</span> &#123;<br>isreconnect = <span class="hljs-number">0</span>,<br>&#125;<br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">--掉线</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">M.disconnect</span><span class="hljs-params">(player_id)</span></span><br><span class="hljs-keyword">for</span> _, m <span class="hljs-keyword">in</span> <span class="hljs-built_in">ipairs</span>(g_modules_list) <span class="hljs-keyword">do</span><br><span class="hljs-keyword">if</span> m.on_disconnect <span class="hljs-keyword">then</span><br>m.on_disconnect(player_id)<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">on_reconnect</span><span class="hljs-params">(player_id)</span></span><br><span class="hljs-keyword">for</span> _, m <span class="hljs-keyword">in</span> <span class="hljs-built_in">ipairs</span>(g_modules_list) <span class="hljs-keyword">do</span><br><span class="hljs-keyword">if</span> m.on_reconnect <span class="hljs-keyword">then</span><br>m.on_reconnect(player_id)<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><span class="hljs-comment">--重连</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">M.reconnect</span><span class="hljs-params">(player_id)</span></span><br>skynet.fork(on_reconnect, player_id)<br><span class="hljs-keyword">return</span> &#123;<br>isreconnect = <span class="hljs-number">1</span>,<br>&#125;<br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">--登出</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">M.goout</span><span class="hljs-params">(player_id)</span></span><br><span class="hljs-keyword">for</span> _, m <span class="hljs-keyword">in</span> <span class="hljs-built_in">ipairs</span>(g_modules_list) <span class="hljs-keyword">do</span><br><span class="hljs-keyword">if</span> m.on_loginout <span class="hljs-keyword">then</span><br>m.on_loginout(player_id)<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br>M.register_cmd = &#123;&#125;<br><br><span class="hljs-comment">--设置CMD命令</span><br><span class="hljs-keyword">for</span> _, m <span class="hljs-keyword">in</span> <span class="hljs-built_in">ipairs</span>(g_modules_list) <span class="hljs-keyword">do</span><br><span class="hljs-keyword">local</span> register_cmd = m.register_cmd<br><span class="hljs-keyword">for</span> cmdname,func <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(register_cmd) <span class="hljs-keyword">do</span><br><span class="hljs-built_in">assert</span>(<span class="hljs-keyword">not</span> M.register_cmd[cmdname], <span class="hljs-string">&quot;exists cmdname: &quot;</span> .. cmdname)<br>M.register_cmd[cmdname] = func<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">-- 客户端消息处理结束</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">M.handle_end</span><span class="hljs-params">(player_id, packname, pack_body, ret, errcode, errmsg)</span></span><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> ret <span class="hljs-keyword">then</span><br><span class="hljs-built_in">log</span>.info(<span class="hljs-string">&quot;handle_end err &gt;&gt;&gt; &quot;</span>, packname, ret, errcode, errmsg)<br>errors_msg:errors(player_id, errcode, errmsg, packname)<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">-- 离开房间回调</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">M.leave_table</span><span class="hljs-params">(player_id, table_name, table_id)</span></span><br><span class="hljs-comment">--离开房间说明对局结束了，就直接踢掉吧</span><br>skynet.fork(g_interface_mgr.goout, g_interface_mgr, player_id)<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">return</span> M<br></code></pre></td></tr></table></figure><p>最关键的一行代码就是 <code>local g_modules_list = require &quot;hall.hall&quot;</code><br>引入hall_plug的服务只需要在hall文件夹下创建hall.lua，文件hall.lua再去require对应的模块入口即可。</p><p>hall.lua</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-built_in">require</span> <span class="hljs-string">&quot;hall.player.player&quot;</span>,<br><span class="hljs-built_in">require</span> <span class="hljs-string">&quot;hall.match.match&quot;</span>,<br><span class="hljs-built_in">require</span> <span class="hljs-string">&quot;hall.item.item&quot;</span>,<br><span class="hljs-built_in">require</span> <span class="hljs-string">&quot;hall.game_record.game_record&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs lua"><br><span class="hljs-keyword">local</span> match_logic = <span class="hljs-built_in">require</span> <span class="hljs-string">&quot;hall.match.match_logic&quot;</span><br><br><br><span class="hljs-keyword">local</span> M = &#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">M.init</span><span class="hljs-params">(interface_mgr)</span></span><br>    match_logic.init(interface_mgr)<br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">M.on_login</span><span class="hljs-params">(player_id)</span></span><br>    match_logic.on_login(player_id)<br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">M.on_reconnect</span><span class="hljs-params">(player_id)</span></span><br>    match_logic.on_reconnect(player_id)<br><span class="hljs-keyword">end</span><br><br>M.handle = &#123;<br>    <span class="hljs-comment">--匹配</span><br>    [<span class="hljs-string">&#x27;.hallserver_match.MatchGameReq&#x27;</span>] = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(player_id, packname, pack_body)</span></span><br>       <span class="hljs-keyword">return</span> match_logic.do_match_game(player_id, pack_body)<br>    <span class="hljs-keyword">end</span>,<br>    <span class="hljs-comment">--取消匹配</span><br>    [<span class="hljs-string">&#x27;.hallserver_match.CancelMatchGameReq&#x27;</span>] = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(player_id, packname, pack_body)</span></span><br>        <span class="hljs-keyword">return</span> match_logic.do_cancel_match_game(player_id, pack_body)<br>    <span class="hljs-keyword">end</span>,<br>    <span class="hljs-comment">--接受对局</span><br>    [<span class="hljs-string">&#x27;.hallserver_match.AcceptMatchReq&#x27;</span>] = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(player_id, packname, pack_body)</span></span><br>        <span class="hljs-keyword">return</span> match_logic.do_accept_match(player_id, pack_body)<br>    <span class="hljs-keyword">end</span>,<br>&#125;<br><br><span class="hljs-keyword">local</span> CMD = &#123;&#125;<br><br><span class="hljs-comment">--匹配成功</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CMD.match_succ</span><span class="hljs-params">(...)</span></span><br>   <span class="hljs-keyword">return</span> match_logic.cmd_match_succ(...)<br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">--加入对局</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CMD.match_join_game</span><span class="hljs-params">(...)</span></span><br>    <span class="hljs-keyword">return</span> match_logic.cmd_join_game(...)<br><span class="hljs-keyword">end</span><br><br>M.register_cmd = CMD<br><br><span class="hljs-keyword">return</span> M<br></code></pre></td></tr></table></figure><p>服务启动之后，会根据require的顺序调用init函数。</p><h2 id="客户端消息处理"><a href="#客户端消息处理" class="headerlink" title="客户端消息处理"></a>客户端消息处理</h2><p>通过在M.handle中实现对应消息名处理函数。</p><h2 id="服务器之间的消息"><a href="#服务器之间的消息" class="headerlink" title="服务器之间的消息"></a>服务器之间的消息</h2><p>通过<code>register_cmd</code>注册服务之间的消息处理函数。</p><h2 id="用户的登录，登出事情"><a href="#用户的登录，登出事情" class="headerlink" title="用户的登录，登出事情"></a>用户的登录，登出事情</h2><p>通过实现 <code>on_login</code>接口来实现，调用顺序按照require顺序执行。</p><h2 id="模块之间的接口调用"><a href="#模块之间的接口调用" class="headerlink" title="模块之间的接口调用"></a>模块之间的接口调用</h2><p>通过各模块提供interface.lua文件来实现接口调用</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> <span class="hljs-built_in">error</span> = <span class="hljs-built_in">error</span><br><span class="hljs-keyword">local</span> M = &#123;&#125;<br><br><span class="hljs-comment">--这是player对外的接口 这里写定义，player_logic写实现</span><br><br><span class="hljs-comment">--获取玩家列表</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">M.get_online_list</span><span class="hljs-params">()</span></span><br>    <span class="hljs-built_in">error</span>(<span class="hljs-string">&quot;调用了未实现的接口 get_online_list&quot;</span>)<br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">--获取玩家信息</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">M.get_info</span><span class="hljs-params">(player_id)</span></span><br>    <span class="hljs-built_in">error</span>(<span class="hljs-string">&quot;调用了未实现的接口 get_info&quot;</span>)<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">return</span> M<br></code></pre></td></tr></table></figure><p>比如这是player模块定义的接口，player逻辑模块需要重写这些接口，否则其他模块调用就会报错。</p>]]></content>
    
    
    <categories>
      
      <category>skynet_fly 文档</category>
      
      <category>实战篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>skynet_fly_word</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何在skynet_fly_demo新增一个游戏？</title>
    <link href="/2023/05/03/skynet_fly_word/word_4/F_q/"/>
    <url>/2023/05/03/skynet_fly_word/word_4/F_q/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>通常基于游戏大厅的对战类型游戏不会只有一款玩法，像英雄联盟会有匹配场，排位场，大乱斗，还有一些限时玩法，克隆，无限火力。这些特殊玩法，通常分开开服比较好，相互隔离不影响。<br>skynet_fly_demo利用了skynet_fly房间类游戏架构可以非常快速的搭建房间对战类游戏，非常适合这种架构模式。那么如何在skynet_fly_demo新增一个游戏？我将已新增一个数字炸弹游戏为例子，进行逐步讲解。</p><h1 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h1><p>在上一节(<strong>用户是如何匹配进入到游戏的？</strong>)中,我们了解到了<strong>用户-&gt;匹配-&gt;匹配成功-&gt;进入游戏</strong>的过程。新增一款游戏，其实就是把新款游戏加入到这个过程中，不过前提是先有游戏。</p><h1 id="新增游戏"><a href="#新增游戏" class="headerlink" title="新增游戏"></a>新增游戏</h1><h2 id="stop-1-创建游戏服务项目"><a href="#stop-1-创建游戏服务项目" class="headerlink" title="stop 1 创建游戏服务项目"></a>stop 1 创建游戏服务项目</h2><p>在games文件夹下创建名为<strong>digitalbomb</strong>数字炸弹的游戏，这个文件夹的名字就是<strong>cluster_name</strong>,集群中的服务名。</p><h2 id="stop-2-新增入口文件-main-lua"><a href="#stop-2-新增入口文件-main-lua" class="headerlink" title="stop 2 新增入口文件 main.lua"></a>stop 2 新增入口文件 main.lua</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> skynet = <span class="hljs-built_in">require</span> <span class="hljs-string">&quot;skynet&quot;</span><br><span class="hljs-keyword">local</span> contriner_launcher = <span class="hljs-built_in">require</span> <span class="hljs-string">&quot;skynet-fly.contriner.contriner_launcher&quot;</span><br><br>skynet.start(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span><br>skynet.<span class="hljs-built_in">error</span>(<span class="hljs-string">&quot;start digitalbomb&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;</span>)<br>contriner_launcher.run()<br><span class="hljs-comment">--启动集群连接入口</span><br>skynet.uniqueservice(<span class="hljs-string">&quot;cluster_server&quot;</span>)<br><span class="hljs-comment">--启动room_game_login 登录服务</span><br>skynet.uniqueservice(<span class="hljs-string">&quot;room_game_login&quot;</span>)<br><br>skynet.call(<span class="hljs-string">&#x27;.logger&#x27;</span>,<span class="hljs-string">&#x27;lua&#x27;</span>,<span class="hljs-string">&#x27;add_hook&#x27;</span>,<span class="hljs-string">&#x27;common.log_hook&#x27;</span>)<br><br>skynet.<span class="hljs-built_in">exit</span>()<br><span class="hljs-keyword">end</span>)<br></code></pre></td></tr></table></figure><p>启动入口文件跟象棋是一样的。</p><h2 id="stop-3-编辑load-mods-lua-文件"><a href="#stop-3-编辑load-mods-lua-文件" class="headerlink" title="stop 3 编辑load_mods.lua 文件"></a>stop 3 编辑load_mods.lua 文件</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> redis_cfg = <span class="hljs-built_in">loadfile</span>(<span class="hljs-string">&quot;../../commonlualib/common/etc/redis_cfg.lua&quot;</span>)()<br><span class="hljs-keyword">local</span> server_cfg = <span class="hljs-built_in">loadfile</span>(<span class="hljs-string">&quot;../../commonlualib/common/etc/server_cfg.lua&quot;</span>)()<br><span class="hljs-keyword">local</span> gate_cfg = <span class="hljs-built_in">loadfile</span>(<span class="hljs-string">&quot;../../commonlualib/common/etc/gate_cfg.lua&quot;</span>)()<br><span class="hljs-keyword">local</span> cluster_server_cfg = <span class="hljs-built_in">loadfile</span>(<span class="hljs-string">&quot;../../commonlualib/common/etc/cluster_server_cfg.lua&quot;</span>)()<br><span class="hljs-keyword">local</span> mysql_cfg = <span class="hljs-built_in">loadfile</span>(<span class="hljs-string">&quot;../../commonlualib/common/etc/mysql_cfg.lua&quot;</span>)()<br><br><span class="hljs-keyword">return</span> &#123;<br><span class="hljs-comment">--共享配置</span><br>share_config_m = &#123;<br>launch_seq = <span class="hljs-number">1000</span>,     <span class="hljs-comment">--启动顺序，从小到大</span><br>launch_num = <span class="hljs-number">1</span>,     <span class="hljs-comment">--启动数量</span><br>default_arg = &#123;     <span class="hljs-comment">--默认配置</span><br><span class="hljs-comment">--room_game_login用的配置</span><br>room_game_login = &#123;<br>gateservice = <span class="hljs-string">&quot;ws_gate&quot;</span>, <span class="hljs-comment">--gate 或者 ws_gate</span><br><span class="hljs-comment">--gate连接配置</span><br>gateconf = gate_cfg.games.digitalbomb_1,<br>login_plug = <span class="hljs-string">&quot;common.plug.login_plug&quot;</span>,  <span class="hljs-comment">--login加载的插件lua模块文件名</span><br>&#125;,<br><span class="hljs-comment">--cluster_server用的配置</span><br>cluster_server = cluster_server_cfg.games.digitalbomb_1,<br><br>server_cfg = server_cfg.games.digitalbomb_1,<br>&#125;<br>&#125;,<br><br><span class="hljs-comment">--日志切割</span><br>logrotate_m = &#123;<br>        launch_seq = <span class="hljs-number">5000</span>,<br>        launch_num = <span class="hljs-number">1</span>,<br>        default_arg = &#123;<br>            file_path = <span class="hljs-string">&#x27;./logs_1/&#x27;</span>,          <span class="hljs-comment">--文件路径</span><br>            filename = <span class="hljs-string">&#x27;server.log&#x27;</span>,   <span class="hljs-comment">--文件名</span><br>            limit_size = <span class="hljs-number">0</span>,            <span class="hljs-comment">--最小分割大小</span><br>            max_age = <span class="hljs-number">7</span>,               <span class="hljs-comment">--最大保留天数</span><br>            max_backups = <span class="hljs-number">7</span>,           <span class="hljs-comment">--最大保留文件数</span><br>            sys_cmd = <span class="hljs-string">[[</span><br><span class="hljs-string">                /usr/bin/pkill -HUP -f skynet.digitalbomb_config.lua.load_mods_1.lua\n</span><br><span class="hljs-string">            ]]</span>,              <span class="hljs-comment">--系统命令</span><br>        &#125;<br>    &#125;,<br>&#125;<br></code></pre></td></tr></table></figure><p>为了方便讲解查看，我把跟象棋相同的配置项都删除了，留下了需要改动的配置项。<br><strong>gateconf</strong> ws_gate连接入口的配置<br><strong>cluster_server</strong> 集群入口配置<br><strong>server_cfg</strong> 服务的环境参数配置<br><strong>sys_cmd</strong> 日志轮换的系统命令</p><p>load_mods.lua 只需要调整这几个配置即可，多开数字炸弹也是调整这几个配置。</p><h2 id="stop-3-login-plug-lua-配置登录插件"><a href="#stop-3-login-plug-lua-配置登录插件" class="headerlink" title="stop 3 login_plug.lua 配置登录插件"></a>stop 3 login_plug.lua 配置登录插件</h2><p>login_plug插件可以跟象棋公用 <code>login_plug = &quot;common.plug.login_plug&quot;,  --login加载的插件lua模块文件名</code>,登录协议也可以共用。</p><h2 id="stop-4-hall-plug-lua-配置大厅插件"><a href="#stop-4-hall-plug-lua-配置大厅插件" class="headerlink" title="stop 4 hall_plug.lua 配置大厅插件"></a>stop 4 hall_plug.lua 配置大厅插件</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">--大厅服</span><br>room_game_hall_m = &#123;<br>launch_seq = <span class="hljs-number">2000</span>, <span class="hljs-comment">--第二个启动</span><br>launch_num = <span class="hljs-number">6</span>, <span class="hljs-comment">--启动6个</span><br>default_arg = &#123;<br>hall_plug = <span class="hljs-string">&quot;common.plug.hall_plug&quot;</span>,         <span class="hljs-comment">--大厅加载的插件lua模块文件名</span><br>&#125;<br>&#125;,<br></code></pre></td></tr></table></figure><p>大厅的功能就是接收心跳包、处理玩家进入房间的消息，也可以通用。</p><p>在项目服务下创建hall&#x2F;hall&#x2F;lua文件，加载对应公共模块即可。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">return</span> &#123;<br><span class="hljs-built_in">require</span> <span class="hljs-string">&quot;gamecommon.hall.player.player&quot;</span>,<br><span class="hljs-built_in">require</span> <span class="hljs-string">&quot;gamecommon.hall.match.match&quot;</span>,<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="stop5-table-plug-lua-房间配置插件"><a href="#stop5-table-plug-lua-房间配置插件" class="headerlink" title="stop5 table_plug.lua 房间配置插件"></a>stop5 table_plug.lua 房间配置插件</h2><p>这里插件里编辑游戏的交互逻辑，通常不能通用，在这里实现核心逻辑。游戏实现我就不赘述了。</p><p>步骤：<br>创建 table&#x2F;table_plug.lua 实现逻辑</p><p>在load_mods.lua 中新增房间服配置</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">--房间服</span><br>room_game_table_m = &#123;<br>    launch_seq = <span class="hljs-number">4000</span>, <span class="hljs-comment">--第四个启动</span><br>    launch_num = <span class="hljs-number">6</span>, <span class="hljs-comment">--启动6个</span><br>    default_arg = &#123;<br>        table_plug = <span class="hljs-string">&quot;table.table_plug&quot;</span>,   <span class="hljs-comment">--房间插件</span><br>        instance_name = <span class="hljs-string">&quot;default&quot;</span>,<br>        table_conf = &#123;<br>            player_num = <span class="hljs-number">2</span>,        <span class="hljs-comment">--2个人玩</span><br>        &#125;<br>    &#125;<br>&#125;,<br></code></pre></td></tr></table></figure><p>到此游戏可以说是加好了。</p><h1 id="接入匹配流程"><a href="#接入匹配流程" class="headerlink" title="接入匹配流程"></a>接入匹配流程</h1><h2 id="stop1-用户-gt-匹配"><a href="#stop1-用户-gt-匹配" class="headerlink" title="stop1 用户-&gt;匹配"></a>stop1 用户-&gt;匹配</h2><p>用户进哪个游戏是用户决定了，所以客户端需要告诉服务端，需要去匹配哪个游戏。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">--请求匹配</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">M.do_match_game</span><span class="hljs-params">(player_id, pack_body)</span></span><br>    <span class="hljs-comment">--log.info(&quot;do_match_game &gt;&gt;&gt; &quot;,player_id, pack_body)</span><br>    <span class="hljs-keyword">local</span> game_id = pack_body.game_id<br>    <span class="hljs-keyword">local</span> game_server = GAME_ID_ENUM[game_id]<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> game_server <span class="hljs-keyword">then</span><br>        <span class="hljs-built_in">log</span>.<span class="hljs-built_in">error</span>(<span class="hljs-string">&quot;do_match_game not exists gameid &quot;</span>, game_id)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, errorcode.GAME_NOT_EXISTS, <span class="hljs-string">&quot;GAME_NOT_EXISTS&quot;</span><br>    <span class="hljs-keyword">end</span><br><br>    <span class="hljs-keyword">local</span> game_room_info = game_redis.get_game_room_info(player_id)<br>    <span class="hljs-keyword">if</span> game_room_info <span class="hljs-keyword">and</span> <span class="hljs-built_in">next</span>(game_room_info) <span class="hljs-keyword">then</span><br>        <span class="hljs-built_in">log</span>.<span class="hljs-built_in">error</span>(<span class="hljs-string">&quot;exists game_room_info &quot;</span>,player_id, game_room_info)<br>        <span class="hljs-keyword">return</span> <br>    <span class="hljs-keyword">end</span><br><br>    <span class="hljs-comment">--log.info(&quot;do_match_game2 &gt;&gt;&gt; &quot;,player_id, pack_body)</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> rpc_matchserver_match.<span class="hljs-built_in">match</span>(game_server, player_id) <span class="hljs-keyword">then</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-comment">--log.info(&quot;do_match_game3 &gt;&gt;&gt; &quot;,player_id, pack_body)</span><br>    <span class="hljs-comment">--回复匹配</span><br>    match_msg:match_game_res(player_id, &#123;game_id = game_id&#125;)<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>客户端传递的game_id,我们需要通过game_id找到对应游戏服务的<strong>cluster_name</strong>也就是游戏服务的文件夹名字，我们在GAME_ID_ENUM这里枚举文件中添加映射关系。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> enum = &#123;<br>    [<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;chinese_chess&#x27;</span>,<br>    chinese_chess = <span class="hljs-number">1</span>,<br>    [<span class="hljs-number">2</span>] = <span class="hljs-string">&#x27;digitalbomb&#x27;</span>,<br>    digitalbomb = <span class="hljs-number">2</span>,<br>&#125;<br><br><span class="hljs-keyword">return</span> enum<br></code></pre></td></tr></table></figure><p>添加完映射关系后就能通过 <code>rpc_matchserver_match.match(game_server, player_id)</code>告诉匹配服，我需要匹配数字炸弹游戏。</p><h2 id="stop2-匹配-gt-匹配成功"><a href="#stop2-匹配-gt-匹配成功" class="headerlink" title="stop2 匹配-&gt;匹配成功"></a>stop2 匹配-&gt;匹配成功</h2><p>之前匹配只知道有象棋游戏，不知道有数字炸弹游戏，这时候去匹配肯定不成功。此时我们需要改动<strong>matchserver</strong>。<br>我们在load_mods.lua 中修改match_m和cluster_client_m的配置</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs lua"><br><span class="hljs-comment">--集群客户端</span><br>cluster_client_m = &#123;<br>    launch_seq = <span class="hljs-number">4</span>,<br>    launch_num = <span class="hljs-number">1</span>,<br>    default_arg = &#123;<br>        node_map = &#123;<br>            [<span class="hljs-string">&#x27;logserver&#x27;</span>]  = <span class="hljs-literal">true</span>,       <span class="hljs-comment">--日志服</span><br>            [<span class="hljs-string">&#x27;hallserver&#x27;</span>] = <span class="hljs-literal">true</span>,       <span class="hljs-comment">--大厅服</span><br>            [<span class="hljs-string">&#x27;chinese_chess&#x27;</span>] = <span class="hljs-literal">true</span>,    <span class="hljs-comment">--中国象棋</span><br>            [<span class="hljs-string">&#x27;centerserver&#x27;</span>] = <span class="hljs-literal">true</span>,     <span class="hljs-comment">--中心服</span><br>            [<span class="hljs-string">&#x27;digitalbomb&#x27;</span>] = <span class="hljs-literal">true</span>,      <span class="hljs-comment">--数字炸弹</span><br>        &#125;,<br>        watch = <span class="hljs-string">&#x27;redis&#x27;</span>,  <span class="hljs-comment">--监听redis的方式做服务发现</span><br>    &#125;<br>&#125;,<br><span class="hljs-comment">--匹配逻辑</span><br>match_m = &#123;<br>    launch_seq = <span class="hljs-number">5</span>,<br>    launch_num = <span class="hljs-number">2</span>,<br>    mod_args = &#123;<br>        &#123;instance_name = <span class="hljs-string">&quot;chinese_chess&quot;</span>&#125;,<br>        &#123;instance_name = <span class="hljs-string">&quot;digitalbomb&quot;</span>&#125;,<br>    &#125;<br>&#125;,<br></code></pre></td></tr></table></figure><p>因为match_m需要rpc请求<strong>digitalbomb</strong>数字炸弹游戏服，所以需要在cluster_client_m-&gt;node_map中把digitalbomb添加进去。<br>把launch_num从1改为2，在 mod_args 中新增 digitalbomb 的配置项，这样match_m就会启动2个，一个match_m处理象棋的匹配，一个处理数字炸弹的匹配。</p><p>到这里，数字炸弹游戏已经接入到匹配了。</p><h2 id="stop3-匹配成功-gt-进入游戏"><a href="#stop3-匹配成功-gt-进入游戏" class="headerlink" title="stop3 匹配成功-&gt;进入游戏"></a>stop3 匹配成功-&gt;进入游戏</h2><p>这个流程是通用的。</p><h2 id="stop4-重连处理"><a href="#stop4-重连处理" class="headerlink" title="stop4 重连处理"></a>stop4 重连处理</h2><p>因为在开发环境中，我们并不会妥善的关服，一般就是强行重启，可能有些玩家正在游戏中，这时会玩家会残留游戏房间信息在redis，因为hallserver处理了重连游戏，玩家登录后，会查询游戏房间信息，存在即发给客户端进去重连。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">check_join_room_game</span><span class="hljs-params">(player_id)</span></span><br>    <span class="hljs-keyword">local</span> game_room_info = game_redis.get_game_room_info(player_id)<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> game_room_info <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">next</span>(game_room_info) <span class="hljs-keyword">then</span><br>        <span class="hljs-keyword">return</span><br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">local</span> cli = cluster_client:instance(game_room_info.svr_name, <span class="hljs-string">&quot;room_game_alloc_m&quot;</span>)<br>    cli:set_svr_id(game_room_info.svr_id)<br>    <span class="hljs-keyword">local</span> ret = cli:one_mod_call(<span class="hljs-string">&quot;exists&quot;</span>, game_room_info.table_id)<br>    <span class="hljs-keyword">if</span> #ret.result &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> ret.result[<span class="hljs-number">1</span>] <span class="hljs-keyword">then</span> <br>        M.cmd_join_game(player_id, game_room_info.token, game_room_info.host, game_room_info.table_id)<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-comment">--说明房间已经不存在了</span><br>        <span class="hljs-comment">--删除房间信息</span><br>        game_redis.del_game_room_info(player_id)<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>那如果出现了强行重启的情况，实际上redis记录的游戏房间信息是脏数据了，就需要清除，怎么确认是脏数据，就需要去对应的游戏服查询该房间存不存在，不存在即删除。<br>所以大厅服也会访问对应的游戏服，大厅服也需要在<code>cluster_client_m</code>-&gt;node_map中把digitalbomb加上。</p>]]></content>
    
    
    <categories>
      
      <category>skynet_fly 文档</category>
      
      <category>实战篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>skynet_fly_word</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前言</title>
    <link href="/2023/02/25/skynet_fly_word/word_3/A_home/"/>
    <url>/2023/02/25/skynet_fly_word/word_3/A_home/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这一篇，主要介绍<code>skyent_fly</code>提供的增强功能。</p><p><img src="/img/skynet_fly_word/word_3/dog.png"></p><p>我想应该有很多读者一股脑把文档看了个遍，之后发现学费了。<br>正常的。技术能力提升并不能一蹴而就，需要经过大量的实践思考学习，慢慢累计起来方能有所成。</p><p><img src="/img/skynet_fly_word/word_3/f.png"><br>加油！</p>]]></content>
    
    
    <categories>
      
      <category>skynet_fly 文档</category>
      
      <category>强化篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>skynet_fly_word</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>可热更匹配房间类游戏架构基础设施</title>
    <link href="/2023/02/25/skynet_fly_word/word_3/B_game/"/>
    <url>/2023/02/25/skynet_fly_word/word_3/B_game/</url>
    
    <content type="html"><![CDATA[<p><a href="https://huahua132.github.io/2023/07/22/skynet_fly_ss/room_game/">可热更匹配房间类游戏架构基础设施</a><br><a href="https://huahua132.github.io/2023/10/15/skynet_fly_ss/room_game_up/">后续优化</a></p>]]></content>
    
    
    <categories>
      
      <category>skynet_fly 文档</category>
      
      <category>强化篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>skynet_fly_word</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>gate,wsgate通用协议的设计</title>
    <link href="/2023/02/25/skynet_fly_word/word_3/C_proto/"/>
    <url>/2023/02/25/skynet_fly_word/word_3/C_proto/</url>
    
    <content type="html"><![CDATA[<p><a href="https://huahua132.github.io/2023/12/10/skynet_fly_ss/pack/">gate,wsgate通用协议的设计</a></p>]]></content>
    
    
    <categories>
      
      <category>skynet_fly 文档</category>
      
      <category>强化篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>skynet_fly_word</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>定时器的封装</title>
    <link href="/2023/02/25/skynet_fly_word/word_3/D_timer/"/>
    <url>/2023/02/25/skynet_fly_word/word_3/D_timer/</url>
    
    <content type="html"><![CDATA[<p><a href="https://huahua132.github.io/2023/07/02/skynet_fly_ss/timer/">定时器的封装</a><br><a href="https://huahua132.github.io/2024/01/21/skynet_fly_api/timer/">使用API</a></p>]]></content>
    
    
    <categories>
      
      <category>skynet_fly 文档</category>
      
      <category>强化篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>skynet_fly_word</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>整点报时</title>
    <link href="/2023/02/25/skynet_fly_word/word_3/G_point/"/>
    <url>/2023/02/25/skynet_fly_word/word_3/G_point/</url>
    
    <content type="html"><![CDATA[<p><a href="https://huahua132.github.io/2023/10/22/skynet_fly_ss/time_point/">整点报时</a></p>]]></content>
    
    
    <categories>
      
      <category>skynet_fly 文档</category>
      
      <category>强化篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>skynet_fly_word</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redis的封装</title>
    <link href="/2023/02/25/skynet_fly_word/word_3/F_redis/"/>
    <url>/2023/02/25/skynet_fly_word/word_3/F_redis/</url>
    
    <content type="html"><![CDATA[<p><a href="https://huahua132.github.io/2023/07/08/skynet_fly_ss/redis/">redis的封装</a></p>]]></content>
    
    
    <categories>
      
      <category>skynet_fly 文档</category>
      
      <category>强化篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>skynet_fly_word</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>可热更模块的启动配置项</title>
    <link href="/2023/02/25/skynet_fly_word/word_3/E_module/"/>
    <url>/2023/02/25/skynet_fly_word/word_3/E_module/</url>
    
    <content type="html"><![CDATA[<p><a href="https://huahua132.github.io/2024/01/14/skynet_fly_api/mods/">可热更模块的启动配置项</a></p>]]></content>
    
    
    <categories>
      
      <category>skynet_fly 文档</category>
      
      <category>强化篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>skynet_fly_word</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>orm数据库关系映射</title>
    <link href="/2023/02/25/skynet_fly_word/word_3/H_orm/"/>
    <url>/2023/02/25/skynet_fly_word/word_3/H_orm/</url>
    
    <content type="html"><![CDATA[<p><a href="https://huahua132.github.io/2023/12/24/skynet_fly_ss/orm/">orm数据库关系映射</a><br><a href="https://huahua132.github.io/2024/01/28/skynet_fly_api/orm/">api</a></p>]]></content>
    
    
    <categories>
      
      <category>skynet_fly 文档</category>
      
      <category>强化篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>skynet_fly_word</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>日志分割</title>
    <link href="/2023/02/25/skynet_fly_word/word_3/J_logrotate/"/>
    <url>/2023/02/25/skynet_fly_word/word_3/J_logrotate/</url>
    
    <content type="html"><![CDATA[<p><a href="https://huahua132.github.io/2023/09/10/skynet_fly_ss/logrotate/">日志分割</a></p>]]></content>
    
    
    <categories>
      
      <category>skynet_fly 文档</category>
      
      <category>强化篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>skynet_fly_word</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>监听同步模块</title>
    <link href="/2023/02/25/skynet_fly_word/word_3/I_watch/"/>
    <url>/2023/02/25/skynet_fly_word/word_3/I_watch/</url>
    
    <content type="html"><![CDATA[<p><a href="https://huahua132.github.io/2024/01/28/skynet_fly_ss/watch_syn/">监听同步模块</a><br><a href="https://huahua132.github.io/2024/01/28/skynet_fly_api/watch_syn/">api</a></p>]]></content>
    
    
    <categories>
      
      <category>skynet_fly 文档</category>
      
      <category>强化篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>skynet_fly_word</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>日志服务</title>
    <link href="/2023/02/25/skynet_fly_word/word_3/K_log/"/>
    <url>/2023/02/25/skynet_fly_word/word_3/K_log/</url>
    
    <content type="html"><![CDATA[<p><a href="https://huahua132.github.io/2023/11/19/skynet_fly_ss/logservice/">日志服务</a></p>]]></content>
    
    
    <categories>
      
      <category>skynet_fly 文档</category>
      
      <category>强化篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>skynet_fly_word</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>rpc调用</title>
    <link href="/2023/02/25/skynet_fly_word/word_2/B_RPC/"/>
    <url>/2023/02/25/skynet_fly_word/word_2/B_RPC/</url>
    
    <content type="html"><![CDATA[<h1 id="常规的RPC调用"><a href="#常规的RPC调用" class="headerlink" title="常规的RPC调用"></a>常规的RPC调用</h1><p>使用skynet.call,skyent.send。</p><h1 id="rpc调用可热更服务模块"><a href="#rpc调用可热更服务模块" class="headerlink" title="rpc调用可热更服务模块"></a>rpc调用可热更服务模块</h1><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> ret = contriner_client:instance(<span class="hljs-string">&quot;B_m&quot;</span>):mod_call(<span class="hljs-string">&quot;hello&quot;</span>)<br><span class="hljs-built_in">log</span>.info(<span class="hljs-string">&quot;send_msg_to_b:&quot;</span>,ret)<br></code></pre></td></tr></table></figure><p>这里的意思是给<strong>B_m</strong> 可热更模块发送<strong>hello</strong>消息命令。</p><p>详细可以查看<a href="https://github.com/huahua132/skynet_fly/tree/master/examples">AB_question示例</a></p><h1 id="详细API介绍"><a href="#详细API介绍" class="headerlink" title="详细API介绍"></a><a href="https://huahua132.github.io/2024/01/07/skynet_fly_api/rpc/">详细API介绍</a></h1>]]></content>
    
    
    <categories>
      
      <category>skynet_fly 文档</category>
      
      <category>基础篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>skynet_fly_word</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前言</title>
    <link href="/2023/02/25/skynet_fly_word/word_2/A_home/"/>
    <url>/2023/02/25/skynet_fly_word/word_2/A_home/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>通过入门篇，我们学会了框架的基本使用规则。但是我们还不知道如何RPC调用，如何远程RPC调用，热更原理机制是什么。<br>学会这些，可以说是使用该框架的高手的。</p>]]></content>
    
    
    <categories>
      
      <category>skynet_fly 文档</category>
      
      <category>基础篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>skynet_fly_word</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>集群远程rpc调用</title>
    <link href="/2023/02/25/skynet_fly_word/word_2/C_RPC/"/>
    <url>/2023/02/25/skynet_fly_word/word_2/C_RPC/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>集群远程RPC调用，是基于skynet的<a href="https://github.com/cloudwu/skynet/wiki/Cluster">集群 cluster mode模式</a>封装了一套简单好用、适用用框架的模式。</p><h1 id="配置启动服务端"><a href="#配置启动服务端" class="headerlink" title="配置启动服务端"></a>配置启动服务端</h1><ol><li>配置load_mods.lua</li></ol><p><code>load_mods.lua</code></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">--共享配置</span><br>share_config_m = &#123;<br>launch_seq = <span class="hljs-number">1</span>,<br>launch_num = <span class="hljs-number">1</span>,<br>default_arg = &#123;<br><span class="hljs-comment">--cluster_server用的配置</span><br>cluster_server = &#123;<br>host = <span class="hljs-string">&quot;127.0.0.1:9688&quot;</span>,<br>&#125;,<br>&#125;,<br>&#125;,<br></code></pre></td></tr></table></figure><ol start="2"><li>启动集群服务端<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua">skynet.uniqueservice(<span class="hljs-string">&quot;cluster_server&quot;</span>)<br></code></pre></td></tr></table></figure></li></ol><h1 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a><a href="https://huahua132.github.io/2023/07/28/skynet_fly_ss/cluster_rpc/">实现细节</a></h1><h1 id="远程RPC调用"><a href="#远程RPC调用" class="headerlink" title="远程RPC调用"></a>远程RPC调用</h1><p>以 <a href="https://github.com/huahua132/skynet_fly/tree/master/examples/cluster_server">cluster_server</a>为例<br>服务有一个<strong>可热更服务模块</strong> <code>test_m.lua</code></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> <span class="hljs-built_in">log</span> = <span class="hljs-built_in">require</span> <span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-keyword">local</span> skynet = <span class="hljs-built_in">require</span> <span class="hljs-string">&quot;skynet&quot;</span><br><span class="hljs-keyword">local</span> contriner_client = <span class="hljs-built_in">require</span> <span class="hljs-string">&quot;contriner_client&quot;</span><br><br>contriner_client:register(<span class="hljs-string">&quot;share_config_m&quot;</span>)<br><span class="hljs-keyword">local</span> <span class="hljs-built_in">string</span> = <span class="hljs-built_in">string</span><br><br><span class="hljs-keyword">local</span> g_config = <span class="hljs-literal">nil</span><br><br><span class="hljs-keyword">local</span> CMD = &#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CMD.hello</span><span class="hljs-params">(who)</span></span><br><span class="hljs-built_in">log</span>.info(<span class="hljs-built_in">string</span>.<span class="hljs-built_in">format</span>(<span class="hljs-string">&quot;%s send hello msg for me&quot;</span>,who))<br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CMD.ping</span><span class="hljs-params">()</span></span><br><span class="hljs-keyword">local</span> confclient = contriner_client:new(<span class="hljs-string">&quot;share_config_m&quot;</span>)<br><span class="hljs-keyword">local</span> conf = confclient:mod_call(<span class="hljs-string">&#x27;query&#x27;</span>,<span class="hljs-string">&#x27;cluster_server&#x27;</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">string</span>.<span class="hljs-built_in">format</span>(<span class="hljs-string">&quot;pong %s %s %s&quot;</span>,g_config.instance_name,conf.host,skynet.<span class="hljs-built_in">self</span>())<br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CMD.start</span><span class="hljs-params">(config)</span></span><br>g_config = <span class="hljs-built_in">config</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CMD.exit</span><span class="hljs-params">()</span></span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">return</span> CMD<br></code></pre></td></tr></table></figure><p>那边其他服务改如何调用到这个服务的<code>hello</code>命令呢</p><p><a href="https://github.com/huahua132/skynet_fly/tree/master/examples/cluster_client">cluster_client</a>首先需要配置连接服务端的地址。</p><p><code>load_mods.lua</code></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">return</span> &#123;<br>share_config_m = &#123;<br>launch_seq = <span class="hljs-number">1</span>,<br>launch_num = <span class="hljs-number">1</span>,<br>&#125;,<br><br>cluster_client_m = &#123;<br>launch_seq = <span class="hljs-number">2</span>,<br>launch_num = <span class="hljs-number">1</span>,<br>default_arg = &#123;<br>node_map = &#123;<br>[<span class="hljs-string">&#x27;cluster_server&#x27;</span>] = &#123;<br>[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;127.0.0.1:9688&quot;</span>,<br>[<span class="hljs-number">2</span>] = <span class="hljs-string">&quot;127.0.0.1:9689&quot;</span>,<br>&#125;<br>&#125;<br>&#125;<br>&#125;,<br><br>test_m = &#123;<br>launch_seq = <span class="hljs-number">4</span>,<br>launch_num = <span class="hljs-number">1</span>,<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>之后使用<code>cluster_client</code>就可以使用<strong>远程RPC</strong>调用了</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> cli = cluster_client:new(<span class="hljs-string">&quot;cluster_server&quot;</span>,<span class="hljs-string">&quot;test_m&quot;</span>) <span class="hljs-comment">--访问cluster_server的test_m模板</span><br><br>cli:one_balance_send(<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-string">&quot;one_balance_send&quot;</span>)         <span class="hljs-comment">--调用hello命令</span><br></code></pre></td></tr></table></figure><h1 id="详细API介绍"><a href="#详细API介绍" class="headerlink" title="详细API介绍"></a><a href="https://huahua132.github.io/2024/01/07/skynet_fly_api/rpcf/">详细API介绍</a></h1>]]></content>
    
    
    <categories>
      
      <category>skynet_fly 文档</category>
      
      <category>基础篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>skynet_fly_word</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>检查热更的使用以及原理</title>
    <link href="/2023/02/25/skynet_fly_word/word_2/D_reload/"/>
    <url>/2023/02/25/skynet_fly_word/word_2/D_reload/</url>
    
    <content type="html"><![CDATA[<h1 id="如何执行"><a href="#如何执行" class="headerlink" title="如何执行"></a>如何执行</h1><p><code>sh script/check_reload.sh load_mods.lua</code></p><h1 id="检测规则"><a href="#检测规则" class="headerlink" title="检测规则"></a>检测规则</h1><p>当 <strong>可热更服务模块</strong> require的代码文件有修改，或者在load_mods.lua中的配置有修改，就会热更该服务。</p><h1 id="重试热更"><a href="#重试热更" class="headerlink" title="重试热更"></a>重试热更</h1><p>当 热更后，某个执行热更的服务，<code>start</code>启动失败了，旧服务此时会继续工作，框架会记录热更失败的命令。我们此时可以去修改掉错误后，进行重试。<br><code>sh script/try_again_reload.sh load_mods.lua</code></p><h1 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a><a href="https://huahua132.github.io/2023/06/30/skynet_fly_ss/%E5%85%B3%E4%BA%8Eskynet_fly%E7%83%AD%E6%9B%B4%E6%96%B0%E5%AE%9E%E7%8E%B0/">实现细节</a></h1>]]></content>
    
    
    <categories>
      
      <category>skynet_fly 文档</category>
      
      <category>基础篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>skynet_fly_word</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>启动时生成的临时文件说明</title>
    <link href="/2023/02/25/skynet_fly_word/word_2/F_tmpfile/"/>
    <url>/2023/02/25/skynet_fly_word/word_2/F_tmpfile/</url>
    
    <content type="html"><![CDATA[<p><img src="/img/skynet_fly_word/word_2/tmpfile.png"></p><h1 id="chinese-chess-config-lua"><a href="#chinese-chess-config-lua" class="headerlink" title="chinese_chess_config.lua"></a>chinese_chess_config.lua</h1><p>介入生成的<strong>script</strong>脚本中有很多命令都需要通过debug_console入口去操作，比如<strong>检测热更</strong>，<strong>快进时间</strong>。所有需要有一个地方拿到启动时的debug_port参数，由于生成的<strong>chinese_chess_config.lua</strong>会因启动第二服而重写导致改变，所以启动时需要copy一个运行时副本，供script去读取启动时参数。</p><h1 id="module-info"><a href="#module-info" class="headerlink" title="module_info"></a>module_info</h1><p>用于记录可如果模块文件的修改时间，用于后续检测热更。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">return</span> &#123;<br>        [<span class="hljs-string">&#x27;skynet-fly.utils.time_util&#x27;</span>] = &#123;<br>                [<span class="hljs-string">&#x27;dir&#x27;</span>] = <span class="hljs-string">&#x27;../../skynet_fly/lualib/skynet-fly/utils/time_util.lua&#x27;</span>,<br>                [<span class="hljs-string">&#x27;last_change_time&#x27;</span>] = <span class="hljs-number">1712716696</span>,<br>        &#125;,<br>        [<span class="hljs-string">&#x27;skynet-fly.timer&#x27;</span>] = &#123;<br>                [<span class="hljs-string">&#x27;dir&#x27;</span>] = <span class="hljs-string">&#x27;../../skynet_fly/lualib/skynet-fly/timer.lua&#x27;</span>,<br>                [<span class="hljs-string">&#x27;last_change_time&#x27;</span>] = <span class="hljs-number">1709543644</span>,<br>        &#125;,<br>        [<span class="hljs-string">&#x27;skynet-fly.utils.string_util&#x27;</span>] = &#123;<br>                [<span class="hljs-string">&#x27;dir&#x27;</span>] = <span class="hljs-string">&#x27;../../skynet_fly/lualib/skynet-fly/utils/string_util.lua&#x27;</span>,<br>                [<span class="hljs-string">&#x27;last_change_time&#x27;</span>] = <span class="hljs-number">1709543644</span>,<br>        &#125;,<br>        [<span class="hljs-string">&#x27;skynet-fly.client.contriner_client&#x27;</span>] = &#123;<br>                [<span class="hljs-string">&#x27;dir&#x27;</span>] = <span class="hljs-string">&#x27;../../skynet_fly/lualib/skynet-fly/client/contriner_client.lua&#x27;</span>,<br>                [<span class="hljs-string">&#x27;last_change_time&#x27;</span>] = <span class="hljs-number">1712131772</span>,<br>        &#125;,<br>        [<span class="hljs-string">&#x27;skynet-fly.log&#x27;</span>] = &#123;<br>                [<span class="hljs-string">&#x27;dir&#x27;</span>] = <span class="hljs-string">&#x27;../../skynet_fly/lualib/skynet-fly/log.lua&#x27;</span>,<br>                [<span class="hljs-string">&#x27;last_change_time&#x27;</span>] = <span class="hljs-number">1709621604</span>,<br>        &#125;,<br>        [<span class="hljs-string">&#x27;skynet-fly.etc.module_info&#x27;</span>] = &#123;<br>                [<span class="hljs-string">&#x27;dir&#x27;</span>] = <span class="hljs-string">&#x27;../../skynet_fly/lualib/skynet-fly/etc/module_info.lua&#x27;</span>,<br>                [<span class="hljs-string">&#x27;last_change_time&#x27;</span>] = <span class="hljs-number">1709543644</span>,<br>        &#125;,<br>        [<span class="hljs-string">&#x27;share_config_m&#x27;</span>] = &#123;<br>                [<span class="hljs-string">&#x27;dir&#x27;</span>] = <span class="hljs-string">&#x27;../../skynet_fly/module/share_config_m.lua&#x27;</span>,<br>                [<span class="hljs-string">&#x27;last_change_time&#x27;</span>] = <span class="hljs-number">1709543644</span>,<br>        &#125;,<br>        [<span class="hljs-string">&#x27;skynet-fly.contriner.contriner_interface&#x27;</span>] = &#123;<br>                [<span class="hljs-string">&#x27;dir&#x27;</span>] = <span class="hljs-string">&#x27;../../skynet_fly/lualib/skynet-fly/contriner/contriner_interface.lua&#x27;</span>,<br>                [<span class="hljs-string">&#x27;last_change_time&#x27;</span>] = <span class="hljs-number">1709543644</span>,<br>        &#125;,<br>        [<span class="hljs-string">&#x27;skynet-fly.utils.skynet_util&#x27;</span>] = &#123;<br>                [<span class="hljs-string">&#x27;dir&#x27;</span>] = <span class="hljs-string">&#x27;../../skynet_fly/lualib/skynet-fly/utils/skynet_util.lua&#x27;</span>,<br>                [<span class="hljs-string">&#x27;last_change_time&#x27;</span>] = <span class="hljs-number">1709543644</span>,<br>        &#125;,<br>        [<span class="hljs-string">&#x27;skynet-fly.write_mod_required&#x27;</span>] = &#123;<br>                [<span class="hljs-string">&#x27;dir&#x27;</span>] = <span class="hljs-string">&#x27;../../skynet_fly/lualib/skynet-fly/write_mod_required.lua&#x27;</span>,<br>                [<span class="hljs-string">&#x27;last_change_time&#x27;</span>] = <span class="hljs-number">1709543644</span>,<br>        &#125;,<br>        [<span class="hljs-string">&#x27;skynet-fly.utils.table_util&#x27;</span>] = &#123;<br>                [<span class="hljs-string">&#x27;dir&#x27;</span>] = <span class="hljs-string">&#x27;../../skynet_fly/lualib/skynet-fly/utils/table_util.lua&#x27;</span>,<br>                [<span class="hljs-string">&#x27;last_change_time&#x27;</span>] = <span class="hljs-number">1709543644</span>,<br>        &#125;,<br>&#125;<br></code></pre></td></tr></table></figure><p>这是其中一个的内容。</p><h1 id="load-mod-lua-old"><a href="#load-mod-lua-old" class="headerlink" title="load_mod.lua.old"></a>load_mod.lua.old</h1><p>也是记录运行的配置，用于对比检测热更。</p><h1 id="skynet-load-mods-lua-pid"><a href="#skynet-load-mods-lua-pid" class="headerlink" title="skynet.load_mods.lua.pid"></a>skynet.load_mods.lua.pid</h1><p>记录运行时的pid，用于守护进程，防止重复启动。</p>]]></content>
    
    
    <categories>
      
      <category>skynet_fly 文档</category>
      
      <category>基础篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>skynet_fly_word</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>快进时间</title>
    <link href="/2023/02/25/skynet_fly_word/word_2/E_fasttime/"/>
    <url>/2023/02/25/skynet_fly_word/word_2/E_fasttime/</url>
    
    <content type="html"><![CDATA[<h1 id="如何执行"><a href="#如何执行" class="headerlink" title="如何执行"></a>如何执行</h1><p><code>sh script/fasttime.sh load_mods.lua &#39;2023:10:26 19:22:50&#39; 1</code></p><p>最后一个<code>1</code>表示1秒1秒的快进。</p><h1 id="快进时间存在的问题"><a href="#快进时间存在的问题" class="headerlink" title="快进时间存在的问题"></a>快进时间存在的问题</h1><p>比如一分钟一分钟的快进。<br>有如下代码</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> cnt = <span class="hljs-number">1</span><br><span class="hljs-keyword">while</span> <span class="hljs-literal">true</span> <span class="hljs-keyword">do</span><br>    skynet.sleep(<span class="hljs-number">100</span>)<br>    <span class="hljs-built_in">log</span>.info(<span class="hljs-string">&quot;hello&quot;</span>, cnt)<br>    cnt = cnt + <span class="hljs-number">1</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>正常流逝1小时，cnt能达到3600次。<br>按1秒1秒快进能达到3600次。<br>按60秒秒快进只能达到60次。</p>]]></content>
    
    
    <categories>
      
      <category>skynet_fly 文档</category>
      
      <category>基础篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>skynet_fly_word</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前言</title>
    <link href="/2023/02/25/skynet_fly_word/word_1/A_home/"/>
    <url>/2023/02/25/skynet_fly_word/word_1/A_home/</url>
    
    <content type="html"><![CDATA[<h1 id="项目简介"><a href="#项目简介" class="headerlink" title="项目简介"></a>项目简介</h1><p>skynet_fly的理念是基于skynet开发开箱即用的微服务框架，旨在大家使用该框架，不会想着需要修改底层源码，而是基于该框架对服务端做一个快速搭建。<br>skynet_fly持续迭代的原则，尽量向下兼容，不会因向下兼容性而束手束脚，后续考虑使用版本更新日志记录大版本的改动信息。</p><h1 id="框架优势"><a href="#框架优势" class="headerlink" title="框架优势"></a>框架优势</h1><p>skynet_fly是基于skynet扩展的可以快速开发web，游戏，和需要rpc调用的框架。<br>使用skynet_fly的好处：</p><ul><li>支持不停服更新。</li><li>一键生成skynet的配置文件和skynet_fly的配置文件以及配套shell脚本。</li><li>对匹配房间类游戏做了gate,ws_gate的基础设施封装以及pb,json协议的支持，开发游戏只需要实现相关业务逻辑。</li><li>对redis,mysql,timer,log 使用封装。</li><li>基于skynet cluster封装出简单易用的远程rpc调用。</li><li>支持服务发现。</li><li>支持http服务长连接。</li><li>支持http服务路由，中间件模式。</li><li>支持jwt鉴权。</li><li>内置日志分割。</li><li>支持快进时间。</li><li>支持orm（数据关系映射）目前适配了(mysql,mongo),数据库可无缝切换。</li></ul><h1 id="适合哪些人群"><a href="#适合哪些人群" class="headerlink" title="适合哪些人群"></a>适合哪些人群</h1><ol><li>喜欢lua语言，想用lua开发游戏、网站、后台、API服务等等。</li></ol><p>如果你对skynet没有一点点了解，可能使用该框架会有点困难，建议先大概了解学习<a href="https://github.com/cloudwu/skynet">skynet框架</a></p><ol start="2"><li>对skynet有一定了解，却迷茫于如何架构服务。</li></ol><p>对skynet有一定了解，那么上手该框架将会轻松很多。</p><h1 id="为什么要开发一个skynet-fly框架？"><a href="#为什么要开发一个skynet-fly框架？" class="headerlink" title="为什么要开发一个skynet_fly框架？"></a>为什么要开发一个skynet_fly框架？</h1><ol><li>skynet框架不是开箱即用的，使用skynet开发游戏基本上或多或少都需要对框架做一些修改。</li></ol><p>在开源框架当中，大部分好用的框架都是开箱即用的，对新手非常友好。使用skynet如果没有人带路的话，还是挺困难的，想要用的好，得看明白底层代码，然后还需要一些架构能力。<br>而使用skynet_fly，提供了很多基础设施的支持，架构服务只需要关注实现业务代码，能够更快速的开发迭代。</p><ol start="2"><li>使用lua开发网站的框架较少，我想skynet_fly可以做到。</li></ol><p><a href="https://github.com/hanxi">涵曦</a>开发的<a href="https://github.com/hanxi/wlua">wlua</a>可以说是实现了lua版本 <a href="https://github.com/gin-gonic/gin">gin</a>框架。<br>我把wlua的核心代码嵌入了skynet_fly中，再利用skynet_fly的热更模块机制，可以做到网站服务热更。</p><h1 id="框架提供了这么多功能是不是很复杂，很难用？"><a href="#框架提供了这么多功能是不是很复杂，很难用？" class="headerlink" title="框架提供了这么多功能是不是很复杂，很难用？"></a>框架提供了这么多功能是不是很复杂，很难用？</h1><p>可以说的核心只是基于skynet开发一套方便构建服务的<strong>脚手架</strong>，像web服务，集群RPC，还有一些封装，日志分割等等都是附加功能。<br>可以认为学会使用脚手架的学习使用skynet_fly的<strong>必要知识</strong>。<br>其他都是<strong>附加知识</strong>，只需要用的时候来取就行，不需要一股作气全部学完。</p><h1 id="文档的食用流程"><a href="#文档的食用流程" class="headerlink" title="文档的食用流程"></a>文档的食用流程</h1><ol><li><p>基础篇<br>介绍skynet_fly如何安装编译skynet_fly、开发流程推荐、如何构建skynet_fly服务、开发规范等等，学习完基础篇，可以说就是入门了。新手流程已经走完了，后续都是刷怪捡装备提升实力了，简直轻轻松松。</p></li><li><p>进阶篇<br>学习核心功能模块，主要是RPC，远程RPC调用。</p></li><li><p>强化篇<br>附加功能模块的使用文档，放心食用。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>skynet_fly 文档</category>
      
      <category>入门篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>skynet_fly_word</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>开发环境推荐</title>
    <link href="/2023/02/25/skynet_fly_word/word_1/B_env/"/>
    <url>/2023/02/25/skynet_fly_word/word_1/B_env/</url>
    
    <content type="html"><![CDATA[<h1 id="vscode-Oracle-VM-VirtualBox"><a href="#vscode-Oracle-VM-VirtualBox" class="headerlink" title="vscode + Oracle VM VirtualBox"></a>vscode + Oracle VM VirtualBox</h1><p>vscode加虚拟机的方式，是我常用的开发方式。</p><h2 id="安装虚拟机"><a href="#安装虚拟机" class="headerlink" title="安装虚拟机"></a>安装虚拟机</h2><ol><li>安装VirtualBox,<a href="https://www.virtualbox.org/">官网下载安装即可</a></li><li>下载centos或者ubantu镜像</li></ol><ul><li><a href="https://mirrors.bfsu.edu.cn/centos/7.9.2009/isos/x86_64/CentOS-7-x86_64-DVD-2009.iso">centos</a></li><li><a href="https://releases.ubuntu.com/22.04/ubuntu-22.04.4-desktop-amd64.iso">ubuntu</a></li></ul><ol start="3"><li>使用VirtualBox安装虚拟机<br>这里自行百度。</li></ol><h2 id="vscode安装插件"><a href="#vscode安装插件" class="headerlink" title="vscode安装插件"></a>vscode安装插件</h2><p><a href="https://github.com/Tencent/LuaHelper">luaHelper</a><br><a href="https://github.com/Natizyskunk/vscode-sftp/releases">sftp</a></p><h3 id="配置SFTP"><a href="#配置SFTP" class="headerlink" title="配置SFTP"></a>配置SFTP</h3><ol><li><p>创建配置<br><code>ctrl shift p</code><br><img src="/img/skynet_fly_word/word_1/sftp.png"></p></li><li><p>编辑配置</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;skynet_fly&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;host&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;127.0.0.1&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;protocol&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;sftp&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;port&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">22</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;username&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;root&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;password&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;123456&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;remotePath&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/home/weihua/skynet_fly&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;uploadOnSave&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;useTempFile&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;openSsh&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></li><li><p>上传文件<br><img src="/img/skynet_fly_word/word_1/sftp2.png"></p></li></ol><p>没有出错的话，文件已经上传到linux的对应目录了。</p>]]></content>
    
    
    <categories>
      
      <category>skynet_fly 文档</category>
      
      <category>入门篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>skynet_fly_word</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何编写可热更服务模块</title>
    <link href="/2023/02/25/skynet_fly_word/word_1/F_module/"/>
    <url>/2023/02/25/skynet_fly_word/word_1/F_module/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>使用skynet开发服务，通常不会把所有任务写在一个服务中，一般会拆分成一个个服务单元，服务单元通过rpc调用协同工作。</p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><strong>可热更服务模块</strong> 本质上就是一个skynet的lua服务，是用skynet.newservice API 创建的。只是会<strong>加载指定的 xxx_m.lua文件</strong>,相当于用相同的盒子包装不同的东西。</p><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> CMD = &#123;&#125;<br><br><span class="hljs-comment">--start 函数是必须实现的，返回true，说明启动成功，false，说明启动失败</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CMD.start</span><span class="hljs-params">(config)</span></span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br><span class="hljs-keyword">end</span><br><span class="hljs-comment">-- herald_exit 有新服务尝试上线</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CMD.herald_exit</span><span class="hljs-params">()</span></span><br>    <span class="hljs-built_in">log</span>.<span class="hljs-built_in">error</span>(<span class="hljs-string">&quot;预告退出&quot;</span>)<br><span class="hljs-keyword">end</span><br><span class="hljs-comment">-- exit 函数 必须实现，返回true，说明可以退出，将会在1段时间后调用skynet.exit()</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CMD.exit</span><span class="hljs-params">()</span></span><br>    <span class="hljs-built_in">log</span>.<span class="hljs-built_in">error</span>(<span class="hljs-string">&quot;退出&quot;</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br><span class="hljs-keyword">end</span><br><span class="hljs-comment">-- fix_exit 说明已经热更成功，有新服务上线了，旧服务可以处理下线工作了</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CMD.fix_exit</span><span class="hljs-params">()</span></span><br>    <span class="hljs-built_in">log</span>.<span class="hljs-built_in">error</span>(<span class="hljs-string">&quot;确认要退出&quot;</span>)<br><span class="hljs-keyword">end</span><br><span class="hljs-comment">-- cancel_exit 新服务上线失败</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CMD.cancel_exit</span><span class="hljs-params">()</span></span><br>    <span class="hljs-built_in">log</span>.<span class="hljs-built_in">error</span>(<span class="hljs-string">&quot;取消退出&quot;</span>)<br><span class="hljs-keyword">end</span><br><span class="hljs-comment">-- check_exit 检查退出，返回true，表示可以退出。</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CMD.check_exit</span><span class="hljs-params">()</span></span><br>    <span class="hljs-built_in">log</span>.<span class="hljs-built_in">error</span>(<span class="hljs-string">&quot;检查退出&quot;</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">--自定义 rpc 命令 处理函数</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CMD.doingsame</span><span class="hljs-params">()</span></span><br><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">return</span> CMD<br></code></pre></td></tr></table></figure><h1 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a><a href="https://huahua132.github.io/2023/12/03/skynet_fly_ss/reload/">实现细节</a></h1><p>实现细节，有兴趣可以看看。</p>]]></content>
    
    
    <categories>
      
      <category>skynet_fly 文档</category>
      
      <category>入门篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>skynet_fly_word</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>构建服务脚手架</title>
    <link href="/2023/02/25/skynet_fly_word/word_1/D_creator/"/>
    <url>/2023/02/25/skynet_fly_word/word_1/D_creator/</url>
    
    <content type="html"><![CDATA[<h1 id="为啥需要脚手架？"><a href="#为啥需要脚手架？" class="headerlink" title="为啥需要脚手架？"></a>为啥需要脚手架？</h1><p>如果你对缘由感兴趣，可以看看<a href="https://huahua132.github.io/2023/06/30/skynet_fly_ss/%E5%85%B3%E4%BA%8Eskynet_fly%E7%9A%84%E4%B8%80%E9%94%AE%E6%9E%84%E5%BB%BA%E6%9C%8D%E5%8A%A1%E9%85%8D%E7%BD%AE/">这个</a></p><h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><ol><li>生成skynet 启动配置文件</li><li>生成服务基础运维脚本</li></ol><h1 id="构建命令"><a href="#构建命令" class="headerlink" title="构建命令"></a>构建命令</h1><p><code>skynet_fly/binshell/make_server.sh skynet_fly_path</code></p><p>我们已构建<code>skynet_fly/examples/webapp</code>为例子</p><ol><li><p>进入服务文件夹目录下。<br><code>cd skynet_fly/examples/webapp</code></p></li><li><p>构建运维脚本。<br><code>bash ../../binshell/make_server.sh ../../</code></p></li></ol><p>之后会生成以下文件。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk">make ./webapp_config.lua<br>make .<span class="hljs-regexp">/script/</span>run.sh                运行<br>make .<span class="hljs-regexp">/script/</span>reload.sh             热更可热更服务模块<br>make .<span class="hljs-regexp">/script/</span>check_reload.sh       自动检查文件修改并热更<br>make .<span class="hljs-regexp">/script/</span>kill_mod.sh           干掉某些可热更服务模块<br>make .<span class="hljs-regexp">/script/</span>stop.sh               停服<br>make .<span class="hljs-regexp">/script/</span>restart.sh            重启<br>make .<span class="hljs-regexp">/script/</span>try_again_reload.sh   热更失败后，可以重试热更<br>make .<span class="hljs-regexp">/script/</span>fasttime.sh           加速时间<br></code></pre></td></tr></table></figure><p>可以发现<code>webapp_config.lua</code>的生成规则是这样的<code>svr_name</code> .. <code>_config.lua</code>，也就是服务文件夹的名字拼接起来的，在skynet_fly默认服务文件夹名为<strong>服务名称</strong>，这个<strong>服务名称</strong>在<strong>集群远程rpc</strong>中会用到。</p><ol start="3"><li>运行服务。<br>script&#x2F;run.sh 配置文件 是否守护进程(0 不启用 默认启用)<br><code>bash script/run.sh load_mods_prod.lua 0</code> 或者 <code>bash script/run.sh load_mods.lua 0</code></li></ol><ul><li>守护进程运行，后台运行，log会写在日志文件，目前日志文件默认放在<code>logs/server.log</code>下面。</li><li>非守护进程运行，ctrl + c 就会终止服务。</li></ul><p>我们可以使用不同的配置文件来启动服务，这样可以方便的区分，正式环境，开发环境，测试环境不同的配置。<br>也可以方便部署单机多服，单机就能模拟多机部署。</p><p>比如以上的两种启动方式就相当于启动了两个服务。</p><ul><li>bash script&#x2F;run.sh load_mods_prod.lua     用生成环境配置</li><li>bash script&#x2F;run.sh load_mods.lua          用测试环境配置</li></ul><p>我们给指定的服务执行命令时，需要带上启动的<strong>配置文件名</strong>，因为当单机上部署多个相同服务时我们需要区分它们。<br>比如<strong>检查热更</strong></p><ul><li>正式环境 bash script&#x2F;check_reload.sh load_mods_prod.lua</li><li>测试环境 bash script&#x2F;check_reload.sh load_mods.lua</li></ul><h1 id="命令使用注意点"><a href="#命令使用注意点" class="headerlink" title="命令使用注意点"></a>命令使用注意点</h1><p>script中的脚本命令并不能在任意目录下执行。script中的shell命令，都默认当前路径的服务的根目录，所有必须在服务的根目录执行。<br>比如你cd 到script目录，执行相关命令就不行。</p><p>上面脚本有关于热更的命令，我们先不急着了解热更命令，我们先看看下一节，如何配置运行可热更服务。</p>]]></content>
    
    
    <categories>
      
      <category>skynet_fly 文档</category>
      
      <category>入门篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>skynet_fly_word</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>load_mods配置文件的使用</title>
    <link href="/2023/02/25/skynet_fly_word/word_1/E_load_mods/"/>
    <url>/2023/02/25/skynet_fly_word/word_1/E_load_mods/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>load_mods配置文件是skynet_fly非常核心的东西。通常一个服务为了区分不同环境，都会有一个服务配置项。<br>传统的服务端配置可能就是key-value形式的配置项，因为大部分传统服务端都是把配置做成全局单例，方便读取。</p><h1 id="skynet-有个启动配置，为啥还要新增一个？"><a href="#skynet-有个启动配置，为啥还要新增一个？" class="headerlink" title="skynet 有个启动配置，为啥还要新增一个？"></a>skynet 有个启动配置，为啥还要新增一个？</h1><ol><li>因为skynet_env都是key-value形式的，而且是配置在全局变量中，不方便做配置遍历。</li><li>skynet_env读取数据需要竞争自选锁，使用中应该尽量少用（尽量在代码加载阶段拿取）。</li><li>不适用于给可插拔的可热更服务编写配置。</li><li>无法热更。</li></ol><h1 id="配置介绍"><a href="#配置介绍" class="headerlink" title="配置介绍"></a>配置介绍</h1><p>以<code>webapp</code>中的配置为例</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">return</span> &#123;<br>share_config_m = &#123;<br>launch_seq = <span class="hljs-number">1</span>,<br>launch_num = <span class="hljs-number">1</span>,<br>default_arg = &#123;<br>server_cfg = &#123;<br>thread = <span class="hljs-number">2</span>,<br>debug_port = <span class="hljs-number">9001</span>,<br>&#125;<br>&#125;<br>&#125;,<br><br>web_agent_m = &#123;<br>launch_seq = <span class="hljs-number">1</span>,<br>launch_num = <span class="hljs-number">6</span>,<br>default_arg = &#123;<br>protocol = <span class="hljs-string">&#x27;http&#x27;</span>,<br>dispatch = <span class="hljs-string">&#x27;apps.webapp_dispatch&#x27;</span>,<br>keep_alive_time = <span class="hljs-number">300</span>,         <span class="hljs-comment">--最长保活时间</span><br>second_req_limit = <span class="hljs-number">2000</span>,       <span class="hljs-comment">--1秒内请求数量限制</span><br>&#125;<br>&#125;,<br><br>web_master_m = &#123;<br>launch_seq = <span class="hljs-number">2</span>,<br>launch_num = <span class="hljs-number">1</span>,<br>default_arg = &#123;<br>protocol = <span class="hljs-string">&#x27;http&#x27;</span>,<br>port = <span class="hljs-number">80</span>,         <span class="hljs-comment">--端口</span><br>max_client = <span class="hljs-number">6000</span>, <span class="hljs-comment">--最大连接数</span><br>second_conn_limit = <span class="hljs-number">2000</span>, <span class="hljs-comment">--相同ip 1秒内建立连接数限制</span><br>keep_live_limit = <span class="hljs-number">2000</span>,  <span class="hljs-comment">--相同ip 保持活跃数量限制</span><br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>配置返回一个表。<br>表的<strong>key</strong>需要填写想要启动的<strong>可热更服务模块</strong>，就是<code>****_m.lua</code>文件。<br>表的<strong>value</strong>就是对应这个<strong>可热更服务模块</strong>的详细配置。<br>其中字段意义如下:</p><ul><li><strong>launch_seq</strong> 启动顺序。</li><li><strong>launch_num</strong> 启动数量。</li><li><strong>default_arg</strong> 默认配置。</li><li><strong>mod_args</strong> 模块配置。</li></ul><p>假设launch_num &#x3D; 2,就会启动2个可热更模板服务，index 1、2<br>拿取配置规则为: <code>cfg = mod_args[index] or default_arg</code><br>优先拿mod_args的专属配置，没有取默认配置。</p><ul><li><strong>delay_run</strong> 推迟运行。</li></ul><p><strong>可热更模块服务的启动</strong><br><a href="https://github.com/huahua132/skynet_fly/blob/master/lualib/skynet-fly/contriner/contriner_launcher.lua">launcher</a></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">M.run</span><span class="hljs-params">()</span></span><br>    skynet.monitor(<span class="hljs-string">&#x27;monitor_exit&#x27;</span>)<br>    <span class="hljs-keyword">local</span> cmgr = skynet.uniqueservice(<span class="hljs-string">&#x27;contriner_mgr&#x27;</span>)<br>skynet.uniqueservice(<span class="hljs-string">&quot;debug_console&quot;</span>, skynet.<span class="hljs-built_in">getenv</span>(<span class="hljs-string">&#x27;debug_port&#x27;</span>))<br><br>    <span class="hljs-keyword">local</span> before_run_list = &#123;&#125; <span class="hljs-comment">--先跑</span><br>    <span class="hljs-keyword">local</span> delay_run_list = &#123;&#125;  <span class="hljs-comment">--延迟再次调用再跑</span><br><span class="hljs-keyword">for</span> mod_name,mod_cfg <span class="hljs-keyword">in</span> table_util.sort_ipairs(load_mods,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(a,b)</span></span><br><span class="hljs-keyword">return</span> a.launch_seq &lt; b.launch_seq<br><span class="hljs-keyword">end</span>) <span class="hljs-keyword">do</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> mod_cfg.delay_run <span class="hljs-keyword">then</span><br>            <span class="hljs-built_in">table</span>.<span class="hljs-built_in">insert</span>(before_run_list, mod_name)<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-built_in">table</span>.<span class="hljs-built_in">insert</span>(delay_run_list, mod_name)<br>        <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">local</span> self_address = skynet.<span class="hljs-built_in">self</span>()<br>    skynet.call(cmgr, <span class="hljs-string">&#x27;lua&#x27;</span>, <span class="hljs-string">&#x27;load_modules&#x27;</span>, self_address, <span class="hljs-built_in">table</span>.<span class="hljs-built_in">unpack</span>(before_run_list))<br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> delay_run_list <span class="hljs-keyword">then</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">end</span><br>        skynet.call(cmgr, <span class="hljs-string">&#x27;lua&#x27;</span>, <span class="hljs-string">&#x27;load_modules&#x27;</span>, self_address, <span class="hljs-built_in">table</span>.<span class="hljs-built_in">unpack</span>(delay_run_list))<br>        delay_run_list = <span class="hljs-literal">nil</span><br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>启动函数执行会返回需要推迟运行的函数，因为可能存在这种情况，可热更服务模块中依赖的<strong>普通skynet服务</strong>，此时就需要先启动<strong>普通skynet服务</strong>，再启动推迟运行的<strong>可热更模块服务</strong>。</p><h1 id="mod-args-index-或者-default-arg的配置传递到哪了？"><a href="#mod-args-index-或者-default-arg的配置传递到哪了？" class="headerlink" title="mod_args[index] 或者 default_arg的配置传递到哪了？"></a>mod_args[index] 或者 default_arg的配置传递到哪了？</h1><p>一个<strong>可热更服务模板</strong>必须定义<code>start</code>和<code>exit</code>两个回调函数。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> CMD = &#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CMD.start</span><span class="hljs-params">(config)</span></span> <span class="hljs-comment">--mod_args[index] or default_arg</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CMD.exit</span><span class="hljs-params">()</span></span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">return</span> CMD<br></code></pre></td></tr></table></figure><p>可以看到，配置传递到<code>start</code>函数中了。</p><p>我们也可以通过加载<code>skynet-fly.etc.module_info</code>来获取配置信息。</p><p>module_info提供了 <code>get_cfg()</code>方法供获取配置。<br>还提供了<code>get_base_info()</code>供查询可热更服务的基础信息。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lua">module_name = MODULE_NAME,     <span class="hljs-comment">--模块名称  比如 web_master_m web_agent_m</span><br>index = INDEX,   <span class="hljs-comment">--启动索引  比如启动6   6个服务的索引分别 是 1 - 6</span><br>launch_date = LAUNCH_DATE,   <span class="hljs-comment">--启动日期</span><br>launch_time = LAUNCH_TIME,   <span class="hljs-comment">--启动时间戳</span><br>version = VERSION,   <span class="hljs-comment">--版本号    热更会使版本号增加</span><br></code></pre></td></tr></table></figure><p>如果不是可热更服务，调用相关命令<br><code>get_cfg</code>会返回nil<br><code>get_base_info</code>将是一个空table。</p><h1 id="如何区分可热更服务和普通服务"><a href="#如何区分可热更服务和普通服务" class="headerlink" title="如何区分可热更服务和普通服务"></a>如何区分可热更服务和普通服务</h1><p>skynet_fly中，有两个特殊的全局变量。<br>SERVICE_NAME 是skynet启动服务名。<br>MODULE_NAME是可热更模块的名称。如果一个服务中，这个值为nil，它就是一个可热更服务。</p>]]></content>
    
    
    <categories>
      
      <category>skynet_fly 文档</category>
      
      <category>入门篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>skynet_fly_word</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>项目文件夹介绍</title>
    <link href="/2023/02/25/skynet_fly_word/word_1/G_dir/"/>
    <url>/2023/02/25/skynet_fly_word/word_1/G_dir/</url>
    
    <content type="html"><![CDATA[<h1 id="3rd"><a href="#3rd" class="headerlink" title="3rd"></a>3rd</h1><p>存放第三方依赖</p><h1 id="binshell"><a href="#binshell" class="headerlink" title="binshell"></a>binshell</h1><p>服务构建工具</p><h1 id="examples"><a href="#examples" class="headerlink" title="examples"></a>examples</h1><p>示例学习服务</p><h1 id="lualib"><a href="#lualib" class="headerlink" title="lualib"></a>lualib</h1><p>skynet_fly lua库文件代码</p><h1 id="module"><a href="#module" class="headerlink" title="module"></a>module</h1><p>skynet_fly 提供的<strong>可热更服务模块</strong></p><h1 id="script"><a href="#script" class="headerlink" title="script"></a>script</h1><p>lua shell 脚本工具代码</p><h1 id="service"><a href="#service" class="headerlink" title="service"></a>service</h1><p>skynet普通服务</p><h1 id="skynet"><a href="#skynet" class="headerlink" title="skynet"></a>skynet</h1><p>skynet代码</p><h1 id="test"><a href="#test" class="headerlink" title="test"></a>test</h1><p>单元测试服务代码，主要用来编写一些模块的单元测试。</p>]]></content>
    
    
    <categories>
      
      <category>skynet_fly 文档</category>
      
      <category>入门篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>skynet_fly_word</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>规范建议</title>
    <link href="/2023/02/25/skynet_fly_word/word_1/H_standard/"/>
    <url>/2023/02/25/skynet_fly_word/word_1/H_standard/</url>
    
    <content type="html"><![CDATA[<h1 id="启动配置文件"><a href="#启动配置文件" class="headerlink" title="启动配置文件"></a>启动配置文件</h1><p><code>load_mods_xxx.lua</code></p><h1 id="可热更模块"><a href="#可热更模块" class="headerlink" title="可热更模块"></a>可热更模块</h1><p>都存放在 <strong>module</strong>命名的文件夹下，以<code>xxx_m.lua</code>命名。<br>编写规范以CMD命令。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> CMD = &#123;&#125;<br><br><span class="hljs-keyword">return</span> CMD<br></code></pre></td></tr></table></figure><h1 id="普通skynet服务"><a href="#普通skynet服务" class="headerlink" title="普通skynet服务"></a>普通skynet服务</h1><p>都存放在 <strong>service</strong>命名的文件夹下，命令随意，因为service的查找规则，只会在service文件夹下查找，文件名重复有可能，但是手动查找范围小。</p><h1 id="普通lua模块"><a href="#普通lua模块" class="headerlink" title="普通lua模块"></a>普通lua模块</h1><p>建议规范</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> M = &#123;&#125;<br><br><span class="hljs-keyword">return</span> M<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>skynet_fly 文档</category>
      
      <category>入门篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>skynet_fly_word</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编译</title>
    <link href="/2023/02/25/skynet_fly_word/word_1/C_builder/"/>
    <url>/2023/02/25/skynet_fly_word/word_1/C_builder/</url>
    
    <content type="html"><![CDATA[<p>推荐使用git,使用git clone的方式拉取下来，因为使用下载的方式，还需要去手动下载对应的submodule，skynet的代码。</p><h1 id="拉取代码"><a href="#拉取代码" class="headerlink" title="拉取代码"></a>拉取代码</h1><p><code>git clone https://github.com/huahua132/skynet_fly.git</code></p><h1 id="拉取子模块代码"><a href="#拉取子模块代码" class="headerlink" title="拉取子模块代码"></a>拉取子模块代码</h1><p><code>cd skynet_fly</code><br><code>git submodule update --init</code></p><h1 id="拉取skynet代码代码子模块"><a href="#拉取skynet代码代码子模块" class="headerlink" title="拉取skynet代码代码子模块"></a>拉取skynet代码代码子模块</h1><p><code>cd skynet</code><br><code>git submodule update --init</code><br><code>cd ../</code></p><h2 id="后续如果需要更新子模块代码"><a href="#后续如果需要更新子模块代码" class="headerlink" title="后续如果需要更新子模块代码"></a>后续如果需要更新子模块代码</h2><p><code>git submodule update --remote</code></p><h1 id="使用sftp上传skynet-fly所有文件"><a href="#使用sftp上传skynet-fly所有文件" class="headerlink" title="使用sftp上传skynet_fly所有文件"></a>使用sftp上传skynet_fly所有文件</h1><h1 id="根据系统安装对应依赖软件和库"><a href="#根据系统安装对应依赖软件和库" class="headerlink" title="根据系统安装对应依赖软件和库"></a>根据系统安装对应依赖软件和库</h1><ul><li><p><strong>ubuntu</strong><br><code>sh install_ubuntu.sh</code></p></li><li><p><strong>centos</strong><br><code>sh install_centos.sh</code></p></li></ul><h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h1><p>cd 到skynet_fly根目录<br><code>make linux</code></p><p>编译没有出错的话，会在生成<code>skynet_fly/skynet/skynet</code>可执行文件。</p>]]></content>
    
    
    <categories>
      
      <category>skynet_fly 文档</category>
      
      <category>入门篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>skynet_fly_word</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>文件查找规则</title>
    <link href="/2023/02/25/skynet_fly_word/word_1/I_file/"/>
    <url>/2023/02/25/skynet_fly_word/word_1/I_file/</url>
    
    <content type="html"><![CDATA[<h1 id="service"><a href="#service" class="headerlink" title="service"></a>service</h1><p><code>luaservice 约束服务只能放在 server根目录 || server-&gt;service || common-&gt;service || skynet_fly-&gt;service || skynet-&gt;service</code></p><h1 id="cpath"><a href="#cpath" class="headerlink" title="cpath"></a>cpath</h1><p><code>file_util.path_join(skynet_fly_path, &#39;/cservice/?.so;&#39;) .. skynet_path .. &quot;cservice/?.so;&quot;,</code></p><h1 id="lua-cpath"><a href="#lua-cpath" class="headerlink" title="lua_cpath"></a>lua_cpath</h1><p><code>file_util.path_join(skynet_fly_path, &#39;/luaclib/?.so;&#39;) .. skynet_path .. &quot;luaclib/?.so;&quot;</code></p><h1 id="lua-path"><a href="#lua-path" class="headerlink" title="lua_path"></a>lua_path</h1><p><code>--创建 lua文件 查找规则，优先级 server下非service文件夹 &gt; server上上级目录common文件夹非service文件夹 &gt; skynet_fly lualib下所有文件夹 &gt; skynet lualib下所以文件夹</code></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">M.create_luapath</span><span class="hljs-params">(skynet_fly_path)</span></span><br><span class="hljs-keyword">local</span> server_path = <span class="hljs-string">&#x27;./&#x27;</span><br><span class="hljs-keyword">local</span> skynet_path = M.path_join(skynet_fly_path, <span class="hljs-string">&#x27;/skynet&#x27;</span>)<br><span class="hljs-keyword">local</span> common_path = <span class="hljs-string">&#x27;../../common/&#x27;</span><br><br><span class="hljs-comment">--server下非service文件夹</span><br><span class="hljs-keyword">local</span> lua_path = server_path .. <span class="hljs-string">&#x27;?.lua;&#x27;</span><br><span class="hljs-keyword">for</span> file_name,file_path,file_info <span class="hljs-keyword">in</span> M.diripairs(server_path) <span class="hljs-keyword">do</span><br><span class="hljs-keyword">if</span> file_info.mode == <span class="hljs-string">&#x27;directory&#x27;</span> <span class="hljs-keyword">and</span> file_name ~= <span class="hljs-string">&#x27;service&#x27;</span> <span class="hljs-keyword">then</span><br>lua_path = lua_path .. file_path .. <span class="hljs-string">&#x27;/?.lua;&#x27;</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">--server上上级目录common所有文件夹</span><br>lua_path = lua_path .. common_path .. <span class="hljs-string">&#x27;?.lua;&#x27;</span><br><span class="hljs-keyword">for</span> file_name,file_path,file_info <span class="hljs-keyword">in</span> M.diripairs(common_path) <span class="hljs-keyword">do</span><br><span class="hljs-keyword">if</span> file_info.mode == <span class="hljs-string">&#x27;directory&#x27;</span> <span class="hljs-keyword">and</span> file_name ~= <span class="hljs-string">&#x27;service&#x27;</span> <span class="hljs-keyword">then</span><br>lua_path = lua_path .. file_path .. <span class="hljs-string">&#x27;/?.lua;&#x27;</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">--skynet_fly lualib下所有文件夹</span><br>lua_path = lua_path .. M.path_join(skynet_fly_path, <span class="hljs-string">&#x27;/lualib/?.lua;&#x27;</span>)<br><span class="hljs-keyword">for</span> file_name,file_path,file_info <span class="hljs-keyword">in</span> M.diripairs(M.path_join(skynet_fly_path, <span class="hljs-string">&#x27;/lualib&#x27;</span>)) <span class="hljs-keyword">do</span><br><span class="hljs-keyword">if</span> file_info.mode == <span class="hljs-string">&#x27;directory&#x27;</span> <span class="hljs-keyword">then</span><br>lua_path = lua_path .. file_path .. <span class="hljs-string">&#x27;/?.lua;&#x27;</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">--skynet_fly 3rd下所有文件夹</span><br>lua_path = lua_path .. M.path_join(skynet_fly_path, <span class="hljs-string">&#x27;/3rd/?.lua;&#x27;</span>)<br><span class="hljs-keyword">for</span> file_name,file_path,file_info <span class="hljs-keyword">in</span> M.diripairs(M.path_join(skynet_fly_path, <span class="hljs-string">&#x27;/3rd&#x27;</span>)) <span class="hljs-keyword">do</span><br><span class="hljs-keyword">if</span> file_info.mode == <span class="hljs-string">&#x27;directory&#x27;</span> <span class="hljs-keyword">then</span><br>lua_path = lua_path .. file_path .. <span class="hljs-string">&#x27;/?.lua;&#x27;</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">--skynet lualib下所以文件夹</span><br>lua_path = lua_path .. skynet_path .. <span class="hljs-string">&#x27;/lualib/?.lua;&#x27;</span><br><span class="hljs-keyword">for</span> file_name,file_path,file_info <span class="hljs-keyword">in</span> M.diripairs(skynet_path .. <span class="hljs-string">&#x27;/lualib&#x27;</span>) <span class="hljs-keyword">do</span><br><span class="hljs-keyword">if</span> file_info.mode == <span class="hljs-string">&#x27;directory&#x27;</span> <span class="hljs-keyword">then</span><br>lua_path = lua_path .. file_path .. <span class="hljs-string">&#x27;/?.lua;&#x27;</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">return</span> lua_path<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>看到这里，基本上<code>skynet_fly</code>的核心实现已经看了一半了，现在你绝对可以使用<code>skynet_fly</code>编写一些独立工作的服务单元。</p><h1 id="版本更新-2024-03-04"><a href="#版本更新-2024-03-04" class="headerlink" title="版本更新[2024.03.04]"></a>版本更新[2024.03.04]</h1><h2 id="github-tag"><a href="#github-tag" class="headerlink" title="github tag"></a>github <a href="https://github.com/huahua132/skynet_fly/commit/cb8ec734b359b7fbe4c9c683dbe10182ab61f4fb">tag</a></h2><h2 id="修改原因"><a href="#修改原因" class="headerlink" title="修改原因"></a>修改原因</h2><p>由于有使用者发现<code>skynet_fly</code>在wsl上启动服务很慢，差不多一秒启动一个服务，而<code>skynet</code>提供的示例还是非常快的，因为wsl访问window文件，因为需要兼容文件系统，所以比访问linux文件要慢很多。起初我怀疑是因为读取文件导致，因为<code>skynet_fly</code>与<code>skynet</code>文件相关的差异就是关闭了代码缓存(skynet.codecache “OFF”)，每个新启动的服务都需要去完整的读取文件，当我尝试去除这个差异再重启服务时，问题依旧没有改善。后面怀疑到<code>lua_path</code>上面，因为按照之前我对<code>lua-path</code>的处理，查找路径可能有几十个，路径多加上路径下的文件多，而<code>require</code>的加载过程会从头到尾，逐个路径查找，直到找到为止，由于我把<code>skynet</code>的库优先级排在最低，所以查找过程几乎都跑完了<code>o(n)</code>的时间复杂度。之后我参数把冗余的<code>3rd</code>中的路径去除一些，再次启动服务，发现速度快不少，从而确定问题。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>在实际开发服务中，一般需要<code>require</code>加载<strong>本服库</strong>，<strong>公共库</strong>，<strong>skynet_fly库</strong>，<strong>skynet库</strong>。我们只需要把这4个库的根目录写入lua_path,<code>require</code>文件依赖是使用<br>本服库.aaa.bbb.ccc的风格引入即可，这样做，不行加载速度快，也更好查找文件的来源。</p><p>修改后的luapath 优先级是这样的</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">M.create_luapath</span><span class="hljs-params">(skynet_fly_path)</span></span><br><span class="hljs-keyword">local</span> server_path = <span class="hljs-string">&#x27;./&#x27;</span><br><span class="hljs-keyword">local</span> skynet_path = M.path_join(skynet_fly_path, <span class="hljs-string">&#x27;/skynet&#x27;</span>)<br><span class="hljs-keyword">local</span> common_path = <span class="hljs-string">&#x27;../../commonlualib/&#x27;</span><br><br><span class="hljs-comment">--server文件夹</span><br><span class="hljs-keyword">local</span> lua_path = server_path .. <span class="hljs-string">&#x27;?.lua;&#x27;</span><br><br><span class="hljs-comment">--server 下 ./module文件夹</span><br>lua_path = lua_path .. server_path .. <span class="hljs-string">&#x27;module/?.lua;&#x27;</span><br><br><span class="hljs-comment">--server上上级目录commonlualib文件夹</span><br>lua_path = lua_path .. common_path .. <span class="hljs-string">&#x27;?.lua;&#x27;</span><br><br><span class="hljs-comment">--server上上级目录commonlualib/module文件夹</span><br>lua_path = lua_path .. common_path .. <span class="hljs-string">&#x27;/module/?.lua;&#x27;</span><br><br><span class="hljs-comment">--skynet_fly lualib文件夹</span><br>lua_path = lua_path .. M.path_join(skynet_fly_path, <span class="hljs-string">&#x27;/lualib/?.lua;&#x27;</span>)<br><br><span class="hljs-comment">--skyent_fly module文件夹</span><br>lua_path = lua_path .. M.path_join(skynet_fly_path, <span class="hljs-string">&#x27;/module/?.lua;&#x27;</span>)<br><br><span class="hljs-comment">--skynet lualib文件夹</span><br>lua_path = lua_path .. skynet_path .. <span class="hljs-string">&#x27;/lualib/?.lua;&#x27;</span><br><br><span class="hljs-keyword">return</span> lua_path<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h2 id="风格"><a href="#风格" class="headerlink" title="风格"></a>风格</h2><ul><li><p><strong>本服库</strong><br><code>require(&quot;enum.code&quot;)</code></p></li><li><p><strong>公共库</strong><br>根节点下面创建一个common目录<br><code>require(&quot;common.enum.code&quot;)</code></p></li><li><p><strong>skynet_fly库</strong><br><code>require(&quot;skynet-fly.enum.code&quot;)</code></p></li><li><p><strong>skynet库</strong><br><code>require(&quot;skynet.enum.code&quot;)</code><br>由于改成这种风格需要调整到skynet源码，暂时不改动，目前仅把skynet.lualib加上lua_path中，所有加载<code>skynet</code>与加载本地库的风格是一致的。</p></li></ul><h2 id="server文件夹是指？"><a href="#server文件夹是指？" class="headerlink" title="server文件夹是指？"></a>server文件夹是指？</h2><p>是指我们启动服务的根目录。<br>比如我们启动示例中的 webapp，就需要cd到webapp的根目录然后启动。</p>]]></content>
    
    
    <categories>
      
      <category>skynet_fly 文档</category>
      
      <category>入门篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>skynet_fly_word</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何更改skynet服务的配置项</title>
    <link href="/2023/02/25/skynet_fly_word/word_1/m_scfg/"/>
    <url>/2023/02/25/skynet_fly_word/word_1/m_scfg/</url>
    
    <content type="html"><![CDATA[<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p><code>load_mods.lua</code> 在配置文件中，我们可以启动一个<code>share_config_m</code>共享配置的模块，我们可以把这些配置放在 <code>server_cfg</code>中。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">return</span> &#123;<br>share_config_m = &#123;<br>launch_seq = <span class="hljs-number">1</span>,<br>launch_num = <span class="hljs-number">1</span>,<br>default_arg = &#123;<br>server_cfg = &#123;<br>thread = <span class="hljs-number">2</span>,                 <span class="hljs-comment">--启用线程数</span><br>debug_port = <span class="hljs-number">9001</span>,          <span class="hljs-comment">--debug端口</span><br>                svr_id = <span class="hljs-number">1</span>,                 <span class="hljs-comment">--服务ID</span><br>                logpath = <span class="hljs-string">&#x27;./logs/&#x27;</span>,        <span class="hljs-comment">--日志目录</span><br>                loglevel = <span class="hljs-string">&#x27;info&#x27;</span>,          <span class="hljs-comment">--日志等级</span><br>                logfilename = <span class="hljs-string">&#x27;server.log&#x27;</span>, <span class="hljs-comment">--日志文件名</span><br>&#125;<br>&#125;<br>&#125;,<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h1><p>如果没有配置，这些参数配置的默认值如下</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs lua">thread = <span class="hljs-number">4</span>,                 <span class="hljs-comment">--启用线程数</span><br>debug_port = <span class="hljs-number">8888</span>,          <span class="hljs-comment">--debug端口</span><br>svr_id = <span class="hljs-number">1</span>,                 <span class="hljs-comment">--服务ID</span><br>logpath = <span class="hljs-string">&#x27;./logs/&#x27;</span>,        <span class="hljs-comment">--日志目录</span><br>loglevel = <span class="hljs-string">&#x27;info&#x27;</span>,          <span class="hljs-comment">--日志等级</span><br>logfilename = <span class="hljs-string">&#x27;server.log&#x27;</span>, <span class="hljs-comment">--日志文件名</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>skynet_fly 文档</category>
      
      <category>入门篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>skynet_fly_word</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
