

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="huahua132">
  <meta name="keywords" content="">
  
    <meta name="description" content="redis有哪些好处？ 数据类型丰富，提供了string,list,hash,set,zset五种基础类型，还提供了stream，geo，bitmap扩展类型string数据结构：简单动态字符串list数据结构：双向链表，压缩列表hash压缩列表，哈希表zset压缩列表，跳表set哈希表，整数数组  数据可以设置过期时间  支持事务  支持脚本化运行  哈希冲突解决 少量的冲突redis使用链式哈">
<meta property="og:type" content="article">
<meta property="og:title" content="redis 知识杂谈">
<meta property="og:url" content="https://huahua132.github.io/2023/05/13/redis/redis/index.html">
<meta property="og:site_name" content="huahua132 blog">
<meta property="og:description" content="redis有哪些好处？ 数据类型丰富，提供了string,list,hash,set,zset五种基础类型，还提供了stream，geo，bitmap扩展类型string数据结构：简单动态字符串list数据结构：双向链表，压缩列表hash压缩列表，哈希表zset压缩列表，跳表set哈希表，整数数组  数据可以设置过期时间  支持事务  支持脚本化运行  哈希冲突解决 少量的冲突redis使用链式哈">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://huahua132.github.io/img/redis/redis_object.jpg">
<meta property="og:image" content="https://huahua132.github.io/img/redis/keys.webp">
<meta property="og:image" content="https://huahua132.github.io/img/redis/code.webp">
<meta property="og:image" content="https://huahua132.github.io/img/redis/geo.webp">
<meta property="og:image" content="https://huahua132.github.io/img/redis/set.webp">
<meta property="og:image" content="https://huahua132.github.io/img/redis/frame.webp">
<meta property="og:image" content="https://huahua132.github.io/img/redis/cache.webp">
<meta property="og:image" content="https://huahua132.github.io/img/redis/cache1.webp">
<meta property="og:image" content="https://huahua132.github.io/img/redis/cache2.webp">
<meta property="og:image" content="https://huahua132.github.io/img/redis/ADIC.webp">
<meta property="article:published_time" content="2023-05-13T03:33:49.000Z">
<meta property="article:modified_time" content="2024-07-15T10:23:11.827Z">
<meta property="article:author" content="huahua132">
<meta property="article:tag" content="redis">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://huahua132.github.io/img/redis/redis_object.jpg">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>redis 知识杂谈 - huahua132 blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"huahua132.github.io","root":"/","version":"1.9.4","typing":{"enable":true,"typeSpeed":100,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  

  

  

  

  

  



  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>huahua132 blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/bg/bg.webp') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="redis 知识杂谈"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-05-13 11:33" pubdate>
          2023年5月13日 中午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          10k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          87 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar category-bar" style="margin-right: -1rem">
    





<div class="category-list">
  
  
    
    
    
    <div class="category row nomargin-x">
      <a class="category-item 
          list-group-item category-item-action col-10 col-md-11 col-xm-11" title="redis"
        id="heading-86a1b907d54bf7010394bf316e183e67" role="tab" data-toggle="collapse" href="#collapse-86a1b907d54bf7010394bf316e183e67"
        aria-expanded="true"
      >
        redis
        <span class="list-group-count">(1)</span>
        <i class="iconfont icon-arrowright"></i>
      </a>
      
      <div class="category-collapse collapse show" id="collapse-86a1b907d54bf7010394bf316e183e67"
           role="tabpanel" aria-labelledby="heading-86a1b907d54bf7010394bf316e183e67">
        
        
          
  <div class="category-post-list">
    
    
      
      
        <a href="/2023/05/13/redis/redis/" title="redis 知识杂谈"
           class="list-group-item list-group-item-action
           active">
          <span class="category-post">redis 知识杂谈</span>
        </a>
      
    
  </div>

        
      </div>
    </div>
  
</div>


  </aside>


    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">redis 知识杂谈</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="redis有哪些好处？"><a href="#redis有哪些好处？" class="headerlink" title="redis有哪些好处？"></a>redis有哪些好处？</h1><ol>
<li><p>数据类型丰富，提供了string,list,hash,set,zset五种基础类型，还提供了stream，geo，bitmap扩展类型<br>string<br>数据结构：简单动态字符串<br>list<br>数据结构：双向链表，压缩列表<br>hash<br>压缩列表，哈希表<br>zset<br>压缩列表，跳表<br>set<br>哈希表，整数数组</p>
</li>
<li><p>数据可以设置过期时间</p>
</li>
<li><p>支持事务</p>
</li>
<li><p>支持脚本化运行</p>
</li>
<li><p>哈希冲突解决<br> 少量的冲突redis使用链式哈希解决，当链表过长时redis会触发rehash机制，rehash机制会增加现有hash桶的数量，分散entry元素</p>
</li>
</ol>
<ul>
<li><p><strong>rehash机制</strong><br>  redis有两张全局hash表，hash1,hash2，起初hash2没有分配空间<br>  当触发rehash时：<br>  会给hash2分配更大的空间，重设hash函数，增加hash桶总量，把hash1重新映射到hash2，释放hash1</p>
</li>
<li><p><strong>渐进式rehash机制</strong><br>  由于rehash机制非常耗时，会阻塞redis<br>  所以将集中迁移改为分散迁移，当处理一个请求时，就从hash1中的第一个索引位置开始，把位置1的所有entries重新映射到hash2中。</p>
</li>
</ul>
<h1 id="单线程的redis为什么这么快？"><a href="#单线程的redis为什么这么快？" class="headerlink" title=" 单线程的redis为什么这么快？"></a> 单线程的redis为什么这么快？</h1><ol>
<li>首先redis并不是真正意义上的单线程，比如持久化，异步删除，集群同步，都是用额外的线程完成的</li>
<li>为什么不用多线程，多线程访问共享资源，需要增加额度的机制，就会带来额外的开销</li>
<li>redis大部分操作都是在内存中完成，加上采用的高效的数据结构，例如hash表，跳表</li>
<li>redis采用多路复用机制，使其能够并发处理大量客户端请求</li>
</ol>
<h1 id="数据同步：主从库如何实现数据同步？"><a href="#数据同步：主从库如何实现数据同步？" class="headerlink" title="数据同步：主从库如何实现数据同步？"></a>数据同步：主从库如何实现数据同步？</h1><h2 id="redis具有高可用，是什么意思？"><a href="#redis具有高可用，是什么意思？" class="headerlink" title="redis具有高可用，是什么意思？"></a>redis具有高可用，是什么意思？</h2><p>二层意思，一是数据尽量少丢失，二是服务尽量少中断，AOF和RDB保证了一，对于二redis通过增加冗余副本量。</p>
<h2 id="redis提供了主从库模式，以保证数据副本的一致，主从库采用了"><a href="#redis提供了主从库模式，以保证数据副本的一致，主从库采用了" class="headerlink" title="redis提供了主从库模式，以保证数据副本的一致，主从库采用了"></a>redis提供了主从库模式，以保证数据副本的一致，主从库采用了</h2><p>读写分离的方式。</p>
<ul>
<li><strong>读操作：</strong> 主库，从库都可以接送。</li>
<li><strong>写操作：</strong> 只有主库能接收执行，然后主库同步给从库执行。</li>
</ul>
<h2 id="第一次如何同步？"><a href="#第一次如何同步？" class="headerlink" title="第一次如何同步？"></a>第一次如何同步？</h2><p>从库和主库建立连接后，会与主库协商第一次全量同步，主库会进行RDB内存快照和传输RDB内存快照。</p>
<h2 id="多个副本怎么分担主库全量复制压力？"><a href="#多个副本怎么分担主库全量复制压力？" class="headerlink" title="多个副本怎么分担主库全量复制压力？"></a>多个副本怎么分担主库全量复制压力？</h2><p>采用主-从-从模式</p>
<h2 id="全量复制完了之后如何同步？"><a href="#全量复制完了之后如何同步？" class="headerlink" title="全量复制完了之后如何同步？"></a>全量复制完了之后如何同步？</h2><p>基于长链接的命令传播</p>
<h2 id="主从库网络断开怎么办？"><a href="#主从库网络断开怎么办？" class="headerlink" title="主从库网络断开怎么办？"></a>主从库网络断开怎么办？</h2><p>主库会维护一个repl_backlog_buffer环状缓冲区，主库会记录自己写到的位置，从库会记录自己读到的位置，<br>当网络重连后主库会把master_rpl_offset 到 slave_repl_offset之间的命令同步到从库，</p>
<p>由于是环状的缓存区，当从库的同步速度小于主库的写入，当主库赶上从库就会需要重新进行全量复制。<br>常规的避免办法是增加repl_backlog_buffer缓存区容量。设置repl_backlog_size。</p>
<h1 id="哨兵机制，主库挂了，如何不间断服务？"><a href="#哨兵机制，主库挂了，如何不间断服务？" class="headerlink" title="哨兵机制，主库挂了，如何不间断服务？"></a>哨兵机制，主库挂了，如何不间断服务？</h1><h2 id="哨兵三大功能-监控，选主，通知"><a href="#哨兵三大功能-监控，选主，通知" class="headerlink" title="哨兵三大功能   监控，选主，通知"></a>哨兵三大功能   监控，选主，通知</h2><ol>
<li><strong>监控</strong>主库运行状态，并判断主库是否客观下线。</li>
<li>主库客观下线，<strong>选择新主库</strong>。</li>
<li>选出新主库，<strong>通知</strong>从库和客户端。</li>
</ol>
<h2 id="细节要点"><a href="#细节要点" class="headerlink" title="细节要点"></a>细节要点</h2><ol>
<li>哨兵的本质是一个redis实例。</li>
<li>哨兵通过心跳检测，监控主库状态，主库下线分为客观下线和主观下线。</li>
<li>哨兵监控是可能误判的，所以一般要集群部署，减少误判率。</li>
<li>选定主库先筛选打分，得分高的会被选为新主库。</li>
<li><strong>筛选规则：</strong> 从库的网络状况，之前与主库的连接状况，筛选中断标准可以配置。</li>
<li><strong>打分规则：</strong> 从库的优先级，数据同步状况，id号大小。</li>
</ol>
<h2 id="哨兵集群，哨兵挂了，主库还能切换吗？"><a href="#哨兵集群，哨兵挂了，主库还能切换吗？" class="headerlink" title="哨兵集群，哨兵挂了，主库还能切换吗？"></a>哨兵集群，哨兵挂了，主库还能切换吗？</h2><p>哨兵挂的数量少于<strong>quorum</strong>就可以，至少有<strong>2</strong>个哨兵才能执行主从切换。</p>
<ol>
<li>基于pub&#x2F;sub机制的哨兵集群组成过程。</li>
<li>基于INFO命令的从库列表，帮助哨兵与从库建立连接。</li>
<li>基于哨兵自身的pub&#x2F;sub功能，实现客户端和哨兵之间的事件通知。</li>
<li>判断主库客观下线需要投票，需要同意票数大于querum数量。</li>
<li>通过选举投票方式选出哨兵leader，执行主库切换通知。</li>
<li>要保证所以哨兵实例的配置是一致的，尤其是主观下线的判断值<strong>down-after-millseconds</strong>。</li>
</ol>
<h2 id="频道事件："><a href="#频道事件：" class="headerlink" title="频道事件："></a>频道事件：</h2><ul>
<li><strong>+sdown：</strong> 主观下线</li>
<li><strong>-sdown：</strong> 退出主观下线</li>
<li><strong>+odown：</strong> 客观下线</li>
<li><strong>-odown：</strong> 退出客观下线</li>
<li><strong>+slave-reconf-sent：</strong> 哨兵发送slaveof命令重新配置从库</li>
<li><strong>+slave-reconf-inprog：</strong> 从库配置成新主库 同步中</li>
<li><strong>+slave-reconf-done：</strong> 从库配置成新主库 完成同步</li>
<li><strong>+switch-mater：</strong> 主库地址发生变化</li>
</ul>
<h1 id="数据量增多了，是该加内存还是该加实例？"><a href="#数据量增多了，是该加内存还是该加实例？" class="headerlink" title="数据量增多了，是该加内存还是该加实例？"></a>数据量增多了，是该加内存还是该加实例？</h1><h2 id="当数据量增大时，通常会有两种选择"><a href="#当数据量增大时，通常会有两种选择" class="headerlink" title="当数据量增大时，通常会有两种选择"></a>当数据量增大时，通常会有两种选择</h2><ul>
<li><strong>纵向扩展：</strong>加内存</li>
<li><strong>横向扩展：</strong>加实例</li>
</ul>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><ul>
<li><strong>纵向扩展：</strong><br>  <strong>优点：</strong> 实施简单，直接<br>  <strong>缺点：</strong> RDB时间长，硬件以及成本有上限</li>
<li><strong>横向扩展：</strong><br>  <strong>优点：</strong> 没有硬件和成本限制<br>  <strong>缺点：</strong> 增加系统了复杂度</li>
</ul>
<h2 id="切片集群数据该存哪儿？"><a href="#切片集群数据该存哪儿？" class="headerlink" title="切片集群数据该存哪儿？"></a>切片集群数据该存哪儿？</h2><p>redis cluster官方解决方案采用哈希槽，hash-slot，一个切片集群共有16384个哈希槽。<br>通过CRC16算法计算出一个16bit的值，然后取模16384得到对应哈希槽。<br>redis cluster根据实例数量平均分配哈希槽，也可以通过cluster meet,cluster addslots手动配置搭建。<br>手动配置需要把16384个槽分配完，否则无法工作。</p>
<h2 id="客户端如何定位数据？"><a href="#客户端如何定位数据？" class="headerlink" title="客户端如何定位数据？"></a>客户端如何定位数据？</h2><p>切片集群会共享各自的哈希槽信息，客户端与实例建立连接时，会把哈希槽的信息发送给客户端。<br>但是在集群新增或者减少实例的时候，redis需要重新分配哈希槽。 还有为了负载均衡，redis需要把哈希槽所有实例重新分配一遍，这就可能带来客户端哈希槽信息与服务器不一致的问题。<br>    这时redis cluster 方案提供了一种重定向机制，客户端给一个实例发送读写操作时，数据槽不在这个实例，需要重定向发送到另一个实例。<br>    重定向地址如何知晓，请求的第一个redis实例会返回错误，加上重定向的实例连接信息。（error） MOVED slotID  ip:port</p>
<h2 id="ask重定向？"><a href="#ask重定向？" class="headerlink" title="ask重定向？"></a>ask重定向？</h2><p>当哈希槽正在迁移，命令落中正在迁移的槽时，会回复 ASK slotID ip:port</p>
<h1 id="aof日志，宕机了，如何避免数据丢失？"><a href="#aof日志，宕机了，如何避免数据丢失？" class="headerlink" title="aof日志，宕机了，如何避免数据丢失？"></a>aof日志，宕机了，如何避免数据丢失？</h1><ol>
<li>aof通过逐一记录命令，恢复时逐一执行命令来保证数据的可靠性。</li>
<li>aof提供了三种写回策略，<strong>always,everysec,no</strong>。</li>
<li>aof重写机制，避免日志文件过大，这个过程是fork子进程拷贝父进程内存数据，直接根据数据库里数据的最新状态，生成这些数据的插入命令。</li>
<li>aof在恢复时，需要重放aof日志命令，这个过程会比较慢，RDB快照恢复会比aof快。</li>
</ol>
<h1 id="RDB内存快照，宕机了，redis如何快速恢复？"><a href="#RDB内存快照，宕机了，redis如何快速恢复？" class="headerlink" title="RDB内存快照，宕机了，redis如何快速恢复？"></a>RDB内存快照，宕机了，redis如何快速恢复？</h1><p>redis提供save,和bgsave两个命令来生成RDB快照<br>save在主线程中执行，会导致阻塞<br>bgsave创建一个子进程，避免了主线程的阻塞</p>
<h2 id="快照时数据还能修改吗？"><a href="#快照时数据还能修改吗？" class="headerlink" title="快照时数据还能修改吗？"></a>快照时数据还能修改吗？</h2><p>快照时，子进程和主进程访问的同一块内存，正常情况下，快照完成前，只能读不能写，但是redis借助了操作系统的写时复制技术，在快照期间，可以执行写命令。</p>
<h2 id="快照可以每秒执行一次吗"><a href="#快照可以每秒执行一次吗" class="headerlink" title="快照可以每秒执行一次吗?"></a>快照可以每秒执行一次吗?</h2><p>虽然执行快照不会影响主线程，但是会给磁盘带来很大压力，而且快照可能一秒内完成不了。redis上一个bgsave在运行，不能启动第二个bgsave。</p>
<h2 id="有什么办法既可以利用RDB的快速恢复又可以做到尽量少丢数据呢？"><a href="#有什么办法既可以利用RDB的快速恢复又可以做到尽量少丢数据呢？" class="headerlink" title="有什么办法既可以利用RDB的快速恢复又可以做到尽量少丢数据呢？"></a>有什么办法既可以利用RDB的快速恢复又可以做到尽量少丢数据呢？</h2><p>混合使用AOF日志和RDB快照，这样AOF日志只有记录两次快照之间的命令了</p>
<h1 id="string类型为什么不好用了？"><a href="#string类型为什么不好用了？" class="headerlink" title="string类型为什么不好用了？"></a>string类型为什么不好用了？</h1><p>string类型在保存本身占用的内存空间不大时，string类型的元数据开销就会占主导地位，这里面包括redis_object，SDS结构，dict_entry结构的内存开销。</p>
<h2 id="那内存占用是怎么多出来的呢？"><a href="#那内存占用是怎么多出来的呢？" class="headerlink" title="那内存占用是怎么多出来的呢？"></a>那内存占用是怎么多出来的呢？</h2><p>redis使用一个全局哈希表保存所以键值对，每一项都是dict_entry结构体，用来指向一个键值对，分别指向key,value,next，三个指针一共24字节，由于jemalloc的内存分配机制，会实际分配最接近2的幂次数，所以24字节，实际分配32字节。<br>然后还有分配一个key和value的redis_object对象，一个redis_object对象至少占用16字节，2个就是32，所以使用一个string类型保存数据至少要64字节。</p>
<p><img src="/img/redis/redis_object.jpg" srcset="/img/loading.gif" lazyload><br><img src="/img/redis/keys.webp" srcset="/img/loading.gif" lazyload></p>
<h2 id="动态字符串的编码方式有3种："><a href="#动态字符串的编码方式有3种：" class="headerlink" title="动态字符串的编码方式有3种："></a>动态字符串的编码方式有3种：</h2><ul>
<li><strong>int编码：</strong> ptr指针位直接用于保存整型</li>
<li><strong>embstr编码：</strong> 当string内容小于等于44字节时候，redis_object和sds数据使用一块连续的内存，也就是整个数据块小于等于64字节。</li>
<li><strong>row编码：</strong> redis_object和SDS内存地址可能不连续。</li>
</ul>
<p><img src="/img/redis/code.webp" srcset="/img/loading.gif" lazyload></p>
<h2 id="那用什么数据可以节省内存？"><a href="#那用什么数据可以节省内存？" class="headerlink" title="那用什么数据可以节省内存？"></a>那用什么数据可以节省内存？</h2><p>redis的hash，list，zset，set在元素小于配置限制内时会使用intset整数数组，ziplist压缩列表来存储数据。</p>
<ul>
<li><strong>hash：</strong> zliblist，hash</li>
<li><strong>list：</strong> zliblist，双向链表</li>
<li><strong>zset：</strong> zliblist，跳表</li>
<li><strong>set：</strong> intset，hash</li>
</ul>
<h2 id="压缩列表的构成"><a href="#压缩列表的构成" class="headerlink" title="压缩列表的构成"></a>压缩列表的构成</h2><p>表头有zlibytes，zltail，zllen，分别表示列表长度，列表尾的偏移量，以及列表的entry个数，压缩列表之所以可以节省内存，是因为它是用一系列连续的entry保存数据。</p>
<h2 id="entry结构"><a href="#entry结构" class="headerlink" title="entry结构"></a>entry结构</h2><ul>
<li><strong>prev_len：</strong> 表示前一个entry的长度，1或5字节</li>
<li><strong>len：</strong> 表示自身长度，4字节</li>
<li><strong>encoding：</strong> 1字节</li>
<li><strong>content：</strong> 保存实际数据</li>
</ul>
<p>如果实际数据是int类型8字节，总共是1+4+1+8&#x3D;14字节往上适配是16字节。<br>这样新增一个数据只需要16字节，少了dict_entry和2个redis_object的创建，比使用string类型少了48字节。</p>
<h2 id="inset结构"><a href="#inset结构" class="headerlink" title="inset结构"></a>inset结构</h2><pre><code class="hljs">uint32_t encoding;
uint_32_t length;
int8_t contents[];
</code></pre>
<ol>
<li>inset在元素是整型结果的时候使用。</li>
<li>inset会根据encoding编码调整contents类型，当插入的元素字节长度大于之前所以元素的长度时会进行升级，调整contents的元素内存占用宽度，inset不会进行降级。</li>
<li>inset插入删除时间复杂度为o(n)，查找使用2分查找时间复杂度为o(log n)，查询长度为o(1)。</li>
</ol>
<p>相关配置：<br><strong>list:</strong> list-max-ziplist-size   -2表示8kb，最多8kb<br><strong>set:</strong> set-max-intset-entries   表示512个元素，最多512元素<br><strong>zset:</strong> zset-max-ziplist-size,zset-max-ziplist-value<br><strong>hash:</strong> hash-max-ziplist-size,hash-max-ziplist-value<br><strong>zset和hash，</strong> size和value 分别表示最多size个元素，值字节长度最大多少。</p>
<p>所以结构升级后不可降级。</p>
<h1 id="GEO是什么？"><a href="#GEO是什么？" class="headerlink" title="GEO是什么？"></a>GEO是什么？</h1><p>扩展类型之一，广泛用于LBS服务中，可以记录经纬度的地理位置信息，GEO是基于zset实现的。</p>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>geohash编码，基本原理是二分区间，区间编码</p>
<p>假如有一组经纬度为，经度100，纬度30。<br>经度范围是[180,-180]，纬度范围是[90,-90]。<br>geohash会分别把经度纬度编码成N位的二进制。<br>假如我们只编码两位经度为100。<br>设范围[0,-180]为0，范围[0,180]为1<br>此时编码为：1<br>然后再设[0,90]为0，[90,180]为1<br>此时编码为：11<br>根据此编码规则我们得知纬度30的编码为：10<br>然后geohash会以经度为奇纬度为偶的方式逐位交叉编码，得到1110，<br>然后把1110当做score存入zset。<br><img src="/img/redis/geo.webp" srcset="/img/loading.gif" lazyload></p>
<p>不过，有点编码值相近实际距离却很远，为了避免查询不准确的问题，我们可以同时查询给定经纬度的4个或8个方格。</p>
<h2 id="操作命令"><a href="#操作命令" class="headerlink" title="操作命令"></a>操作命令</h2><ul>
<li><strong>geoadd</strong> key 经度，纬度，members</li>
<li><strong>georadius</strong> key 经度，纬度，范围 其他参数</li>
</ul>
<h1 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h1><p>三大需求：<br>    消息保序<br>    重复消息处理<br>    消息可靠性保证</p>
<p>list：<br>    优点：简单易懂<br>    缺点：消息保序和消息可靠性需要自己实现策略保证</p>
<p>stream:<br>    优点：自动生成id，提供消费组形势读取数据，满足消息队列三大需求</p>
<h1 id="如何在redis中保存时间序列数据？"><a href="#如何在redis中保存时间序列数据？" class="headerlink" title="如何在redis中保存时间序列数据？"></a>如何在redis中保存时间序列数据？</h1><h2 id="使用场景，比如服务器每一秒的在线人数，各个游戏的在玩人数。查询需求"><a href="#使用场景，比如服务器每一秒的在线人数，各个游戏的在玩人数。查询需求" class="headerlink" title="使用场景，比如服务器每一秒的在线人数，各个游戏的在玩人数。查询需求"></a>使用场景，比如服务器每一秒的在线人数，各个游戏的在玩人数。<br>查询需求</h2><ol>
<li>1点钟的在线人数。 get单点查询。</li>
<li>1点到2点的最大在线人数，范围查询加sort排序。</li>
<li>1点到2点平均在线人数，聚合计算。<br>4 .1点到2点玩A游戏的人数比玩b游戏的人数的时间段多的百分比。</li>
</ol>
<h2 id="二种方案"><a href="#二种方案" class="headerlink" title="二种方案"></a>二种方案</h2><ol>
<li>使用hash+zset，可以满足1，2，3，4，但是3，4需要客户端请求拿到所以数据再聚合计算，数据传输开销大。</li>
<li>使用扩展类型RedisTimeSeries，专门为存取时间序列数据而设计的，可以满足2，3，避免了大量数据传输，不过底层用链表实现，范围查询的复杂度为o(n)。</li>
</ol>
<h2 id="方案优缺点"><a href="#方案优缺点" class="headerlink" title="方案优缺点"></a>方案优缺点</h2><ol>
<li>使用hash+zset<br> <strong>优点：</strong> 支持单点查询，范围查询的高效支持。<br> <strong>缺点：</strong> 聚合计算需要拿出来处理，网络数据传输量大。</li>
<li>使用扩展类型RedisTimeSeries<br> <strong>优点：</strong> 内部聚合计算，占用内存较低。<br> <strong>缺点：</strong> 仅仅支持最新数据的单点查询，范围查询时间复杂度为o(n)。</li>
</ol>
<h2 id="个人思考"><a href="#个人思考" class="headerlink" title="个人思考"></a>个人思考</h2><p>如果有全量的聚合计算且数据量较大优先使用redisTimeseries，因为全量的化，用hash，zset的时间复杂度也是o(n)</p>
<h1 id="有一亿个keys要统计，应该用哪种集合？"><a href="#有一亿个keys要统计，应该用哪种集合？" class="headerlink" title="有一亿个keys要统计，应该用哪种集合？"></a>有一亿个keys要统计，应该用哪种集合？</h1><ol>
<li>bitmap适合于二值状态统计，比如签到，登录统计，对比set,hash,zset,做聚合统计的效率会快，bitmap是o(1)是时间复杂度，其他类型至少都要o(N)。</li>
<li>hyperloglog适用于那种不需要非常精确的统计，比如网站的访问量，优势是占用内存低，一个key固定只需要12k，精准率81%，统计成员总数2的64次方。<br><img src="/img/redis/set.webp" srcset="/img/loading.gif" lazyload></li>
</ol>
<h1 id="redis单线程处理io瓶颈主要包括2个方面？"><a href="#redis单线程处理io瓶颈主要包括2个方面？" class="headerlink" title="redis单线程处理io瓶颈主要包括2个方面？"></a>redis单线程处理io瓶颈主要包括2个方面？</h1><ol>
<li><p>任意一个请求在server一旦发送耗时，都会影响整个server的性能，也就是说后面的请求都要等这个耗时请求处理完成，自己才能处理到<br> a、操作bigkey<br> b、使用复杂度过高的命令，当N基数很大时，非常耗时<br> c、大量key过期<br> d、淘汰策略，当内存达到设置上限后<br> e、AOF写盘开始always策略，写盘速度比写内存速度低太多<br> f、主从全量同步，fork生成快照完成之前，redis一直不可写</p>
</li>
<li><p>并发量非常大时，单线程读写客户端io数据存在性能瓶颈，虽然有多路复用，但是读写客户端数据依旧是同步io，只能单线程依次读取写入，无法利用多核。</p>
</li>
</ol>
<h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><ul>
<li><p><strong>针对问题1</strong> 人为规避，redis4.0推出了lazy-free异步释放内存</p>
</li>
<li><p><strong>针对问题2</strong> redis6.0推出多线程，并发场景下可以利用多核处理客户端io读写</p>
</li>
</ul>
<h1 id="异步机制：如何避免单线程模型的阻塞？"><a href="#异步机制：如何避免单线程模型的阻塞？" class="headerlink" title="异步机制：如何避免单线程模型的阻塞？"></a>异步机制：如何避免单线程模型的阻塞？</h1><h2 id="redis实例运行时的四大类交互对象客户端，磁盘，主从库实例，切片集群实例基于四大类交互对象，梳理了会导致redis性能受损的五大阻塞点："><a href="#redis实例运行时的四大类交互对象客户端，磁盘，主从库实例，切片集群实例基于四大类交互对象，梳理了会导致redis性能受损的五大阻塞点：" class="headerlink" title="redis实例运行时的四大类交互对象客户端，磁盘，主从库实例，切片集群实例基于四大类交互对象，梳理了会导致redis性能受损的五大阻塞点："></a>redis实例运行时的四大类交互对象客户端，磁盘，主从库实例，切片集群实例<br>基于四大类交互对象，梳理了会导致redis性能受损的五大阻塞点：</h2><ul>
<li>集合全量查询</li>
<li>聚合操作</li>
<li>bigkey删除</li>
<li>清空数据库</li>
<li>AOF日志同步写</li>
<li>从库加载RDB文件</li>
</ul>
<h2 id="阻塞性能受损原因："><a href="#阻塞性能受损原因：" class="headerlink" title="阻塞性能受损原因："></a>阻塞性能受损原因：</h2><ul>
<li>集合全量查询：操作时间复杂度为o(n)</li>
<li>聚合操作：操作时间复杂度&gt;&#x3D;o(n)</li>
<li>bigkey删除：虽然删除key看起来的只是简单的释放内存，不过操作还需要把内存插入到空闲列表进行管理和再分配</li>
<li>清空数据库：跟bigkey删除性质一样</li>
<li>AOF日志同步写：磁盘读写速度有目共睹</li>
<li>从库加载RDB文件：涉及到读文件，而且数据量大</li>
</ul>
<h2 id="可以异步优化的："><a href="#可以异步优化的：" class="headerlink" title="可以异步优化的："></a>可以异步优化的：</h2><ul>
<li>bigkey删除，清空数据库：开启lazyfree-lazy相关配置</li>
<li>AOF日志同步写：apendfsync配置项由always改为everysec或者no</li>
</ul>
<h2 id="不能异步优化的："><a href="#不能异步优化的：" class="headerlink" title="不能异步优化的："></a>不能异步优化的：</h2><ul>
<li>集合全量查询，聚合操作，从库加载RDB文件</li>
</ul>
<p>可以异步的是不在关键路径上的操作，比如内存释放啊，写盘等等</p>
<h2 id="不能异步的怎么优化："><a href="#不能异步的怎么优化：" class="headerlink" title="不能异步的怎么优化："></a>不能异步的怎么优化：</h2><ul>
<li>集合全量查询，聚合操作：客户端分批读取数据，再聚合计算</li>
<li>从库加载RDB文件：控制主库的数据总量</li>
</ul>
<h2 id="相关配置："><a href="#相关配置：" class="headerlink" title="相关配置："></a>相关配置：</h2><pre><code class="hljs">lazyfree-lazy
    lazy-free-lazy-expire：key在过期时异步释放内存
    lazy-free-lazy-eviction：内存达到maxmemory并设置了淘汰策略是尝试异步释放内存
    lazy-free-lazy-server-del：执行rename/move等命令或需要覆盖一个key时，删除旧key尝试异步释放内存
    replica-lazy-flush：主从全量同步时，从库清空数据库时异步释放内存
</code></pre>
<h2 id="相关命令："><a href="#相关命令：" class="headerlink" title="相关命令："></a>相关命令：</h2><p>unlink 删除key 异步释放内存<br>flushall aysnc   异步清除</p>
<h1 id="如何应对redis变慢"><a href="#如何应对redis变慢" class="headerlink" title="如何应对redis变慢?"></a>如何应对redis变慢?</h1><h2 id="怎么判断redis变慢？"><a href="#怎么判断redis变慢？" class="headerlink" title="怎么判断redis变慢？"></a>怎么判断redis变慢？</h2><ol>
<li><p>查看redis运行时响应延迟： redis-cli –latency -h host -p port<br>如果延迟达到一秒或一秒以上，基本可以认定redis变慢了。</p>
</li>
<li><p>当前环境的基线性能：redis-cli –intrinsic-latency  120<br>如果运行时响应延迟是基线性能的2倍以上，就可以认定redis变慢了。</p>
</li>
</ol>
<h2 id="如何解决redis变慢"><a href="#如何解决redis变慢" class="headerlink" title="如何解决redis变慢?"></a>如何解决redis变慢?</h2><p><img src="/img/redis/frame.webp" srcset="/img/loading.gif" lazyload></p>
<p>redis自身的操作特性，操作系统，文件系统，它们是影响redis性能的三大要素。</p>
<p><strong>一：自身的操作特性</strong></p>
<ol>
<li><p>慢查询命令<br> <strong>原因：</strong> sunion,sort,smembers操作复杂度分别是O(N + M*log(M))和O(N)，时间复杂度过高。<br> <strong>定位方式：</strong> redis日志或者latency monitor工具。<br> <strong>解决办法：</strong> 用其他命令代替，比如sscan，排序，交集，并集可以放在客户端做。</p>
</li>
<li><p>KEYS命令<br> <strong>原因：</strong> 遍历所以keys，比如redis有1百万个keys，就会遍历1百万次，时间复杂度为O(N。<br> <strong>解决办法：</strong> 不用，或者直接禁用。</p>
</li>
<li><p>过期key操作<br> <strong>删除机制：</strong> </p>
<ol>
<li>ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP &#x3D; 20默认配置，100毫秒删除20个过期key，1秒删除200个，</li>
<li>如果超过25%的key过期了，则重复删除的过程，直到过期key的比例降至25%以下。<br> <strong>原因：</strong> 过期key的删除是主线程在执行，触发机制2可能存在影响。<br> <strong>解决办法：</strong> 避免大量key同时设置相同的过期时间，比如在固定过期时间后面加一个小范围的随机时间。</li>
</ol>
</li>
</ol>
<p><strong>二：文件系统：AOF</strong></p>
<p>always同步写盘，每次都会等待写完磁盘。<br>everysec，每秒fork一个子线程来完成写磁盘，不过上一次fork的写盘任务没有完成，那么就会阻塞，特别是aof重写的时候，磁盘io压力较大，可能会造成阻塞。</p>
<p><strong>相关配置：</strong><br>    appendfsync<br>    no-appendfsync-on-rewrite</p>
<p><strong>三：操作系统：swap</strong><br>    当系统内存不够的时候，系统会用磁盘模拟内存，window叫虚拟内存，可以想象磁盘当内存用，当然性能会下降。<br>    查看方式：cd &#x2F;proc&#x2F;进程号<br>                    cat smaps | egrep ‘^(Swap|Size)’</p>
<p><strong>四：内存大页</strong><br>    内存大页机制（Transparent Huge Page THP）<br>    linux内核从2.6.38开始支持大页机制，该机制支持2M大小的内存页分配，常规的只有4kb的粒度来执行的。<br>    RDB内存快照写时复制机制，当内存块数据需要修改时，会将这些数据拷贝一份，然后进行修改，这时候大页机制可能会影响到性能了。<br>    如何关闭：<br>         cat &#x2F;sys&#x2F;kernel&#x2F;mm&#x2F;transparent_hugepage&#x2F;enabled<br>        如果结果是always表示是开启的，如果是never表示禁止了。<br>生产中不建议对Redis的实例运行的机器开启大页<br>        关闭命令：<br>        echo never &#x2F;sys&#x2F;kernel&#x2F;mm&#x2F;transparent_hugepage&#x2F;enabled</p>
<h1 id="删除数据后，为什么内存占用率还是很高？"><a href="#删除数据后，为什么内存占用率还是很高？" class="headerlink" title="删除数据后，为什么内存占用率还是很高？"></a>删除数据后，为什么内存占用率还是很高？</h1><h2 id="明明删除了数据，但是redis占用内存没有降下来？"><a href="#明明删除了数据，但是redis占用内存没有降下来？" class="headerlink" title="明明删除了数据，但是redis占用内存没有降下来？"></a>明明删除了数据，但是redis占用内存没有降下来？</h2><p>这是应该redis释放的内存空间被内存分配管理器管理，并不会立即返回给操作系统。<br>风险点：删除数据，如果删除的是连续空间，那么这个连续空间可以继续用来存储数据;如果不是连续空间，仍然是属于操作系统分配给redis的物理内存，但无法用来存储数据。</p>
<h2 id="内存碎片是什么？"><a href="#内存碎片是什么？" class="headerlink" title="内存碎片是什么？"></a>内存碎片是什么？</h2><p>应用申请的内存是连续的一块N大小的内存空间，不满足N大小的内存块就是内存碎片，无法利用。</p>
<h2 id="内存碎片的形成原因"><a href="#内存碎片的形成原因" class="headerlink" title="内存碎片的形成原因"></a>内存碎片的形成原因</h2><ol>
<li><strong>内因：</strong> 内存分配器分配机制。</li>
<li><strong>外因：</strong> 键值对大小不一样和删除操作。</li>
</ol>
<h2 id="如何判断是否有内存碎片？"><a href="#如何判断是否有内存碎片？" class="headerlink" title="如何判断是否有内存碎片？"></a>如何判断是否有内存碎片？</h2><pre><code class="hljs">命令： INFO memory
mem_fragmentation_ratio 表示内存碎片率，rss/use_memory
use_memory_rss                实际分配内存               
use_memory                      实际使用内存
</code></pre>
<h2 id="合理范围"><a href="#合理范围" class="headerlink" title="合理范围"></a>合理范围</h2><pre><code class="hljs">ratio在1到1.5之间
</code></pre>
<h2 id="如何清理内存碎片？"><a href="#如何清理内存碎片？" class="headerlink" title="如何清理内存碎片？"></a>如何清理内存碎片？</h2><pre><code class="hljs">重启redis
redis自动清理机制：搬家让位，合并空间
不过碎片清理是有代价的
</code></pre>
<h2 id="相关配置：-1"><a href="#相关配置：-1" class="headerlink" title="相关配置："></a>相关配置：</h2><pre><code class="hljs">activedefrag    开关
activedefrag-ignore-bytes 100mb    表示内存碎片达到100mb，开始清理
activedefrag-threshold-lower 10   表示内存碎片空间占redis总分配空间的10%，开始清理
activedefrag-cycle-min 25    表示自动清理过程所用cpu时间比例不低于25%
activedefrag-cycle-max 75   表示自动清理过程所用cpu时间比例不高于75%
</code></pre>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后，我再给你提供一个小贴士：内存碎片自动清理涉及内存拷贝，这对 Redis 而言，是个潜在的风险。如果你在实践过程中遇到 Redis 性能变慢，记得通过日志看下是否正在进行碎片清理。如果 Redis 的确正在清理碎片，那么，我建议你调小 active-defrag-cycle-max 的值，以减轻对正常请求处理的影响。</p>
<h1 id="缓冲区，一个可以引发惨案的地方"><a href="#缓冲区，一个可以引发惨案的地方" class="headerlink" title="缓冲区，一个可以引发惨案的地方"></a>缓冲区，一个可以引发惨案的地方</h1><h2 id="缓冲区主要有两个应用场景："><a href="#缓冲区主要有两个应用场景：" class="headerlink" title="缓冲区主要有两个应用场景："></a>缓冲区主要有两个应用场景：</h2><ol>
<li>在客户端与服务端进行通信时，用来存在客户端和命令，和服务端返回给客户端的数据。</li>
<li>在主从同步进行时，用来存放主节点接收的写命令和数据。</li>
</ol>
<h2 id="风险："><a href="#风险：" class="headerlink" title="风险："></a>风险：</h2><p>由于缓冲区写入速度大于读出速度，引发缓冲区溢出，造成数据丢失。<br>缓冲区过大，耗尽机器内存，导致redis实例崩溃。</p>
<p>客户端输入，输出缓冲区<br><img src="/img/redis/cache.webp" srcset="/img/loading.gif" lazyload></p>
<h2 id="如何应对输入缓存区溢出："><a href="#如何应对输入缓存区溢出：" class="headerlink" title="如何应对输入缓存区溢出："></a>如何应对输入缓存区溢出：</h2><ul>
<li><strong>如何检测：</strong> client list命令查看，qbuf(已使用大小)，qbuf-free(未使用大小)，通常qbuf很大，qbuf-free很小，就要注意了。</li>
<li><strong>应对方法：</strong></li>
</ul>
<pre><code class="hljs">1. 调大缓存区，没有配置，代码写死1G。
2. 从数据命令的发送和处理入手，避免写入bigkey，避免redis主线程阻塞。
</code></pre>
<h2 id="如何应对输出缓存区溢出："><a href="#如何应对输出缓存区溢出：" class="headerlink" title="如何应对输出缓存区溢出："></a>如何应对输出缓存区溢出：</h2><p><strong>常见溢出场景：</strong><br>        返回bigkey的执行结果。<br>        monitor命令。<br>        缓冲区大小设置不合理。</p>
<h2 id="如何设置输出缓存区大小："><a href="#如何设置输出缓存区大小：" class="headerlink" title="如何设置输出缓存区大小："></a>如何设置输出缓存区大小：</h2><p>output-buffer-limit配置<br>普通客户端：output-buffer-limit normal 0 0 0   –0表示不做限制<br>订阅客户端：output-buffer-limit pubsub 8mb 2mb 60  –8mb表示总量限制，2mb和60表示，60秒内不超过2mb的缓冲器占用，超过就是与该客户端断开连接。</p>
<h1 id="redis为什么适合做缓存"><a href="#redis为什么适合做缓存" class="headerlink" title="redis为什么适合做缓存"></a>redis为什么适合做缓存</h1><p>在分层系统中，数据暂存与快速子系统有助于加速访问，缓存容量有限，缓存写满时需要淘汰机制，而redis天然满足这两个特性，所以非常适合做缓存。</p>
<p>redis做缓存时通常有两种模式：</p>
<ol>
<li>只读缓存：<br> 数据有修改会直接改数据库，改完删除缓存，下次有读取请求会先从数据库读出数据，然后写入redis缓存，之后的读取命令都会命中缓存。<br> 好处，可以保证数据库的数据是最新的，适用与读多写少或者对数据安全性要求较高的业务。</li>
<li>读写缓存：<br> 数据有修改先改缓存，再改数据库，有两种策略，同步只写，和异步写回。<br> 同步直写：<br>     优点：可以保证数据安全性。<br>     缺点：降低性能。<br> 异步写回：<br>     优点：提高业务响应速度。<br>     缺点：有数据丢失风险。</li>
</ol>
<h1 id="缓存满了，怎么办"><a href="#缓存满了，怎么办" class="headerlink" title="缓存满了，怎么办"></a>缓存满了，怎么办</h1><p>缓存应该设置多大，8，2定律，也就是将缓存区的容量设置为总数据量的20%，能拦截80%的访问量。</p>
<p>redis的缓存淘汰策略：<br>redis总共有8种缓存淘汰策略：<br>按机制可以分为5大类：<br>*	<strong>不淘汰机制：</strong> noeviction<br>    <strong>随机淘汰机制：</strong> allkeys-random，volatile-random<br>    <strong>最快过期机制：</strong> volatile-ttl<br>    <strong>最冷淘汰机制：</strong> allkeys-lru,volatile-lru<br>    <strong>最少访问淘汰机制：</strong> allkeys-lfu，volatile-lfu</p>
<h1 id="常见缓存异常场景"><a href="#常见缓存异常场景" class="headerlink" title="常见缓存异常场景"></a>常见缓存异常场景</h1><p>常见4个异常场景：<strong>数据不一致，缓存雪崩，缓存穿透，缓存击穿</strong></p>
<p>数据缓存：读写缓存，只读缓存</p>
<ul>
<li><p><strong>读写缓存：</strong><br>  <strong>同步策略：</strong> 异步写库，同步直写<br>  <strong>优点：</strong> 异步写库，可以提升系统的吞吐量，同步直写，可以保证数据一致性。<br>  <strong>缺点：</strong> 异步写库，可能出现数据丢失，同步直写，会降低系统吞吐量。</p>
</li>
<li><p><strong>只读缓存：</strong><br>  <strong>策略顺序：</strong> 先删库，再删缓存。 先删缓存后删库。<br>  <strong>问题：</strong> 脏数据。<br><img src="/img/redis/cache1.webp" srcset="/img/loading.gif" lazyload></p>
</li>
</ul>
<h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p><strong>原因：</strong> 大量热点key同时过期，导致大量请求落到数据库。<br><strong>解决办法：</strong></p>
<ol>
<li>在设置过期时间时增加随机过期时间。</li>
<li>服务降级。</li>
</ol>
<h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p><strong>原因：</strong> 某个热点数据，无法在缓存中处理，导致压力全部落到数据库。<br><strong>解决办法：</strong> 热点数据不设置过期时间。</p>
<h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p><strong>原因：</strong> 数据不存在。<br><strong>解决办法：</strong></p>
<ol>
<li>布隆过滤器。</li>
<li>设置代表空值的缓存信息。</li>
</ol>
<p><img src="/img/redis/cache2.webp" srcset="/img/loading.gif" lazyload></p>
<h1 id="事务功能，ADIC能保证吗？"><a href="#事务功能，ADIC能保证吗？" class="headerlink" title="事务功能，ADIC能保证吗？"></a>事务功能，ADIC能保证吗？</h1><ul>
<li><p><strong>原子性(Atomicity)</strong><br>概念：一系列操作要不都成功，要么都失败。<br>redis并没有提供回滚操作，不能保证原子性。</p>
</li>
<li><p><strong>一致性(Consistency)</strong><br>概念：数据库中的数据在执行前后是一致的。<br>可以保证，错误的命令不会执行。</p>
</li>
<li><p><strong>隔离性(lsolation)</strong><br>概念：事务执行期间，其他操作无法取到执行事务访问的数据。<br>可以保证，入队有watch命令监控保证，执行由单线程天然保证。</p>
</li>
<li><p><strong>持久性(Durability)</strong><br>持久化数据。<br>不能保证，不管是开启aof还是RDB，都存在数据丢失的可能。</p>
</li>
</ul>
<p><img src="/img/redis/ADIC.webp" srcset="/img/loading.gif" lazyload></p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/redis/" class="category-chain-item">redis</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/redis/">#redis</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>redis 知识杂谈</div>
      <div>https://huahua132.github.io/2023/05/13/redis/redis/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>huahua132</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年5月13日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/05/14/socket/tcp/" title="tcp知识整理">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">tcp知识整理</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/05/13/skynet_frame/frame/" title="skynet c层的整体架构">
                        <span class="hidden-mobile">skynet c层的整体架构</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
